{
    "absolute_path_to_file_in_container": "/smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java",
    "errors": [
        {
            "line_number": 30,
            "message": "[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[30,19] cannot find symbol",
            "additional_info": "  symbol:   class ElementTraversal\n  location: package org.w3c.dom",
            "file_name": "ElementImpl.java",
            "uid": "57870184-1eae-5d9d-9ed6-095c47601c45"
        },
        {
            "line_number": 67,
            "message": "[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[67,25] cannot find symbol",
            "additional_info": "  symbol: class ElementTraversal",
            "file_name": "ElementImpl.java",
            "uid": "649f8acc-a3e8-540a-8c4e-dbba69d1fd95"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nthe following client code fails: \n'''java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom;\n\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.*;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrNSImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.ChildNode;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.ParentNode;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.util.URI;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.ElementTraversal;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.w3c.dom.TypeInfo;\n\n/**\n * Elements represent most of the \"markup\" and structure of the\n * document.  They contain both the data for the element itself\n * (element name and attributes), and any contained nodes, including\n * document text (as children).\n * <P>\n * Elements may have Attributes associated with them; the API for this is\n * defined in Node, but the function is implemented here. In general, XML\n * applications should retrive Attributes as Nodes, since they may contain\n * entity references and hence be a fairly complex sub-tree. HTML users will\n * be dealing with simple string values, and convenience methods are provided\n * to work in terms of Strings.\n * <P>\n * ElementImpl does not support Namespaces. ElementNSImpl, which inherits from\n * it, does.\n * \n * @xerces.internal\n * \n * @see ElementNSImpl\n *\n * @author Arnaud  Le Hors, IBM\n * @author Joe Kesselman, IBM\n * @author Andy Clark, IBM\n * @author Ralf Pfeiffer, IBM\n * @author Michael Glavassevich, IBM\n * @version $Id$\n * @since  PR-DOM-Level-1-19980818.\n */\npublic class ElementImpl\n    extends ParentNode\n    implements Element, ElementTraversal, TypeInfo {\n\n    //\n    // Constants\n    //\n\n    /** Serialization version. */\n    static final long serialVersionUID = 3717253516652722278L;\n    //\n    // Data\n    //\n\n    /** Element name. */\n    protected String name;\n\n    /** Attributes. */\n    protected AttributeMap attributes;\n\n    //\n    // Constructors\n    //\n\n    /** Factory constructor. */\n    public ElementImpl(CoreDocumentImpl ownerDoc, String name) {\n    \tsuper(ownerDoc);\n        this.name = name;\n        needsSyncData(true);    // synchronizeData will initialize attributes\n    }\n\n    // for ElementNSImpl\n    protected ElementImpl() {}\n\n    // Support for DOM Level 3 renameNode method.\n    // Note: This only deals with part of the pb. CoreDocumentImpl\n    // does all the work.\n    void rename(String name) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            int colon1 = name.indexOf(':');\n            if(colon1 != -1){\n                String msg =\n                    DOMMessageFormatter.formatMessage(\n                            DOMMessageFormatter.DOM_DOMAIN,\n                            \"NAMESPACE_ERR\",\n                            null);\n                throw new DOMException(DOMException.NAMESPACE_ERR, msg);\n            }\n            if (!CoreDocumentImpl.isXMLName(name, ownerDocument.isXML11Version())) {\n                String msg = DOMMessageFormatter.formatMessage(\n                        DOMMessageFormatter.DOM_DOMAIN,\n                        \"INVALID_CHARACTER_ERR\", null);\n                throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n                        msg);\n            }\n        }\n        this.name = name;\n        reconcileDefaultAttributes();\n    }\n\n    //\n    // Node methods\n    //\n\n\n    /**\n     * A short integer indicating what type of node this is. The named\n     * constants for this value are defined in the org.w3c.dom.Node interface.\n     */\n    public short getNodeType() {\n        return Node.ELEMENT_NODE;\n    }\n\n    /**\n     * Returns the element name\n     */\n    public String getNodeName() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        return name;\n    }\n\n    /**\n     * Retrieve all the Attributes as a set. Note that this API is inherited\n     * from Node rather than specified on Element; in fact only Elements will\n     * ever have Attributes, but they want to allow folks to \"blindly\" operate\n     * on the tree as a set of Nodes.\n     */\n    public NamedNodeMap getAttributes() {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n        return attributes;\n\n    } // getAttributes():NamedNodeMap\n\n    /**\n     * Return a duplicate copy of this Element. Note that its children\n     * will not be copied unless the \"deep\" flag is true, but Attributes\n     * are <i>always</i> replicated.\n     *\n     * @see Node#cloneNode(boolean)\n     */\n    public Node cloneNode(boolean deep) {\n\n    \tElementImpl newnode = (ElementImpl) super.cloneNode(deep);\n    \t// Replicate NamedNodeMap rather than sharing it.\n        if (attributes != null) {\n            newnode.attributes = (AttributeMap) attributes.cloneMap(newnode);\n        }\n    \treturn newnode;\n\n    } // cloneNode(boolean):Node\n\n    /**\n     * DOM Level 3 WD - Experimental.\n     * Retrieve baseURI\n     */\n    public String getBaseURI() {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        // Absolute base URI is computed according to \n        // XML Base (http://www.w3.org/TR/xmlbase/#granularity)\n        // 1. The base URI specified by an xml:base attribute on the element, \n        // if one exists\n        if (attributes != null) {\n            final Attr attrNode = getXMLBaseAttribute();\n            if (attrNode != null) {\n                final String uri =  attrNode.getNodeValue();\n                if (uri.length() != 0) {// attribute value is always empty string\n                    try {\n                        URI _uri = new URI(uri, true);\n                        // If the URI is already absolute return it; otherwise it's relative and we need to resolve it.\n                        if (_uri.isAbsoluteURI()) {\n                            return _uri.toString();\n                        }\n                        \n                        // Make any parentURI into a URI object to use with the URI(URI, String) constructor\n                        String parentBaseURI = (this.ownerNode != null) ? this.ownerNode.getBaseURI() : null;\n                        if (parentBaseURI != null) {\n                            try {\n                                URI _parentBaseURI = new URI(parentBaseURI);\n                                _uri.absolutize(_parentBaseURI);\n                                return _uri.toString();\n                            }\n                            catch (URI.MalformedURIException ex) {\n                                // This should never happen: parent should have checked the URI and returned null if invalid.\n                                return null;\n                            }\n                        }\n                        // REVISIT: what should happen in this case?\n                        return null; \n                    }\n                    catch (URI.MalformedURIException ex) {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        // 2.the base URI of the element's parent element within the \n        // document or external entity, if one exists \n        // 3. the base URI of the document entity or external entity \n        // containing the element\n\n        // ownerNode serves as a parent or as document\n        return (this.ownerNode != null) ? this.ownerNode.getBaseURI() : null;\n    } //getBaseURI\n    \n    /**\n     * NON-DOM\n     * Returns the xml:base attribute.\n     */\n    protected Attr getXMLBaseAttribute() {\n        return (Attr) attributes.getNamedItem(\"xml:base\");\n    } // getXMLBaseAttribute():Attr\n\n    /**\n     * NON-DOM\n     * set the ownerDocument of this node, its children, and its attributes\n     */\n    protected void setOwnerDocument(CoreDocumentImpl doc) {\n        super.setOwnerDocument(doc);\n        if (attributes != null) {\n            attributes.setOwnerDocument(doc);\n        }\n    }\n\n    //\n    // Element methods\n    //\n\n    /**\n     * Look up a single Attribute by name. Returns the Attribute's\n     * string value, or an empty string (NOT null!) to indicate that the\n     * name did not map to a currently defined attribute.\n     * <p>\n     * Note: Attributes may contain complex node trees. This method\n     * returns the \"flattened\" string obtained from Attribute.getValue().\n     * If you need the structure information, see getAttributeNode().\n     */\n    public String getAttribute(String name) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return \"\";\n        }\n        Attr attr = (Attr)(attributes.getNamedItem(name));\n        return (attr == null) ? \"\" : attr.getValue();\n\n    } // getAttribute(String):String\n\n\n    /**\n     * Look up a single Attribute by name. Returns the Attribute Node,\n     * so its complete child tree is available. This could be important in\n     * XML, where the string rendering may not be sufficient information.\n     * <p>\n     * If no matching attribute is available, returns null.\n     */\n    public Attr getAttributeNode(String name) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return null;\n        }\n        return (Attr)attributes.getNamedItem(name);\n\n    } // getAttributeNode(String):Attr\n\n\n    /**\n     * Returns a NodeList of all descendent nodes (children,\n     * grandchildren, and so on) which are Elements and which have the\n     * specified tag name.\n     * <p>\n     * Note: NodeList is a \"live\" view of the DOM. Its contents will\n     * change as the DOM changes, and alterations made to the NodeList\n     * will be reflected in the DOM.\n     *\n     * @param tagname The type of element to gather. To obtain a list of\n     * all elements no matter what their names, use the wild-card tag\n     * name \"*\".\n     *\n     * @see DeepNodeListImpl\n     */\n    public NodeList getElementsByTagName(String tagname) {\n    \treturn new DeepNodeListImpl(this,tagname);\n    }\n\n    /**\n     * Returns the name of the Element. Note that Element.nodeName() is\n     * defined to also return the tag name.\n     * <p>\n     * This is case-preserving in XML. HTML should uppercasify it on the\n     * way in.\n     */\n    public String getTagName() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n    \treturn name;\n    }\n\n    /**\n     * In \"normal form\" (as read from a source file), there will never be two\n     * Text children in succession. But DOM users may create successive Text\n     * nodes in the course of manipulating the document. Normalize walks the\n     * sub-tree and merges adjacent Texts, as if the DOM had been written out\n     * and read back in again. This simplifies implementation of higher-level\n     * functions that may want to assume that the document is in standard form.\n     * <p>\n     * To normalize a Document, normalize its top-level Element child.\n     * <p>\n     * As of PR-DOM-Level-1-19980818, CDATA -- despite being a subclass of\n     * Text -- is considered \"markup\" and will _not_ be merged either with\n     * normal Text or with other CDATASections.\n     */\n    public void normalize() {\n        // No need to normalize if already normalized.\n        if (isNormalized()) {\n            return;\n        }\n        if (needsSyncChildren()) {\n            synchronizeChildren();\n        }\n        ChildNode kid, next;\n        for (kid = firstChild; kid != null; kid = next) {\n            next = kid.nextSibling;\n\n            // If kid is a text node, we need to check for one of two\n            // conditions:\n            //   1) There is an adjacent text node\n            //   2) There is no adjacent text node, but kid is\n            //      an empty text node.\n            if ( kid.getNodeType() == Node.TEXT_NODE )\n            {\n                // If an adjacent text node, merge it with kid\n                if ( next!=null && next.getNodeType() == Node.TEXT_NODE )\n                {\n                    ((Text)kid).appendData(next.getNodeValue());\n                    removeChild( next );\n                    next = kid; // Don't advance; there might be another.\n                }\n                else\n                {\n                    // If kid is empty, remove it\n                    if ( kid.getNodeValue() == null || kid.getNodeValue().length() == 0 ) {\n                        removeChild( kid );\n                    }\n                }\n            }\n\n            // Otherwise it might be an Element, which is handled recursively\n            else if (kid.getNodeType() == Node.ELEMENT_NODE) {\n                kid.normalize();\n            }\n        }\n\n        // We must also normalize all of the attributes\n        if ( attributes!=null )\n        {\n            for( int i=0; i<attributes.getLength(); ++i )\n            {\n                Node attr = attributes.item(i);\n                attr.normalize();\n            }\n        }\n\n    \t// changed() will have occurred when the removeChild() was done,\n    \t// so does not have to be reissued.\n\n        isNormalized(true);\n    } // normalize()\n\n    /**\n     * Remove the named attribute from this Element. If the removed\n     * Attribute has a default value, it is immediately replaced thereby.\n     * <P>\n     * The default logic is actually implemented in NamedNodeMapImpl.\n     * PR-DOM-Level-1-19980818 doesn't fully address the DTD, so some\n     * of this behavior is likely to change in future versions. ?????\n     * <P>\n     * Note that this call \"succeeds\" even if no attribute by this name\n     * existed -- unlike removeAttributeNode, which will throw a not-found\n     * exception in that case.\n     *\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n    public void removeAttribute(String name) {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return;\n        }\n\n        attributes.safeRemoveNamedItem(name);\n\n    } // removeAttribute(String)\n\n\n    /**\n     * Remove the specified attribute/value pair. If the removed\n     * Attribute has a default value, it is immediately replaced.\n     * <p>\n     * NOTE: Specifically removes THIS NODE -- not the node with this\n     * name, nor the node with these contents. If the specific Attribute\n     * object passed in is not stored in this Element, we throw a\n     * DOMException.  If you really want to remove an attribute by name,\n     * use removeAttribute().\n     *\n     * @return the Attribute object that was removed.\n     * @throws DOMException(NOT_FOUND_ERR) if oldattr is not an attribute of\n     * this Element.\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n    public Attr removeAttributeNode(Attr oldAttr)\n        throws DOMException {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n        }\n        return (Attr) attributes.removeItem(oldAttr, true);\n\n    } // removeAttributeNode(Attr):Attr\n\n\n    /**\n     * Add a new name/value pair, or replace the value of the existing\n     * attribute having that name.\n     *\n     * Note: this method supports only the simplest kind of Attribute,\n     * one whose value is a string contained in a single Text node.\n     * If you want to assert a more complex value (which XML permits,\n     * though HTML doesn't), see setAttributeNode().\n     *\n     * The attribute is created with specified=true, meaning it's an\n     * explicit value rather than inherited from the DTD as a default.\n     * Again, setAttributeNode can be used to achieve other results.\n     *\n     * @throws DOMException(INVALID_NAME_ERR) if the name is not acceptable.\n     * (Attribute factory will do that test for us.)\n     *\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n\tpublic void setAttribute(String name, String value) {\n\n\t\tif (ownerDocument.errorChecking && isReadOnly()) {\n\t\t\tString msg =\n\t\t\t\tDOMMessageFormatter.formatMessage(\n\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN,\n\t\t\t\t\t\"NO_MODIFICATION_ALLOWED_ERR\",\n\t\t\t\t\tnull);\n\t\t\tthrow new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n\t\t}\n\n\t\tif (needsSyncData()) {\n\t\t\tsynchronizeData();\n\t\t}\n\n\t\tAttr newAttr = getAttributeNode(name);\n\t\tif (newAttr == null) {\n\t\t\tnewAttr = getOwnerDocument().createAttribute(name);\n\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = new AttributeMap(this, null);\n\t\t\t}\n\n\t\t\tnewAttr.setNodeValue(value);\n\t\t\tattributes.setNamedItem(newAttr);\n\t\t}\n\t\telse {\n\t\t\tnewAttr.setNodeValue(value);\n\t\t}\n\n\t} // setAttribute(String,String)\n\n    /**\n     * Add a new attribute/value pair, or replace the value of the\n     * existing attribute with that name.\n     * <P>\n     * This method allows you to add an Attribute that has already been\n     * constructed, and hence avoids the limitations of the simple\n     * setAttribute() call. It can handle attribute values that have\n     * arbitrarily complex tree structure -- in particular, those which\n     * had entity references mixed into their text.\n     *\n     * @throws DOMException(INUSE_ATTRIBUTE_ERR) if the Attribute object\n     * has already been assigned to another Element.\n     */\n    public Attr setAttributeNode(Attr newAttr)\n        throws DOMException\n        {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n    \tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (newAttr.getOwnerDocument() != ownerDocument) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"WRONG_DOCUMENT_ERR\", null);\n    \t\t    throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);\n            }\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n    \t// This will throw INUSE if necessary\n    \treturn (Attr) attributes.setNamedItem(newAttr);\n\n    } // setAttributeNode(Attr):Attr\n\n    //\n    // DOM2: Namespace methods\n    //\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Retrieves an attribute value by local name and namespace URI.\n     *\n     * @param namespaceURI\n     *                      The namespace URI of the attribute to\n     *                      retrieve.\n     * @param localName     The local name of the attribute to retrieve.\n     * @return String       The Attr value as a string, or empty string\n     *                      if that attribute\n     *                      does not have a specified or default value.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public String getAttributeNS(String namespaceURI, String localName) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return \"\";\n        }\n\n        Attr attr = (Attr)(attributes.getNamedItemNS(namespaceURI, localName));\n        return (attr == null) ? \"\" : attr.getValue();\n\n    } // getAttributeNS(String,String):String\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     *  Adds a new attribute.\n     *  If the given namespaceURI is null or an empty string and the\n     *  qualifiedName has a prefix that is \"xml\", the new attribute is bound to\n     *  the predefined namespace \"http://www.w3.org/XML/1998/namespace\"\n     *  [Namespaces].  If an attribute with the same local name and namespace\n     *  URI is already present on the element, its prefix is changed to be the\n     *  prefix part of the qualifiedName, and its value is changed to be the\n     *  value parameter. This value is a simple string, it is not parsed as it\n     *  is being set. So any markup (such as syntax to be recognized as an\n     *  entity reference) is treated as literal text, and needs to be\n     *  appropriately escaped by the implementation when it is written out. In\n     *  order to assign an attribute value that contains entity references, the\n     *  user must create an Attr node plus any Text and EntityReference nodes,\n     *  build the appropriate subtree, and use setAttributeNodeNS or\n     *  setAttributeNode to assign it as the value of an attribute.\n     *\n     * @param namespaceURI      The namespace URI of the attribute to create\n     *                          or alter.\n     * @param qualifiedName     The qualified name of the attribute to create or\n     *                          alter.\n     * @param value             The value to set in string form.\n     * @throws                  INVALID_CHARACTER_ERR: Raised if the specified\n     *                          name contains an invalid character.\n     *\n     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this\n     *                          node is readonly.\n     *\n     * @throws                  NAMESPACE_ERR: Raised if the qualifiedName\n     *                          has a prefix that is \"xml\" and the namespaceURI\n     *                          is neither null nor an empty string nor\n     *                          \"http://www.w3.org/XML/1998/namespace\", or if\n     *                          the qualifiedName has a prefix that is \"xmlns\"\n     *                          but the namespaceURI is neither null nor an\n     *                          empty string, or if if the qualifiedName has a\n     *                          prefix different from \"xml\" and \"xmlns\" and the\n     *                          namespaceURI is null or an empty string.\n     * @since WD-DOM-Level-2-19990923\n     */\n     public void setAttributeNS(String namespaceURI,String qualifiedName,\n\t\t                          String value) {\n\t\tif (ownerDocument.errorChecking && isReadOnly()) {\n\t\t\tString msg =\n\t\t\t\tDOMMessageFormatter.formatMessage(\n\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN,\n\t\t\t\t\t\"NO_MODIFICATION_ALLOWED_ERR\",\n\t\t\t\t\tnull);\n\t\t\tthrow new DOMException(\n\t\t\t\tDOMException.NO_MODIFICATION_ALLOWED_ERR,\n\t\t\t\tmsg);\n\t\t}\n\t\tif (needsSyncData()) {\n\t\t\tsynchronizeData();\n\t\t}\n\t\tint index = qualifiedName.indexOf(':');\n\t\tString prefix, localName;\n\t\tif (index < 0) {\n\t\t\tprefix = null;\n\t\t\tlocalName = qualifiedName;\n\t\t}\n\t\telse {\n\t\t\tprefix = qualifiedName.substring(0, index);\n\t\t\tlocalName = qualifiedName.substring(index + 1);\n\t\t}\n\t\tAttr newAttr = getAttributeNodeNS(namespaceURI, localName);\n\t\tif (newAttr == null) {\n            // REVISIT: this is not efficient, we are creating twice the same\n            //          strings for prefix and localName.\n\t\t\tnewAttr = getOwnerDocument().createAttributeNS(\n\t\t\t\t\tnamespaceURI,\n\t\t\t\t\tqualifiedName);\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = new AttributeMap(this, null);\n\t\t\t}\n\t\t\tnewAttr.setNodeValue(value);\n\t\t\tattributes.setNamedItemNS(newAttr);\n\t\t}\n\t\telse {\n            if (newAttr instanceof org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrNSImpl){\n                // change prefix and value\n                ((AttrNSImpl)newAttr).name= (prefix!=null)?(prefix+\":\"+localName):localName;\n            }\n            else {\n                // This case may happen if user calls:\n                //      elem.setAttribute(\"name\", \"value\");\n                //      elem.setAttributeNS(null, \"name\", \"value\");\n                // This case is not defined by the DOM spec, we choose\n                // to create a new attribute in this case and remove an old one from the tree\n                // note this might cause events to be propagated or user data to be lost \n                newAttr = ((CoreDocumentImpl)getOwnerDocument()).createAttributeNS(namespaceURI, qualifiedName, localName);\n                attributes.setNamedItemNS(newAttr);\n            }\n\n\t\t\tnewAttr.setNodeValue(value);\n\t\t}\n\n    } // setAttributeNS(String,String,String)\n\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Removes an attribute by local name and namespace URI. If the removed\n     * attribute has a default value it is immediately replaced.\n     * The replacing attribute has the same namespace URI and local name,\n     * as well as the original prefix.<p>\n     *\n     * @param namespaceURI  The namespace URI of the attribute to remove.\n     *\n     * @param localName     The local name of the attribute to remove.\n     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this\n     *                          node is readonly.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public void removeAttributeNS(String namespaceURI, String localName) {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return;\n        }\n\n        attributes.safeRemoveNamedItemNS(namespaceURI, localName);\n\n    } // removeAttributeNS(String,String)\n\n    /**\n     * Retrieves an Attr node by local name and namespace URI.\n     *\n     * @param namespaceURI  The namespace URI of the attribute to\n     *                      retrieve.\n     * @param localName     The local name of the attribute to retrieve.\n     * @return Attr         The Attr node with the specified attribute\n     *                      local name and namespace\n     *                      URI or null if there is no such attribute.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public Attr getAttributeNodeNS(String namespaceURI, String localName){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return null;\n        }\n        return (Attr)attributes.getNamedItemNS(namespaceURI, localName);\n\n    } // getAttributeNodeNS(String,String):Attr\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Adds a new attribute. If an attribute with that local name and\n     * namespace URI is already present in the element, it is replaced\n     * by the new one.\n     *\n     * @param newAttr   The Attr node to add to the attribute list. When\n     *                  the Node has no namespaceURI, this method behaves\n     *                  like setAttributeNode.\n     * @return Attr     If the newAttr attribute replaces an existing attribute\n     *                  with the same local name and namespace URI, the *\n     *                  previously existing Attr node is returned, otherwise\n     *                  null is returned.\n     * @throws          WRONG_DOCUMENT_ERR: Raised if newAttr\n     *                  was created from a different document than the one that\n     *                  created the element.\n     *\n     * @throws          NO_MODIFICATION_ALLOWED_ERR: Raised if\n     *                  this node is readonly.\n     *\n     * @throws          INUSE_ATTRIBUTE_ERR: Raised if newAttr is\n     *                  already an attribute of another Element object. The\n     *                  DOM user must explicitly clone Attr nodes to re-use\n     *                  them in other elements.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public Attr setAttributeNodeNS(Attr newAttr)\n        throws DOMException\n        {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n    \t\t    throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n            if (newAttr.getOwnerDocument() != ownerDocument) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"WRONG_DOCUMENT_ERR\", null);\n                throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);\n            }\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n    \t// This will throw INUSE if necessary\n    \treturn (Attr) attributes.setNamedItemNS(newAttr);\n\n    } // setAttributeNodeNS(Attr):Attr\n\n    /**\n      * NON-DOM: sets attribute node for this element\n      */\n    protected int setXercesAttributeNode (Attr attr){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n        return attributes.addItem(attr);\n\n    }\n\n    /**\n      * NON-DOM: get inded of an attribute\n      */\n    protected int getXercesAttribute(String namespaceURI, String localName){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return -1;\n        }\n        return attributes.getNamedItemIndex(namespaceURI, localName);\n\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttributes() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        return (attributes != null && attributes.getLength() != 0);\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttribute(String name) {\n        return getAttributeNode(name) != null;\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttributeNS(String namespaceURI, String localName) {\n        return getAttributeNodeNS(namespaceURI, localName) != null;\n    }\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Returns a NodeList of all the Elements with a given local name and\n     * namespace URI in the order in which they would be encountered in a\n     * preorder traversal of the Document tree, starting from this node.\n     *\n     * @param namespaceURI The namespace URI of the elements to match\n     *                     on. The special value \"*\" matches all\n     *                     namespaces. When it is null or an empty\n     *                     string, this method behaves like\n     *                     getElementsByTagName.\n     * @param localName    The local name of the elements to match on.\n     *                     The special value \"*\" matches all local names.\n     * @return NodeList    A new NodeList object containing all the matched\n     *                     Elements.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public NodeList getElementsByTagNameNS(String namespaceURI,\n                                           String localName) {\n    \treturn new DeepNodeListImpl(this, namespaceURI, localName);\n    }\n\n    /**\n     * DOM Level 3 WD- Experimental.\n     * Override inherited behavior from NodeImpl and ParentNode to check on\n     * attributes\n     */\n    public boolean isEqualNode(Node arg) {\n        if (!super.isEqualNode(arg)) {\n            return false;\n        }\n        boolean hasAttrs = hasAttributes();\n        if (hasAttrs != ((Element) arg).hasAttributes()) {\n            return false;\n        }\n        if (hasAttrs) {\n            NamedNodeMap map1 = getAttributes();\n            NamedNodeMap map2 = ((Element) arg).getAttributes();\n            int len = map1.getLength();\n            if (len != map2.getLength()) {\n                return false;\n            }\n            for (int i = 0; i < len; i++) {\n                Node n1 = map1.item(i);\n                if (n1.getLocalName() == null) { // DOM Level 1 Node\n                    Node n2 = map2.getNamedItem(n1.getNodeName());\n                    if (n2 == null || !((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl) n1).isEqualNode(n2)) {\n                        return false;\n                    }\n                }\n                else {\n                    Node n2 = map2.getNamedItemNS(n1.getNamespaceURI(),\n                                                  n1.getLocalName());\n                    if (n2 == null || !((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl) n1).isEqualNode(n2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttributeNode(Attr at, boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n        ((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttribute(String name, boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        Attr at = getAttributeNode(name);\n\t\t\n\t\tif( at == null){\n       \t\tString msg = DOMMessageFormatter.formatMessage(\n\t\t\t\t\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN, \n\t\t\t\t\t\t\t\t\t\"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n\t\t}\n        \n\t\tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n\n        ((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttributeNS(String namespaceURI, String localName,\n                                    boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        Attr at = getAttributeNodeNS(namespaceURI, localName);\n\t\t\n\t\tif( at == null){\n       \t\tString msg = DOMMessageFormatter.formatMessage(\n\t\t\t\t\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN, \n\t\t\t\t\t\t\t\t\t\"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n\t\t}\n       \n\t\tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n        ((AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n   }\n\n    /**\n     * @see TypeInfo#getTypeName()\n     */\n     public String getTypeName() {\n        return null;\n     }\n\n    /**\n     * @see TypeInfo#getTypeNamespace()\n     */\n    public String getTypeNamespace() {\n        return null;\n    }\n\n    /**\n     * Introduced in DOM Level 3. <p>\n     * Checks if a type is derived from another by restriction. See:\n     * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom\n     * \n     * @param typeNamespaceArg \n     *        The namspace of the ancestor type declaration\n     * @param typeNameArg\n     *        The name of the ancestor type declaration\n     * @param derivationMethod\n     *        The derivation method\n     * \n     * @return boolean True if the type is derived by restriciton for the\n     *         reference type\n     */\n    public boolean isDerivedFrom(String typeNamespaceArg, \n                                 String typeNameArg, \n                                 int derivationMethod) {\n                                 \t\n        return false;\n    }\n\n\t/**\n\t * Method getSchemaTypeInfo.\n\t * @return TypeInfo\n\t */\n    public TypeInfo getSchemaTypeInfo(){\n        if(needsSyncData()) {\n            synchronizeData();\n        }\n        return this;\n    }\n\n    //\n    // Public methods\n    //\n\n    /**\n     * NON-DOM: Subclassed to flip the attributes' readonly switch as well.\n     * @see NodeImpl#setReadOnly\n     */\n    public void setReadOnly(boolean readOnly, boolean deep) {\n    \tsuper.setReadOnly(readOnly,deep);\n        if (attributes != null) {\n            attributes.setReadOnly(readOnly,true);\n        }\n    }\n\n\n\n    //\n    // Protected methods\n    //\n\n    /** Synchronizes the data (name and value) for fast nodes. */\n    protected void synchronizeData() {\n\n        // no need to sync in the future\n        needsSyncData(false);\n\n        // we don't want to generate any event for this so turn them off\n        boolean orig = ownerDocument.getMutationEvents();\n        ownerDocument.setMutationEvents(false);\n\n        // attributes\n        setupDefaultAttributes();\n\n        // set mutation events flag back to its original value\n        ownerDocument.setMutationEvents(orig);\n\n    } // synchronizeData()\n\n    // support for DOM Level 3 renameNode method\n    // @param el The element from which to take the attributes\n    void moveSpecifiedAttributes(ElementImpl el) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (el.hasAttributes()) {\n            if (attributes == null) {\n                attributes = new AttributeMap(this, null);\n            }\n            attributes.moveSpecifiedAttributes(el.attributes);\n        }\n    }\n\n    /** Setup the default attributes. */\n    protected void setupDefaultAttributes() {\n        NamedNodeMapImpl defaults = getDefaultAttributes();\n        if (defaults != null) {\n            attributes = new AttributeMap(this, defaults);\n        }\n    }\n\n    /** Reconcile default attributes. */\n    protected void reconcileDefaultAttributes() {\n        if (attributes != null) {\n            NamedNodeMapImpl defaults = getDefaultAttributes();\n            attributes.reconcileDefaults(defaults);\n        }\n    }\n\n    /** Get the default attributes. */\n    protected NamedNodeMapImpl getDefaultAttributes() {\n\n    \tDocumentTypeImpl doctype =\n            (DocumentTypeImpl) ownerDocument.getDoctype();\n    \tif (doctype == null) {\n            return null;\n        }\n        ElementDefinitionImpl eldef =\n            (ElementDefinitionImpl)doctype.getElements()\n                                               .getNamedItem(getNodeName());\n        if (eldef == null) {\n            return null;\n        }\n        return (NamedNodeMapImpl) eldef.getAttributes();\n\n    } // getDefaultAttributes()\n    \n    //\n    // ElementTraversal methods\n    //\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-childElementCount\">\n     * Element Traversal Specification</a>\n     */\n    public final int getChildElementCount() {\n        int count = 0;\n        Element child = getFirstElementChild();\n        while (child != null) {\n            ++count;\n            child = ((ElementImpl) child).getNextElementSibling();\n        }\n        return count;\n    } // getChildElementCount():int\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-firstElementChild\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getFirstElementChild() {\n        Node n = getFirstChild();\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getFirstElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = n.getNextSibling();\n        }\n        return null;\n    } // getFirstElementChild():Element\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-lastElementChild\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getLastElementChild() {\n        Node n = getLastChild();\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getLastElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = n.getPreviousSibling();\n        }\n        return null;\n    } // getLastElementChild():Element\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-nextElementSibling\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getNextElementSibling() {\n        Node n = getNextLogicalSibling(this);\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getFirstElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = getNextLogicalSibling(n);\n        }\n        return null;\n    } // getNextElementSibling():Element\n    \n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-previousElementSibling\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getPreviousElementSibling() {\n        Node n = getPreviousLogicalSibling(this);\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getLastElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = getPreviousLogicalSibling(n);\n        }\n        return null;\n    } // getPreviousElementSibling():Element\n    \n    // Returns the first element node found from a \n    // non-recursive in order traversal of the given node.\n    private Element getFirstElementChild(Node n) {\n        final Node top = n;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                return (Element) n;\n            }\n            Node next = n.getFirstChild();\n            while (next == null) {         \n                if (top == n) {\n                    break;\n                }\n                next = n.getNextSibling();\n                if (next == null) {\n                    n = n.getParentNode();\n                    if (n == null || top == n) {\n                        return null;\n                    }\n                }\n            }\n            n = next;\n        }\n        return null;\n    } // getFirstElementChild(Node):Element\n    \n    // Returns the first element node found from a \n    // non-recursive reverse order traversal of the given node.\n    private Element getLastElementChild(Node n) {\n        final Node top = n;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                return (Element) n;\n            }\n            Node next = n.getLastChild();\n            while (next == null) {         \n                if (top == n) {\n                    break;\n                }\n                next = n.getPreviousSibling();\n                if (next == null) {\n                    n = n.getParentNode();\n                    if (n == null || top == n) {\n                        return null;\n                    }\n                }\n            }\n            n = next;\n        }\n        return null;\n    } // getLastElementChild(Node):Element\n    \n    // Returns the next logical sibling with respect to the given node.\n    private Node getNextLogicalSibling(Node n) {\n        Node next = n.getNextSibling();\n        // If \"n\" has no following sibling and its parent is an entity reference node we \n        // need to continue the search through the following siblings of the entity \n        // reference as these are logically siblings of the given node.\n        if (next == null) {\n            Node parent = n.getParentNode();\n            while (parent != null && parent.getNodeType() == Node.ENTITY_REFERENCE_NODE) {\n                next = parent.getNextSibling();\n                if (next != null) {\n                    break;\n                }\n                parent = parent.getParentNode();\n            }\n        }\n        return next;\n    } // getNextLogicalSibling(Node):Node\n    \n    // Returns the previous logical sibling with respect to the given node.\n    private Node getPreviousLogicalSibling(Node n) {\n        Node prev = n.getPreviousSibling();\n        // If \"n\" has no previous sibling and its parent is an entity reference node we \n        // need to continue the search through the previous siblings of the entity \n        // reference as these are logically siblings of the given node.\n        if (prev == null) {\n            Node parent = n.getParentNode();\n            while (parent != null && parent.getNodeType() == Node.ENTITY_REFERENCE_NODE) {\n                prev = parent.getPreviousSibling();\n                if (prev != null) {\n                    break;\n                }\n                parent = parent.getParentNode();\n            }\n        }\n        return prev;\n    } // getPreviousLogicalSibling(Node):Node\n\n} // class ElementImpl\n\n'''\nthe error is triggered in the following specific lines in the previous code:\nimport org.w3c.dom.ElementTraversal;\n    implements Element, ElementTraversal, TypeInfo {\nwith the following error message:\n[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[30,19] cannot find symbol  symbol:   class ElementTraversal\n  location: package org.w3c.dom\n[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[67,25] cannot find symbol  symbol: class ElementTraversal\nThe error is caused by a change in the API of the dependency: xml-apis 1.4.01->2.0.0. The new library version includes the following changes:\nFormat: element | nature | kind\norg.w3c.dom.ElementTraversal | DELETION | TYPE_REMOVED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the entire fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "import org.w3c.dom.ElementTraversal;\n    implements Element, ElementTraversal, TypeInfo {",
    "error_message": "[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[30,19] cannot find symbol  symbol:   class ElementTraversal\n  location: package org.w3c.dom\n[ERROR] /smooks/core/src/main/java/org/smooks/engine/delivery/sax/ng/org/apache/xerces/dom/ElementImpl.java:[67,25] cannot find symbol  symbol: class ElementTraversal",
    "api_diff": "Format: element | nature | kind\norg.w3c.dom.ElementTraversal | DELETION | TYPE_REMOVED",
    "original_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom;\n\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.*;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrNSImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.ChildNode;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.ParentNode;\nimport org.smooks.engine.delivery.sax.ng.org.apache.xerces.util.URI;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.ElementTraversal;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Text;\nimport org.w3c.dom.TypeInfo;\n\n/**\n * Elements represent most of the \"markup\" and structure of the\n * document.  They contain both the data for the element itself\n * (element name and attributes), and any contained nodes, including\n * document text (as children).\n * <P>\n * Elements may have Attributes associated with them; the API for this is\n * defined in Node, but the function is implemented here. In general, XML\n * applications should retrive Attributes as Nodes, since they may contain\n * entity references and hence be a fairly complex sub-tree. HTML users will\n * be dealing with simple string values, and convenience methods are provided\n * to work in terms of Strings.\n * <P>\n * ElementImpl does not support Namespaces. ElementNSImpl, which inherits from\n * it, does.\n * \n * @xerces.internal\n * \n * @see ElementNSImpl\n *\n * @author Arnaud  Le Hors, IBM\n * @author Joe Kesselman, IBM\n * @author Andy Clark, IBM\n * @author Ralf Pfeiffer, IBM\n * @author Michael Glavassevich, IBM\n * @version $Id$\n * @since  PR-DOM-Level-1-19980818.\n */\npublic class ElementImpl\n    extends ParentNode\n    implements Element, ElementTraversal, TypeInfo {\n\n    //\n    // Constants\n    //\n\n    /** Serialization version. */\n    static final long serialVersionUID = 3717253516652722278L;\n    //\n    // Data\n    //\n\n    /** Element name. */\n    protected String name;\n\n    /** Attributes. */\n    protected AttributeMap attributes;\n\n    //\n    // Constructors\n    //\n\n    /** Factory constructor. */\n    public ElementImpl(CoreDocumentImpl ownerDoc, String name) {\n    \tsuper(ownerDoc);\n        this.name = name;\n        needsSyncData(true);    // synchronizeData will initialize attributes\n    }\n\n    // for ElementNSImpl\n    protected ElementImpl() {}\n\n    // Support for DOM Level 3 renameNode method.\n    // Note: This only deals with part of the pb. CoreDocumentImpl\n    // does all the work.\n    void rename(String name) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            int colon1 = name.indexOf(':');\n            if(colon1 != -1){\n                String msg =\n                    DOMMessageFormatter.formatMessage(\n                            DOMMessageFormatter.DOM_DOMAIN,\n                            \"NAMESPACE_ERR\",\n                            null);\n                throw new DOMException(DOMException.NAMESPACE_ERR, msg);\n            }\n            if (!CoreDocumentImpl.isXMLName(name, ownerDocument.isXML11Version())) {\n                String msg = DOMMessageFormatter.formatMessage(\n                        DOMMessageFormatter.DOM_DOMAIN,\n                        \"INVALID_CHARACTER_ERR\", null);\n                throw new DOMException(DOMException.INVALID_CHARACTER_ERR,\n                        msg);\n            }\n        }\n        this.name = name;\n        reconcileDefaultAttributes();\n    }\n\n    //\n    // Node methods\n    //\n\n\n    /**\n     * A short integer indicating what type of node this is. The named\n     * constants for this value are defined in the org.w3c.dom.Node interface.\n     */\n    public short getNodeType() {\n        return Node.ELEMENT_NODE;\n    }\n\n    /**\n     * Returns the element name\n     */\n    public String getNodeName() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        return name;\n    }\n\n    /**\n     * Retrieve all the Attributes as a set. Note that this API is inherited\n     * from Node rather than specified on Element; in fact only Elements will\n     * ever have Attributes, but they want to allow folks to \"blindly\" operate\n     * on the tree as a set of Nodes.\n     */\n    public NamedNodeMap getAttributes() {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n        return attributes;\n\n    } // getAttributes():NamedNodeMap\n\n    /**\n     * Return a duplicate copy of this Element. Note that its children\n     * will not be copied unless the \"deep\" flag is true, but Attributes\n     * are <i>always</i> replicated.\n     *\n     * @see Node#cloneNode(boolean)\n     */\n    public Node cloneNode(boolean deep) {\n\n    \tElementImpl newnode = (ElementImpl) super.cloneNode(deep);\n    \t// Replicate NamedNodeMap rather than sharing it.\n        if (attributes != null) {\n            newnode.attributes = (AttributeMap) attributes.cloneMap(newnode);\n        }\n    \treturn newnode;\n\n    } // cloneNode(boolean):Node\n\n    /**\n     * DOM Level 3 WD - Experimental.\n     * Retrieve baseURI\n     */\n    public String getBaseURI() {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        // Absolute base URI is computed according to \n        // XML Base (http://www.w3.org/TR/xmlbase/#granularity)\n        // 1. The base URI specified by an xml:base attribute on the element, \n        // if one exists\n        if (attributes != null) {\n            final Attr attrNode = getXMLBaseAttribute();\n            if (attrNode != null) {\n                final String uri =  attrNode.getNodeValue();\n                if (uri.length() != 0) {// attribute value is always empty string\n                    try {\n                        URI _uri = new URI(uri, true);\n                        // If the URI is already absolute return it; otherwise it's relative and we need to resolve it.\n                        if (_uri.isAbsoluteURI()) {\n                            return _uri.toString();\n                        }\n                        \n                        // Make any parentURI into a URI object to use with the URI(URI, String) constructor\n                        String parentBaseURI = (this.ownerNode != null) ? this.ownerNode.getBaseURI() : null;\n                        if (parentBaseURI != null) {\n                            try {\n                                URI _parentBaseURI = new URI(parentBaseURI);\n                                _uri.absolutize(_parentBaseURI);\n                                return _uri.toString();\n                            }\n                            catch (URI.MalformedURIException ex) {\n                                // This should never happen: parent should have checked the URI and returned null if invalid.\n                                return null;\n                            }\n                        }\n                        // REVISIT: what should happen in this case?\n                        return null; \n                    }\n                    catch (URI.MalformedURIException ex) {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        // 2.the base URI of the element's parent element within the \n        // document or external entity, if one exists \n        // 3. the base URI of the document entity or external entity \n        // containing the element\n\n        // ownerNode serves as a parent or as document\n        return (this.ownerNode != null) ? this.ownerNode.getBaseURI() : null;\n    } //getBaseURI\n    \n    /**\n     * NON-DOM\n     * Returns the xml:base attribute.\n     */\n    protected Attr getXMLBaseAttribute() {\n        return (Attr) attributes.getNamedItem(\"xml:base\");\n    } // getXMLBaseAttribute():Attr\n\n    /**\n     * NON-DOM\n     * set the ownerDocument of this node, its children, and its attributes\n     */\n    protected void setOwnerDocument(CoreDocumentImpl doc) {\n        super.setOwnerDocument(doc);\n        if (attributes != null) {\n            attributes.setOwnerDocument(doc);\n        }\n    }\n\n    //\n    // Element methods\n    //\n\n    /**\n     * Look up a single Attribute by name. Returns the Attribute's\n     * string value, or an empty string (NOT null!) to indicate that the\n     * name did not map to a currently defined attribute.\n     * <p>\n     * Note: Attributes may contain complex node trees. This method\n     * returns the \"flattened\" string obtained from Attribute.getValue().\n     * If you need the structure information, see getAttributeNode().\n     */\n    public String getAttribute(String name) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return \"\";\n        }\n        Attr attr = (Attr)(attributes.getNamedItem(name));\n        return (attr == null) ? \"\" : attr.getValue();\n\n    } // getAttribute(String):String\n\n\n    /**\n     * Look up a single Attribute by name. Returns the Attribute Node,\n     * so its complete child tree is available. This could be important in\n     * XML, where the string rendering may not be sufficient information.\n     * <p>\n     * If no matching attribute is available, returns null.\n     */\n    public Attr getAttributeNode(String name) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return null;\n        }\n        return (Attr)attributes.getNamedItem(name);\n\n    } // getAttributeNode(String):Attr\n\n\n    /**\n     * Returns a NodeList of all descendent nodes (children,\n     * grandchildren, and so on) which are Elements and which have the\n     * specified tag name.\n     * <p>\n     * Note: NodeList is a \"live\" view of the DOM. Its contents will\n     * change as the DOM changes, and alterations made to the NodeList\n     * will be reflected in the DOM.\n     *\n     * @param tagname The type of element to gather. To obtain a list of\n     * all elements no matter what their names, use the wild-card tag\n     * name \"*\".\n     *\n     * @see DeepNodeListImpl\n     */\n    public NodeList getElementsByTagName(String tagname) {\n    \treturn new DeepNodeListImpl(this,tagname);\n    }\n\n    /**\n     * Returns the name of the Element. Note that Element.nodeName() is\n     * defined to also return the tag name.\n     * <p>\n     * This is case-preserving in XML. HTML should uppercasify it on the\n     * way in.\n     */\n    public String getTagName() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n    \treturn name;\n    }\n\n    /**\n     * In \"normal form\" (as read from a source file), there will never be two\n     * Text children in succession. But DOM users may create successive Text\n     * nodes in the course of manipulating the document. Normalize walks the\n     * sub-tree and merges adjacent Texts, as if the DOM had been written out\n     * and read back in again. This simplifies implementation of higher-level\n     * functions that may want to assume that the document is in standard form.\n     * <p>\n     * To normalize a Document, normalize its top-level Element child.\n     * <p>\n     * As of PR-DOM-Level-1-19980818, CDATA -- despite being a subclass of\n     * Text -- is considered \"markup\" and will _not_ be merged either with\n     * normal Text or with other CDATASections.\n     */\n    public void normalize() {\n        // No need to normalize if already normalized.\n        if (isNormalized()) {\n            return;\n        }\n        if (needsSyncChildren()) {\n            synchronizeChildren();\n        }\n        ChildNode kid, next;\n        for (kid = firstChild; kid != null; kid = next) {\n            next = kid.nextSibling;\n\n            // If kid is a text node, we need to check for one of two\n            // conditions:\n            //   1) There is an adjacent text node\n            //   2) There is no adjacent text node, but kid is\n            //      an empty text node.\n            if ( kid.getNodeType() == Node.TEXT_NODE )\n            {\n                // If an adjacent text node, merge it with kid\n                if ( next!=null && next.getNodeType() == Node.TEXT_NODE )\n                {\n                    ((Text)kid).appendData(next.getNodeValue());\n                    removeChild( next );\n                    next = kid; // Don't advance; there might be another.\n                }\n                else\n                {\n                    // If kid is empty, remove it\n                    if ( kid.getNodeValue() == null || kid.getNodeValue().length() == 0 ) {\n                        removeChild( kid );\n                    }\n                }\n            }\n\n            // Otherwise it might be an Element, which is handled recursively\n            else if (kid.getNodeType() == Node.ELEMENT_NODE) {\n                kid.normalize();\n            }\n        }\n\n        // We must also normalize all of the attributes\n        if ( attributes!=null )\n        {\n            for( int i=0; i<attributes.getLength(); ++i )\n            {\n                Node attr = attributes.item(i);\n                attr.normalize();\n            }\n        }\n\n    \t// changed() will have occurred when the removeChild() was done,\n    \t// so does not have to be reissued.\n\n        isNormalized(true);\n    } // normalize()\n\n    /**\n     * Remove the named attribute from this Element. If the removed\n     * Attribute has a default value, it is immediately replaced thereby.\n     * <P>\n     * The default logic is actually implemented in NamedNodeMapImpl.\n     * PR-DOM-Level-1-19980818 doesn't fully address the DTD, so some\n     * of this behavior is likely to change in future versions. ?????\n     * <P>\n     * Note that this call \"succeeds\" even if no attribute by this name\n     * existed -- unlike removeAttributeNode, which will throw a not-found\n     * exception in that case.\n     *\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n    public void removeAttribute(String name) {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return;\n        }\n\n        attributes.safeRemoveNamedItem(name);\n\n    } // removeAttribute(String)\n\n\n    /**\n     * Remove the specified attribute/value pair. If the removed\n     * Attribute has a default value, it is immediately replaced.\n     * <p>\n     * NOTE: Specifically removes THIS NODE -- not the node with this\n     * name, nor the node with these contents. If the specific Attribute\n     * object passed in is not stored in this Element, we throw a\n     * DOMException.  If you really want to remove an attribute by name,\n     * use removeAttribute().\n     *\n     * @return the Attribute object that was removed.\n     * @throws DOMException(NOT_FOUND_ERR) if oldattr is not an attribute of\n     * this Element.\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n    public Attr removeAttributeNode(Attr oldAttr)\n        throws DOMException {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n        }\n        return (Attr) attributes.removeItem(oldAttr, true);\n\n    } // removeAttributeNode(Attr):Attr\n\n\n    /**\n     * Add a new name/value pair, or replace the value of the existing\n     * attribute having that name.\n     *\n     * Note: this method supports only the simplest kind of Attribute,\n     * one whose value is a string contained in a single Text node.\n     * If you want to assert a more complex value (which XML permits,\n     * though HTML doesn't), see setAttributeNode().\n     *\n     * The attribute is created with specified=true, meaning it's an\n     * explicit value rather than inherited from the DTD as a default.\n     * Again, setAttributeNode can be used to achieve other results.\n     *\n     * @throws DOMException(INVALID_NAME_ERR) if the name is not acceptable.\n     * (Attribute factory will do that test for us.)\n     *\n     * @throws DOMException(NO_MODIFICATION_ALLOWED_ERR) if the node is\n     * readonly.\n     */\n\tpublic void setAttribute(String name, String value) {\n\n\t\tif (ownerDocument.errorChecking && isReadOnly()) {\n\t\t\tString msg =\n\t\t\t\tDOMMessageFormatter.formatMessage(\n\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN,\n\t\t\t\t\t\"NO_MODIFICATION_ALLOWED_ERR\",\n\t\t\t\t\tnull);\n\t\t\tthrow new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n\t\t}\n\n\t\tif (needsSyncData()) {\n\t\t\tsynchronizeData();\n\t\t}\n\n\t\tAttr newAttr = getAttributeNode(name);\n\t\tif (newAttr == null) {\n\t\t\tnewAttr = getOwnerDocument().createAttribute(name);\n\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = new AttributeMap(this, null);\n\t\t\t}\n\n\t\t\tnewAttr.setNodeValue(value);\n\t\t\tattributes.setNamedItem(newAttr);\n\t\t}\n\t\telse {\n\t\t\tnewAttr.setNodeValue(value);\n\t\t}\n\n\t} // setAttribute(String,String)\n\n    /**\n     * Add a new attribute/value pair, or replace the value of the\n     * existing attribute with that name.\n     * <P>\n     * This method allows you to add an Attribute that has already been\n     * constructed, and hence avoids the limitations of the simple\n     * setAttribute() call. It can handle attribute values that have\n     * arbitrarily complex tree structure -- in particular, those which\n     * had entity references mixed into their text.\n     *\n     * @throws DOMException(INUSE_ATTRIBUTE_ERR) if the Attribute object\n     * has already been assigned to another Element.\n     */\n    public Attr setAttributeNode(Attr newAttr)\n        throws DOMException\n        {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n    \tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (newAttr.getOwnerDocument() != ownerDocument) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"WRONG_DOCUMENT_ERR\", null);\n    \t\t    throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);\n            }\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n    \t// This will throw INUSE if necessary\n    \treturn (Attr) attributes.setNamedItem(newAttr);\n\n    } // setAttributeNode(Attr):Attr\n\n    //\n    // DOM2: Namespace methods\n    //\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Retrieves an attribute value by local name and namespace URI.\n     *\n     * @param namespaceURI\n     *                      The namespace URI of the attribute to\n     *                      retrieve.\n     * @param localName     The local name of the attribute to retrieve.\n     * @return String       The Attr value as a string, or empty string\n     *                      if that attribute\n     *                      does not have a specified or default value.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public String getAttributeNS(String namespaceURI, String localName) {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return \"\";\n        }\n\n        Attr attr = (Attr)(attributes.getNamedItemNS(namespaceURI, localName));\n        return (attr == null) ? \"\" : attr.getValue();\n\n    } // getAttributeNS(String,String):String\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     *  Adds a new attribute.\n     *  If the given namespaceURI is null or an empty string and the\n     *  qualifiedName has a prefix that is \"xml\", the new attribute is bound to\n     *  the predefined namespace \"http://www.w3.org/XML/1998/namespace\"\n     *  [Namespaces].  If an attribute with the same local name and namespace\n     *  URI is already present on the element, its prefix is changed to be the\n     *  prefix part of the qualifiedName, and its value is changed to be the\n     *  value parameter. This value is a simple string, it is not parsed as it\n     *  is being set. So any markup (such as syntax to be recognized as an\n     *  entity reference) is treated as literal text, and needs to be\n     *  appropriately escaped by the implementation when it is written out. In\n     *  order to assign an attribute value that contains entity references, the\n     *  user must create an Attr node plus any Text and EntityReference nodes,\n     *  build the appropriate subtree, and use setAttributeNodeNS or\n     *  setAttributeNode to assign it as the value of an attribute.\n     *\n     * @param namespaceURI      The namespace URI of the attribute to create\n     *                          or alter.\n     * @param qualifiedName     The qualified name of the attribute to create or\n     *                          alter.\n     * @param value             The value to set in string form.\n     * @throws                  INVALID_CHARACTER_ERR: Raised if the specified\n     *                          name contains an invalid character.\n     *\n     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this\n     *                          node is readonly.\n     *\n     * @throws                  NAMESPACE_ERR: Raised if the qualifiedName\n     *                          has a prefix that is \"xml\" and the namespaceURI\n     *                          is neither null nor an empty string nor\n     *                          \"http://www.w3.org/XML/1998/namespace\", or if\n     *                          the qualifiedName has a prefix that is \"xmlns\"\n     *                          but the namespaceURI is neither null nor an\n     *                          empty string, or if if the qualifiedName has a\n     *                          prefix different from \"xml\" and \"xmlns\" and the\n     *                          namespaceURI is null or an empty string.\n     * @since WD-DOM-Level-2-19990923\n     */\n     public void setAttributeNS(String namespaceURI,String qualifiedName,\n\t\t                          String value) {\n\t\tif (ownerDocument.errorChecking && isReadOnly()) {\n\t\t\tString msg =\n\t\t\t\tDOMMessageFormatter.formatMessage(\n\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN,\n\t\t\t\t\t\"NO_MODIFICATION_ALLOWED_ERR\",\n\t\t\t\t\tnull);\n\t\t\tthrow new DOMException(\n\t\t\t\tDOMException.NO_MODIFICATION_ALLOWED_ERR,\n\t\t\t\tmsg);\n\t\t}\n\t\tif (needsSyncData()) {\n\t\t\tsynchronizeData();\n\t\t}\n\t\tint index = qualifiedName.indexOf(':');\n\t\tString prefix, localName;\n\t\tif (index < 0) {\n\t\t\tprefix = null;\n\t\t\tlocalName = qualifiedName;\n\t\t}\n\t\telse {\n\t\t\tprefix = qualifiedName.substring(0, index);\n\t\t\tlocalName = qualifiedName.substring(index + 1);\n\t\t}\n\t\tAttr newAttr = getAttributeNodeNS(namespaceURI, localName);\n\t\tif (newAttr == null) {\n            // REVISIT: this is not efficient, we are creating twice the same\n            //          strings for prefix and localName.\n\t\t\tnewAttr = getOwnerDocument().createAttributeNS(\n\t\t\t\t\tnamespaceURI,\n\t\t\t\t\tqualifiedName);\n\t\t\tif (attributes == null) {\n\t\t\t\tattributes = new AttributeMap(this, null);\n\t\t\t}\n\t\t\tnewAttr.setNodeValue(value);\n\t\t\tattributes.setNamedItemNS(newAttr);\n\t\t}\n\t\telse {\n            if (newAttr instanceof org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrNSImpl){\n                // change prefix and value\n                ((AttrNSImpl)newAttr).name= (prefix!=null)?(prefix+\":\"+localName):localName;\n            }\n            else {\n                // This case may happen if user calls:\n                //      elem.setAttribute(\"name\", \"value\");\n                //      elem.setAttributeNS(null, \"name\", \"value\");\n                // This case is not defined by the DOM spec, we choose\n                // to create a new attribute in this case and remove an old one from the tree\n                // note this might cause events to be propagated or user data to be lost \n                newAttr = ((CoreDocumentImpl)getOwnerDocument()).createAttributeNS(namespaceURI, qualifiedName, localName);\n                attributes.setNamedItemNS(newAttr);\n            }\n\n\t\t\tnewAttr.setNodeValue(value);\n\t\t}\n\n    } // setAttributeNS(String,String,String)\n\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Removes an attribute by local name and namespace URI. If the removed\n     * attribute has a default value it is immediately replaced.\n     * The replacing attribute has the same namespace URI and local name,\n     * as well as the original prefix.<p>\n     *\n     * @param namespaceURI  The namespace URI of the attribute to remove.\n     *\n     * @param localName     The local name of the attribute to remove.\n     * @throws                  NO_MODIFICATION_ALLOWED_ERR: Raised if this\n     *                          node is readonly.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public void removeAttributeNS(String namespaceURI, String localName) {\n\n    \tif (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            return;\n        }\n\n        attributes.safeRemoveNamedItemNS(namespaceURI, localName);\n\n    } // removeAttributeNS(String,String)\n\n    /**\n     * Retrieves an Attr node by local name and namespace URI.\n     *\n     * @param namespaceURI  The namespace URI of the attribute to\n     *                      retrieve.\n     * @param localName     The local name of the attribute to retrieve.\n     * @return Attr         The Attr node with the specified attribute\n     *                      local name and namespace\n     *                      URI or null if there is no such attribute.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public Attr getAttributeNodeNS(String namespaceURI, String localName){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return null;\n        }\n        return (Attr)attributes.getNamedItemNS(namespaceURI, localName);\n\n    } // getAttributeNodeNS(String,String):Attr\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Adds a new attribute. If an attribute with that local name and\n     * namespace URI is already present in the element, it is replaced\n     * by the new one.\n     *\n     * @param newAttr   The Attr node to add to the attribute list. When\n     *                  the Node has no namespaceURI, this method behaves\n     *                  like setAttributeNode.\n     * @return Attr     If the newAttr attribute replaces an existing attribute\n     *                  with the same local name and namespace URI, the *\n     *                  previously existing Attr node is returned, otherwise\n     *                  null is returned.\n     * @throws          WRONG_DOCUMENT_ERR: Raised if newAttr\n     *                  was created from a different document than the one that\n     *                  created the element.\n     *\n     * @throws          NO_MODIFICATION_ALLOWED_ERR: Raised if\n     *                  this node is readonly.\n     *\n     * @throws          INUSE_ATTRIBUTE_ERR: Raised if newAttr is\n     *                  already an attribute of another Element object. The\n     *                  DOM user must explicitly clone Attr nodes to re-use\n     *                  them in other elements.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public Attr setAttributeNodeNS(Attr newAttr)\n        throws DOMException\n        {\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n    \t\t    throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n            if (newAttr.getOwnerDocument() != ownerDocument) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"WRONG_DOCUMENT_ERR\", null);\n                throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, msg);\n            }\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n    \t// This will throw INUSE if necessary\n    \treturn (Attr) attributes.setNamedItemNS(newAttr);\n\n    } // setAttributeNodeNS(Attr):Attr\n\n    /**\n      * NON-DOM: sets attribute node for this element\n      */\n    protected int setXercesAttributeNode (Attr attr){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n\n        if (attributes == null) {\n            attributes = new AttributeMap(this, null);\n        }\n        return attributes.addItem(attr);\n\n    }\n\n    /**\n      * NON-DOM: get inded of an attribute\n      */\n    protected int getXercesAttribute(String namespaceURI, String localName){\n\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (attributes == null) {\n            return -1;\n        }\n        return attributes.getNamedItemIndex(namespaceURI, localName);\n\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttributes() {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        return (attributes != null && attributes.getLength() != 0);\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttribute(String name) {\n        return getAttributeNode(name) != null;\n    }\n\n    /**\n     * Introduced in DOM Level 2.\n     */\n    public boolean hasAttributeNS(String namespaceURI, String localName) {\n        return getAttributeNodeNS(namespaceURI, localName) != null;\n    }\n\n    /**\n     * Introduced in DOM Level 2. <p>\n     *\n     * Returns a NodeList of all the Elements with a given local name and\n     * namespace URI in the order in which they would be encountered in a\n     * preorder traversal of the Document tree, starting from this node.\n     *\n     * @param namespaceURI The namespace URI of the elements to match\n     *                     on. The special value \"*\" matches all\n     *                     namespaces. When it is null or an empty\n     *                     string, this method behaves like\n     *                     getElementsByTagName.\n     * @param localName    The local name of the elements to match on.\n     *                     The special value \"*\" matches all local names.\n     * @return NodeList    A new NodeList object containing all the matched\n     *                     Elements.\n     * @since WD-DOM-Level-2-19990923\n     */\n    public NodeList getElementsByTagNameNS(String namespaceURI,\n                                           String localName) {\n    \treturn new DeepNodeListImpl(this, namespaceURI, localName);\n    }\n\n    /**\n     * DOM Level 3 WD- Experimental.\n     * Override inherited behavior from NodeImpl and ParentNode to check on\n     * attributes\n     */\n    public boolean isEqualNode(Node arg) {\n        if (!super.isEqualNode(arg)) {\n            return false;\n        }\n        boolean hasAttrs = hasAttributes();\n        if (hasAttrs != ((Element) arg).hasAttributes()) {\n            return false;\n        }\n        if (hasAttrs) {\n            NamedNodeMap map1 = getAttributes();\n            NamedNodeMap map2 = ((Element) arg).getAttributes();\n            int len = map1.getLength();\n            if (len != map2.getLength()) {\n                return false;\n            }\n            for (int i = 0; i < len; i++) {\n                Node n1 = map1.item(i);\n                if (n1.getLocalName() == null) { // DOM Level 1 Node\n                    Node n2 = map2.getNamedItem(n1.getNodeName());\n                    if (n2 == null || !((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl) n1).isEqualNode(n2)) {\n                        return false;\n                    }\n                }\n                else {\n                    Node n2 = map2.getNamedItemNS(n1.getNamespaceURI(),\n                                                  n1.getLocalName());\n                    if (n2 == null || !((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.NodeImpl) n1).isEqualNode(n2)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttributeNode(Attr at, boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n        ((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttribute(String name, boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        Attr at = getAttributeNode(name);\n\t\t\n\t\tif( at == null){\n       \t\tString msg = DOMMessageFormatter.formatMessage(\n\t\t\t\t\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN, \n\t\t\t\t\t\t\t\t\t\"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n\t\t}\n        \n\t\tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n\n        ((org.smooks.engine.delivery.sax.ng.org.apache.xerces.dom.AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n    }\n\n    /**\n     * DOM Level 3: register the given attribute node as an ID attribute\n     */\n    public void setIdAttributeNS(String namespaceURI, String localName,\n                                    boolean makeId) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        Attr at = getAttributeNodeNS(namespaceURI, localName);\n\t\t\n\t\tif( at == null){\n       \t\tString msg = DOMMessageFormatter.formatMessage(\n\t\t\t\t\t\t\t\t\tDOMMessageFormatter.DOM_DOMAIN, \n\t\t\t\t\t\t\t\t\t\"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n\t\t}\n       \n\t\tif (ownerDocument.errorChecking) {\n            if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(\n                                     DOMException.NO_MODIFICATION_ALLOWED_ERR,\n                                     msg);\n            }\n\n            if (at.getOwnerElement() != this) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            }\n        }\n        ((AttrImpl) at).isIdAttribute(makeId);\n        if (!makeId) {\n            ownerDocument.removeIdentifier(at.getValue());\n        }\n        else {\n            ownerDocument.putIdentifier(at.getValue(), this);\n        }\n   }\n\n    /**\n     * @see TypeInfo#getTypeName()\n     */\n     public String getTypeName() {\n        return null;\n     }\n\n    /**\n     * @see TypeInfo#getTypeNamespace()\n     */\n    public String getTypeNamespace() {\n        return null;\n    }\n\n    /**\n     * Introduced in DOM Level 3. <p>\n     * Checks if a type is derived from another by restriction. See:\n     * http://www.w3.org/TR/DOM-Level-3-Core/core.html#TypeInfo-isDerivedFrom\n     * \n     * @param typeNamespaceArg \n     *        The namspace of the ancestor type declaration\n     * @param typeNameArg\n     *        The name of the ancestor type declaration\n     * @param derivationMethod\n     *        The derivation method\n     * \n     * @return boolean True if the type is derived by restriciton for the\n     *         reference type\n     */\n    public boolean isDerivedFrom(String typeNamespaceArg, \n                                 String typeNameArg, \n                                 int derivationMethod) {\n                                 \t\n        return false;\n    }\n\n\t/**\n\t * Method getSchemaTypeInfo.\n\t * @return TypeInfo\n\t */\n    public TypeInfo getSchemaTypeInfo(){\n        if(needsSyncData()) {\n            synchronizeData();\n        }\n        return this;\n    }\n\n    //\n    // Public methods\n    //\n\n    /**\n     * NON-DOM: Subclassed to flip the attributes' readonly switch as well.\n     * @see NodeImpl#setReadOnly\n     */\n    public void setReadOnly(boolean readOnly, boolean deep) {\n    \tsuper.setReadOnly(readOnly,deep);\n        if (attributes != null) {\n            attributes.setReadOnly(readOnly,true);\n        }\n    }\n\n\n\n    //\n    // Protected methods\n    //\n\n    /** Synchronizes the data (name and value) for fast nodes. */\n    protected void synchronizeData() {\n\n        // no need to sync in the future\n        needsSyncData(false);\n\n        // we don't want to generate any event for this so turn them off\n        boolean orig = ownerDocument.getMutationEvents();\n        ownerDocument.setMutationEvents(false);\n\n        // attributes\n        setupDefaultAttributes();\n\n        // set mutation events flag back to its original value\n        ownerDocument.setMutationEvents(orig);\n\n    } // synchronizeData()\n\n    // support for DOM Level 3 renameNode method\n    // @param el The element from which to take the attributes\n    void moveSpecifiedAttributes(ElementImpl el) {\n        if (needsSyncData()) {\n            synchronizeData();\n        }\n        if (el.hasAttributes()) {\n            if (attributes == null) {\n                attributes = new AttributeMap(this, null);\n            }\n            attributes.moveSpecifiedAttributes(el.attributes);\n        }\n    }\n\n    /** Setup the default attributes. */\n    protected void setupDefaultAttributes() {\n        NamedNodeMapImpl defaults = getDefaultAttributes();\n        if (defaults != null) {\n            attributes = new AttributeMap(this, defaults);\n        }\n    }\n\n    /** Reconcile default attributes. */\n    protected void reconcileDefaultAttributes() {\n        if (attributes != null) {\n            NamedNodeMapImpl defaults = getDefaultAttributes();\n            attributes.reconcileDefaults(defaults);\n        }\n    }\n\n    /** Get the default attributes. */\n    protected NamedNodeMapImpl getDefaultAttributes() {\n\n    \tDocumentTypeImpl doctype =\n            (DocumentTypeImpl) ownerDocument.getDoctype();\n    \tif (doctype == null) {\n            return null;\n        }\n        ElementDefinitionImpl eldef =\n            (ElementDefinitionImpl)doctype.getElements()\n                                               .getNamedItem(getNodeName());\n        if (eldef == null) {\n            return null;\n        }\n        return (NamedNodeMapImpl) eldef.getAttributes();\n\n    } // getDefaultAttributes()\n    \n    //\n    // ElementTraversal methods\n    //\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-childElementCount\">\n     * Element Traversal Specification</a>\n     */\n    public final int getChildElementCount() {\n        int count = 0;\n        Element child = getFirstElementChild();\n        while (child != null) {\n            ++count;\n            child = ((ElementImpl) child).getNextElementSibling();\n        }\n        return count;\n    } // getChildElementCount():int\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-firstElementChild\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getFirstElementChild() {\n        Node n = getFirstChild();\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getFirstElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = n.getNextSibling();\n        }\n        return null;\n    } // getFirstElementChild():Element\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-lastElementChild\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getLastElementChild() {\n        Node n = getLastChild();\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getLastElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = n.getPreviousSibling();\n        }\n        return null;\n    } // getLastElementChild():Element\n\n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-nextElementSibling\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getNextElementSibling() {\n        Node n = getNextLogicalSibling(this);\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getFirstElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = getNextLogicalSibling(n);\n        }\n        return null;\n    } // getNextElementSibling():Element\n    \n    /**\n     * @see <a href=\"http://www.w3.org/TR/2008/REC-ElementTraversal-20081222/#attribute-previousElementSibling\">\n     * Element Traversal Specification</a>\n     */\n    public final Element getPreviousElementSibling() {\n        Node n = getPreviousLogicalSibling(this);\n        while (n != null) {\n            switch (n.getNodeType()) {\n                case Node.ELEMENT_NODE:\n                    return (Element) n;\n                case Node.ENTITY_REFERENCE_NODE:\n                    final Element e = getLastElementChild(n);\n                    if (e != null) {\n                        return e;\n                    }\n                    break;\n            }\n            n = getPreviousLogicalSibling(n);\n        }\n        return null;\n    } // getPreviousElementSibling():Element\n    \n    // Returns the first element node found from a \n    // non-recursive in order traversal of the given node.\n    private Element getFirstElementChild(Node n) {\n        final Node top = n;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                return (Element) n;\n            }\n            Node next = n.getFirstChild();\n            while (next == null) {         \n                if (top == n) {\n                    break;\n                }\n                next = n.getNextSibling();\n                if (next == null) {\n                    n = n.getParentNode();\n                    if (n == null || top == n) {\n                        return null;\n                    }\n                }\n            }\n            n = next;\n        }\n        return null;\n    } // getFirstElementChild(Node):Element\n    \n    // Returns the first element node found from a \n    // non-recursive reverse order traversal of the given node.\n    private Element getLastElementChild(Node n) {\n        final Node top = n;\n        while (n != null) {\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                return (Element) n;\n            }\n            Node next = n.getLastChild();\n            while (next == null) {         \n                if (top == n) {\n                    break;\n                }\n                next = n.getPreviousSibling();\n                if (next == null) {\n                    n = n.getParentNode();\n                    if (n == null || top == n) {\n                        return null;\n                    }\n                }\n            }\n            n = next;\n        }\n        return null;\n    } // getLastElementChild(Node):Element\n    \n    // Returns the next logical sibling with respect to the given node.\n    private Node getNextLogicalSibling(Node n) {\n        Node next = n.getNextSibling();\n        // If \"n\" has no following sibling and its parent is an entity reference node we \n        // need to continue the search through the following siblings of the entity \n        // reference as these are logically siblings of the given node.\n        if (next == null) {\n            Node parent = n.getParentNode();\n            while (parent != null && parent.getNodeType() == Node.ENTITY_REFERENCE_NODE) {\n                next = parent.getNextSibling();\n                if (next != null) {\n                    break;\n                }\n                parent = parent.getParentNode();\n            }\n        }\n        return next;\n    } // getNextLogicalSibling(Node):Node\n    \n    // Returns the previous logical sibling with respect to the given node.\n    private Node getPreviousLogicalSibling(Node n) {\n        Node prev = n.getPreviousSibling();\n        // If \"n\" has no previous sibling and its parent is an entity reference node we \n        // need to continue the search through the previous siblings of the entity \n        // reference as these are logically siblings of the given node.\n        if (prev == null) {\n            Node parent = n.getParentNode();\n            while (parent != null && parent.getNodeType() == Node.ENTITY_REFERENCE_NODE) {\n                prev = parent.getPreviousSibling();\n                if (prev != null) {\n                    break;\n                }\n                parent = parent.getParentNode();\n            }\n        }\n        return prev;\n    } // getPreviousLogicalSibling(Node):Node\n\n} // class ElementImpl\n",
    "project": "smooks",
    "libraryName": "xml-apis",
    "libraryGroupID": "xml-apis",
    "newVersion": "2.0.0",
    "previousVersion": "1.4.01",
    "breakingCommit": "6f067d9679caa4a8b2086f1e2b4d177ab19cb3b3"
}