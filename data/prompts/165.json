{
    "absolute_path_to_file_in_container": "/cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java",
    "errors": [
        {
            "line_number": 32,
            "message": "[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[32,21] cannot find symbol",
            "additional_info": "  symbol:   class BomGeneratorFactory\n  location: package org.cyclonedx",
            "file_name": "BaseCycloneDxMojo.java",
            "uid": "4a23ce95-aef2-53bd-9c27-c048b528fc47"
        },
        {
            "line_number": 85,
            "message": "[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[85,28] cannot find symbol",
            "additional_info": "  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema",
            "file_name": "BaseCycloneDxMojo.java",
            "uid": "a891cc77-8c36-5613-b35a-020802ac7377"
        },
        {
            "line_number": 480,
            "message": "[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[480,30] cannot find symbol",
            "additional_info": "  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema",
            "file_name": "BaseCycloneDxMojo.java",
            "uid": "a891cc77-8c36-5613-b35a-020802ac7377"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: cyclonedx-core-java 8.0.3->9.0.2\n\nthe following client code fails: \n'''java\n/*\n * This file is part of CycloneDX Maven Plugin.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n * Copyright (c) OWASP Foundation. All Rights Reserved.\n */\npackage org.cyclonedx.maven;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.PluginExecution;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalysis;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\nimport org.cyclonedx.BomGeneratorFactory;\nimport org.cyclonedx.CycloneDxSchema;\nimport org.cyclonedx.exception.GeneratorException;\nimport org.cyclonedx.generators.json.BomJsonGenerator;\nimport org.cyclonedx.generators.xml.BomXmlGenerator;\nimport org.cyclonedx.maven.ProjectDependenciesConverter.BomDependencies;\nimport org.cyclonedx.model.Bom;\nimport org.cyclonedx.model.Component;\nimport org.cyclonedx.model.Dependency;\nimport org.cyclonedx.model.ExternalReference;\nimport org.cyclonedx.model.LifecycleChoice;\nimport org.cyclonedx.model.Lifecycles;\nimport org.cyclonedx.model.Metadata;\nimport org.cyclonedx.model.Property;\nimport org.cyclonedx.parsers.JsonParser;\nimport org.cyclonedx.parsers.Parser;\nimport org.cyclonedx.parsers.XmlParser;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\npublic abstract class BaseCycloneDxMojo extends AbstractMojo {\n\n    @Parameter(property = \"project\", readonly = true, required = true)\n    private MavenProject project;\n\n    /**\n     * The component type associated to the SBOM metadata. See\n     * <a href=\"https://cyclonedx.org/docs/1.5/json/#metadata_component_type\">CycloneDX reference</a> for supported\n     * values. \n     *\n     * @since 2.0.0\n     */\n    @Parameter(property = \"projectType\", defaultValue = \"library\", required = false)\n    private String projectType;\n\n    /**\n     * The CycloneDX schema version the BOM will comply with.\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"schemaVersion\", defaultValue = \"1.5\", required = false)\n    private String schemaVersion;\n    private CycloneDxSchema.Version effectiveSchemaVersion = null;\n\n    /**\n     * The CycloneDX output format that should be generated (<code>xml</code>, <code>json</code> or <code>all</code>).\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"outputFormat\", defaultValue = \"all\", required = false)\n    private String outputFormat;\n\n    /**\n     * The CycloneDX output file name (without extension) that should be generated (in {@code outputDirectory} directory).\n     *\n     * @since 2.2.0\n     */\n    @Parameter(property = \"outputName\", defaultValue = \"bom\", required = false)\n    private String outputName;\n\n    /**\n     * The output directory where to store generated CycloneDX output files.\n     *\n     * @since 2.7.5\n     */\n    @Parameter(property = \"outputDirectory\", defaultValue = \"${project.build.directory}\", required = false)\n    private File outputDirectory;\n\n    /**\n     * Should the resulting BOM contain a unique serial number?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeBomSerialNumber\", defaultValue = \"true\", required = false)\n    private boolean includeBomSerialNumber;\n\n    /**\n     * Should compile scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeCompileScope\", defaultValue = \"true\", required = false)\n    private boolean includeCompileScope;\n\n    /**\n     * Should provided scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeProvidedScope\", defaultValue = \"true\", required = false)\n    private boolean includeProvidedScope;\n\n    /**\n     * Should runtime scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeRuntimeScope\", defaultValue = \"true\", required = false)\n    private boolean includeRuntimeScope;\n\n    /**\n     * Should test scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeTestScope\", defaultValue = \"false\", required = false)\n    private boolean includeTestScope;\n\n    /**\n     * Should system scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeSystemScope\", defaultValue = \"true\", required = false)\n    private boolean includeSystemScope;\n\n    /**\n     * Should license text be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeLicenseText\", defaultValue = \"false\", required = false)\n    private boolean includeLicenseText;\n\n    /**\n     * Excluded types.\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"excludeTypes\", required = false)\n    private String[] excludeTypes;\n\n    /**\n     * Use the original mechanism for determining whether a component has OPTIONAL or REQUIRED scope,\n     * relying on bytecode analysis of the compiled classes instead of the Maven dependency declaration of optional.\n     *\n     * @since 2.7.9\n     */\n    @Parameter(property = \"detectUnusedForOptionalScope\", defaultValue = \"false\")\n    protected boolean detectUnusedForOptionalScope;\n\n    /**\n     * Skip CycloneDX execution.\n     *\n     * @since 1.1.3\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.skip\", defaultValue = \"false\", required = false)\n    private boolean skip = false;\n\n    /**\n     * Don't attach bom.\n     *\n     * @since 2.1.0\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.skipAttach\", defaultValue = \"false\", required = false)\n    private boolean skipAttach = false;\n\n    /**\n     * Classifier of the attached sbom\n     *\n     * @since 2.8.1\n     */\n    @Parameter(property = \"cyclonedx.classifier\", defaultValue = \"cyclonedx\")\n    private String classifier;\n\n    /**\n     * Verbose output.\n     *\n     * @since 2.6.0\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.verbose\", defaultValue = \"false\", required = false)\n    private boolean verbose = false;\n\n    /**\n     * Timestamp for reproducible output archive entries, either formatted as ISO 8601\n     * <code>yyyy-MM-dd'T'HH:mm:ssXXX</code> or as an int representing seconds since the epoch (like\n     * <a href=\"https://reproducible-builds.org/docs/source-date-epoch/\">SOURCE_DATE_EPOCH</a>).\n     *\n     * @since 2.7.9\n     */\n    @Parameter( defaultValue = \"${project.build.outputTimestamp}\" )\n    private String outputTimestamp;\n\n    /**\n     * <a href=\"https://cyclonedx.org/docs/1.5/json/#metadata_component_externalReferences_items_type\">External references</a>\n     * to be added to the component the BOM describes <code>$.metadata.component.externalReferences[]</code>:\n     * <pre>\n     * &lt;externalReferences&gt;\n     *   &lt;externalReference&gt;\n     *     &lt;type>EXTERNAL_REFERENCE_TYPE&lt;/type&gt;&lt;-- constant id corresponding to \"external-reference-type\" SBOM type --&gt;\n     *     &lt;url>https://...&lt;/url&gt;\n     *     &lt;comment>(optional) comment&lt;/comment&gt;\n     *   &lt;/externalReference&gt;\n     * &lt;/externalReferences&gt;\n     * </pre>\n     *\n     * @see <a href=\"https://cyclonedx.github.io/cyclonedx-core-java/org/cyclonedx/model/ExternalReference.Type.html\">ExternalReference.Type constants</a>\n     * @since 2.7.11\n     */\n    @Parameter\n    private ExternalReference[] externalReferences;\n\n    @org.apache.maven.plugins.annotations.Component\n    private MavenProjectHelper mavenProjectHelper;\n\n    @org.apache.maven.plugins.annotations.Component\n    private ModelConverter modelConverter;\n\n    @org.apache.maven.plugins.annotations.Component\n    private ProjectDependenciesConverter projectDependenciesConverter;\n\n    /**\n     * Various messages sent to console.\n     */\n    protected static final String MESSAGE_RESOLVING_DEPS = \"CycloneDX: Resolving Dependencies\";\n    protected static final String MESSAGE_RESOLVING_AGGREGATED_DEPS = \"CycloneDX: Resolving Aggregated Dependencies\";\n    protected static final String MESSAGE_CREATING_BOM = \"CycloneDX: Creating BOM version %s with %d component(s)\";\n    static final String MESSAGE_CALCULATING_HASHES = \"CycloneDX: Calculating Hashes\";\n    protected static final String MESSAGE_WRITING_BOM = \"CycloneDX: Writing and validating BOM (%s): %s\";\n    protected static final String MESSAGE_ATTACHING_BOM = \"           attaching as %s-%s-cyclonedx.%s\";\n    protected static final String MESSAGE_VALIDATION_FAILURE = \"The BOM does not conform to the CycloneDX BOM standard as defined by the XSD\";\n\n    /**\n     * Maven plugins that deploy artifacts.\n     */\n    private static final String MAVEN_DEPLOY_PLUGIN = \"org.apache.maven.plugins:maven-deploy-plugin\";\n    private static final String NEXUS_STAGING_PLUGIN = \"org.sonatype.plugins:nexus-staging-maven-plugin\";\n\n    /**\n     * Returns a reference to the current project.\n     *\n     * @return returns a reference to the current project\n     */\n    protected MavenProject getProject() {\n        return project;\n    }\n\n    protected String generatePackageUrl(final Artifact artifact) {\n        return modelConverter.generatePackageUrl(artifact);\n    }\n\n    protected Component convertMavenDependency(Artifact artifact) {\n        return modelConverter.convertMavenDependency(artifact, schemaVersion(), includeLicenseText);\n    }\n\n    /**\n     * Analyze the current Maven project to extract the BOM components list and their dependencies.\n     *\n     * @param topLevelComponents the PURLs for all top level components\n     * @param components the components map to fill\n     * @param dependencies the dependencies map to fill\n     * @return the name of the analysis done to store as a BOM, or {@code null} to not save result.\n     * @throws MojoExecutionException something weird happened...\n     */\n    protected abstract String extractComponentsAndDependencies(Set<String> topLevelComponents, Map<String, Component> components, Map<String, Dependency> dependencies) throws MojoExecutionException;\n\n    /**\n     * @return {@literal true} if the execution should be skipped.\n     */\n    protected boolean shouldSkip() {\n        return Boolean.parseBoolean(System.getProperty(\"cyclonedx.skip\", Boolean.toString(skip)));\n    }\n\n    protected String getSkipReason() {\n        return null;\n    }\n\n    public void execute() throws MojoExecutionException {\n        if (shouldSkip()) {\n            final String skipReason = getSkipReason();\n            if (skipReason != null) {\n                getLog().info(\"Skipping CycloneDX goal, because \" + skipReason);\n            } else {\n                getLog().info(\"Skipping CycloneDX goal\");\n            }\n            return;\n        }\n        if (!schemaVersion().getVersionString().equals(schemaVersion)) {\n            getLog().warn(\"Invalid schemaVersion configured '\" + schemaVersion +\"', using \" + effectiveSchemaVersion.getVersionString());\n            schemaVersion = effectiveSchemaVersion.getVersionString();\n        }\n        logParameters();\n\n        // top level components do not currently set their scope, we track these to prevent merging of scopes\n        final Set<String> topLevelComponents = new LinkedHashSet<>();\n        final Map<String, Component> componentMap = new LinkedHashMap<>();\n        final Map<String, Dependency> dependencyMap = new LinkedHashMap<>();\n\n        String analysis = extractComponentsAndDependencies(topLevelComponents, componentMap, dependencyMap);\n        if (analysis != null) {\n            final Metadata metadata = modelConverter.convertMavenProject(project, projectType, schemaVersion(), includeLicenseText, externalReferences);\n\n            if (schemaVersion().getVersion() >= 1.3) {\n                metadata.addProperty(newProperty(\"maven.goal\", analysis));\n\n                List<String> scopes = new ArrayList<>();\n                if (includeCompileScope) scopes.add(\"compile\");\n                if (includeProvidedScope) scopes.add(\"provided\");\n                if (includeRuntimeScope) scopes.add(\"runtime\");\n                if (includeSystemScope) scopes.add(\"system\");\n                if (includeTestScope) scopes.add(\"test\");\n                metadata.addProperty(newProperty(\"maven.scopes\", String.join(\",\", scopes)));\n\n                if (detectUnusedForOptionalScope) {\n                    metadata.addProperty(newProperty(\"maven.optional.unused\", Boolean.toString(detectUnusedForOptionalScope)));\n                }\n            }\n\n            final Component rootComponent = metadata.getComponent();\n            componentMap.remove(rootComponent.getPurl());\n\n            projectDependenciesConverter.cleanupBomDependencies(metadata, componentMap, dependencyMap);\n\n            generateBom(analysis, metadata, new ArrayList<>(componentMap.values()), new ArrayList<>(dependencyMap.values()));\n        }\n    }\n\n    private Property newProperty(String name, String value) {\n        Property property = new Property();\n        property.setName(name);\n        property.setValue(value);\n        return property;\n    }\n\n    private void generateBom(String analysis, Metadata metadata, List<Component> components, List<Dependency> dependencies) throws MojoExecutionException {\n        try {\n            getLog().info(String.format(MESSAGE_CREATING_BOM, schemaVersion, components.size()));\n            final Bom bom = new Bom();\n            bom.setComponents(components);\n\n            if (outputTimestamp != null) {\n                // activate Reproducible Builds mode\n                metadata.setTimestamp(null);\n                if (schemaVersion().getVersion() >= 1.3) {\n                    metadata.addProperty(newProperty(\"cdx:reproducible\", \"enabled\"));\n                }\n            }\n\n            if (schemaVersion().getVersion() >= 1.1 && includeBomSerialNumber) {\n                String serialNumber = generateSerialNumber(metadata.getProperties());\n                bom.setSerialNumber(serialNumber);\n            }\n\n            if (schemaVersion().getVersion() >= 1.2) {\n                bom.setMetadata(metadata);\n                bom.setDependencies(dependencies);\n            }\n\n            /*if (schemaVersion().getVersion() >= 1.3) {\n                if (excludeArtifactId != null && excludeTypes.length > 0) { // TODO\n                    final Composition composition = new Composition();\n                    composition.setAggregate(Composition.Aggregate.INCOMPLETE);\n                    composition.setDependencies(Collections.singletonList(new Dependency(bom.getMetadata().getComponent().getBomRef())));\n                    bom.setCompositions(Collections.singletonList(composition));\n                }\n            }*/\n\n            if (schemaVersion().getVersion() >= 1.5) {\n                LifecycleChoice build = new LifecycleChoice();\n                build.setPhase(LifecycleChoice.Phase.BUILD);\n                Lifecycles lifecycles = new Lifecycles();\n                lifecycles.setLifecycleChoice(Collections.singletonList(build));\n                metadata.setLifecycles(lifecycles);\n            }\n\n            if (\"all\".equalsIgnoreCase(outputFormat)\n                    || \"xml\".equalsIgnoreCase(outputFormat)\n                    || \"json\".equalsIgnoreCase(outputFormat)) {\n                saveBom(bom);\n            } else {\n                getLog().error(\"Unsupported output format. Valid options are XML and JSON\");\n            }\n        } catch (GeneratorException | ParserConfigurationException | IOException e) {\n            throw new MojoExecutionException(\"An error occurred executing \" + this.getClass().getName() + \": \" + e.getMessage(), e);\n        }\n    }\n\n    private String generateSerialNumber(List<Property> properties) {\n        String gav = String.format(\"%s:%s:%s\", project.getGroupId(), project.getArtifactId(), project.getVersion());\n        StringBuilder sb = new StringBuilder(gav);\n        if (properties != null) {\n            for(Property prop: properties) {\n                sb.append(';');\n                sb.append(prop.getName());\n                sb.append('=');\n                sb.append(prop.getValue());\n            }\n        }\n        UUID uuid = UUID.nameUUIDFromBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n        return String.format(\"urn:uuid:%s\", uuid);\n    }\n\n    private void saveBom(Bom bom) throws ParserConfigurationException, IOException, GeneratorException,\n            MojoExecutionException {\n        if (\"all\".equalsIgnoreCase(outputFormat) || \"xml\".equalsIgnoreCase(outputFormat)) {\n            final BomXmlGenerator bomGenerator = BomGeneratorFactory.createXml(schemaVersion(), bom);\n            //bomGenerator.generate();\n\n            final String bomString = bomGenerator.toXmlString();\n            saveBomToFile(bomString, \"xml\", new XmlParser());\n        }\n        if (\"all\".equalsIgnoreCase(outputFormat) || \"json\".equalsIgnoreCase(outputFormat)) {\n            final BomJsonGenerator bomGenerator = BomGeneratorFactory.createJson(schemaVersion(), bom);\n\n            final String bomString = bomGenerator.toJsonString();\n            saveBomToFile(bomString, \"json\", new JsonParser());\n        }\n    }\n\n    private void saveBomToFile(String bomString, String extension, Parser bomParser) throws IOException, MojoExecutionException {\n        final File bomFile = new File(outputDirectory, outputName + \".\" + extension);\n\n        getLog().info(String.format(MESSAGE_WRITING_BOM, extension.toUpperCase(), bomFile.getAbsolutePath()));\n        FileUtils.write(bomFile, bomString, StandardCharsets.UTF_8, false);\n\n        if (!bomParser.isValid(bomFile, schemaVersion())) {\n            throw new MojoExecutionException(MESSAGE_VALIDATION_FAILURE);\n        }\n\n        if (!skipAttach) {\n            getLog().info(String.format(MESSAGE_ATTACHING_BOM, project.getArtifactId(), project.getVersion(), extension));\n            mavenProjectHelper.attachArtifact(project, extension, classifier, bomFile);\n        }\n    }\n\n    protected BomDependencies extractBOMDependencies(MavenProject mavenProject) throws MojoExecutionException {\n        ProjectDependenciesConverter.MavenDependencyScopes include = new ProjectDependenciesConverter.MavenDependencyScopes(includeCompileScope, includeProvidedScope, includeRuntimeScope, includeTestScope, includeSystemScope);\n        return projectDependenciesConverter.extractBOMDependencies(mavenProject, include, excludeTypes);\n    }\n\n    /**\n     * Resolves the CycloneDX schema the mojo has been requested to use.\n     * @return the CycloneDX schema to use\n     */\n    protected CycloneDxSchema.Version schemaVersion() {\n        if (effectiveSchemaVersion == null) {\n            if (\"1.0\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_10;\n            } else if (\"1.1\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_11;\n            } else if (\"1.2\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_12;\n            } else if (\"1.3\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_13;\n            } else if (\"1.4\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_14;\n            } else {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_15;\n            }\n        }\n        return effectiveSchemaVersion;\n    }\n\n    protected void logAdditionalParameters() {\n        // no additional parameters\n    }\n\n    protected void logParameters() {\n        if (verbose && getLog().isInfoEnabled()) {\n            getLog().info(\"CycloneDX: Parameters\");\n            getLog().info(\"------------------------------------------------------------------------\");\n            getLog().info(\"schemaVersion          : \" + schemaVersion().getVersionString());\n            getLog().info(\"includeBomSerialNumber : \" + includeBomSerialNumber);\n            getLog().info(\"includeCompileScope    : \" + includeCompileScope);\n            getLog().info(\"includeProvidedScope   : \" + includeProvidedScope);\n            getLog().info(\"includeRuntimeScope    : \" + includeRuntimeScope);\n            getLog().info(\"includeTestScope       : \" + includeTestScope);\n            getLog().info(\"includeSystemScope     : \" + includeSystemScope);\n            getLog().info(\"includeLicenseText     : \" + includeLicenseText);\n            getLog().info(\"outputFormat           : \" + outputFormat);\n            getLog().info(\"outputName             : \" + outputName);\n            logAdditionalParameters();\n            getLog().info(\"------------------------------------------------------------------------\");\n        }\n    }\n\n    protected void populateComponents(final Set<String> topLevelComponents, final Map<String, Component> components, final Map<String, Artifact> artifacts, final ProjectDependencyAnalysis dependencyAnalysis) {\n        for (Map.Entry<String, Artifact> entry: artifacts.entrySet()) {\n            final String purl = entry.getKey();\n            final Artifact artifact = entry.getValue();\n            final Component.Scope artifactScope = getComponentScope(artifact, dependencyAnalysis);\n            final Component component = components.get(purl);\n            if (component == null) {\n                final Component newComponent = convertMavenDependency(artifact);\n                newComponent.setScope(artifactScope);\n                components.put(purl, newComponent);\n            } else if (!topLevelComponents.contains(purl)) {\n                component.setScope(mergeScopes(component.getScope(), artifactScope));\n            }\n        }\n    }\n\n    /**\n     * Get the BOM component scope (required/optional/excluded).  The scope can either be determined through bytecode\n     * analysis or through maven dependency resolution.\n     *\n     * @param artifact Artifact from maven project\n     * @param projectDependencyAnalysis Maven Project Dependency Analysis data\n     *\n     * @return Component.Scope - REQUIRED, OPTIONAL or null if it cannot be determined\n     *\n     * @see #detectUnusedForOptionalScope\n     */\n    private Component.Scope getComponentScope(Artifact artifact, ProjectDependencyAnalysis projectDependencyAnalysis) {\n        if (detectUnusedForOptionalScope) {\n            return inferComponentScope(artifact, projectDependencyAnalysis);\n        } else {\n            return (artifact.isOptional() ? Component.Scope.OPTIONAL : Component.Scope.REQUIRED);\n        }\n    }\n\n    /**\n     * Infer BOM component scope (required/optional/excluded) based on Maven project dependency analysis.\n     *\n     * @param artifact Artifact from maven project\n     * @param projectDependencyAnalysis Maven Project Dependency Analysis data\n     *\n     * @return Component.Scope - REQUIRED: If the component is used (as detected by project dependency analysis). OPTIONAL: If it is unused\n     */\n    private Component.Scope inferComponentScope(Artifact artifact, ProjectDependencyAnalysis projectDependencyAnalysis) {\n        if (projectDependencyAnalysis == null) {\n            return null;\n        }\n\n        Set<Artifact> usedDeclaredArtifacts = projectDependencyAnalysis.getUsedDeclaredArtifacts();\n        Set<Artifact> usedUndeclaredArtifacts = projectDependencyAnalysis.getUsedUndeclaredArtifacts();\n        Set<Artifact> unusedDeclaredArtifacts = projectDependencyAnalysis.getUnusedDeclaredArtifacts();\n        Set<Artifact> testArtifactsWithNonTestScope = projectDependencyAnalysis.getTestArtifactsWithNonTestScope();\n\n        // Is the artifact used?\n        if (usedDeclaredArtifacts.contains(artifact) || usedUndeclaredArtifacts.contains(artifact)) {\n            return Component.Scope.REQUIRED;\n        }\n\n        // Is the artifact unused or test?\n        if (unusedDeclaredArtifacts.contains(artifact) || testArtifactsWithNonTestScope.contains(artifact)) {\n            return Component.Scope.OPTIONAL;\n        }\n\n        return null;\n    }\n\n    // Merging of scopes follows the method previously implemented in the aggregate code.  This needs to be fixed in a future PR.\n    private Component.Scope mergeScopes(final Component.Scope existing, final Component.Scope project) {\n        if ((Component.Scope.REQUIRED == existing) || (Component.Scope.REQUIRED == project)) {\n            return Component.Scope.REQUIRED;\n        }\n        if (null == existing) {\n            return project;\n        }\n        return existing;\n    }\n\n    static boolean isDeployable(final MavenProject project) {\n        return isDeployable(project,\n                        MAVEN_DEPLOY_PLUGIN,\n                        \"skip\",\n                        \"maven.deploy.skip\")\n                || isDeployable(project,\n                        NEXUS_STAGING_PLUGIN,\n                        \"skipNexusStagingDeployMojo\",\n                        \"skipNexusStagingDeployMojo\");\n    }\n\n    private static boolean isDeployable(final MavenProject project,\n                                        final String pluginKey,\n                                        final String parameter,\n                                        final String propertyName) {\n        final Plugin plugin = project.getPlugin(pluginKey);\n        if (plugin != null) {\n            // Default skip value\n            final String property = System.getProperty(propertyName, project.getProperties().getProperty(propertyName));\n            final boolean defaultSkipValue = property != null ? Boolean.parseBoolean(property) : false;\n            // Find an execution that is not skipped\n            for (final PluginExecution execution : plugin.getExecutions()) {\n                if (execution.getGoals().contains(\"deploy\")) {\n                    final Xpp3Dom executionConf = (Xpp3Dom) execution.getConfiguration();\n                    boolean skipValue = defaultSkipValue;\n                    if (executionConf != null) {\n                        Xpp3Dom target = executionConf.getChild(parameter);\n                        if (target != null) {\n                            skipValue = Boolean.parseBoolean(target.getValue());\n                        }\n                    }\n                    if (!skipValue) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\nimport org.cyclonedx.BomGeneratorFactory;\n    private CycloneDxSchema.Version effectiveSchemaVersion = null;\n    protected CycloneDxSchema.Version schemaVersion() {\nwith the following error message:\n[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[32,21] cannot find symbol  symbol:   class BomGeneratorFactory\n  location: package org.cyclonedx\n[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[85,28] cannot find symbol  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema\n[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[480,30] cannot find symbol  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.cyclonedx.model.LicenseChoice.getExpression | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.cyclonedx.CycloneDxSchema.ALL_VERSIONS | MUTATION | FIELD_TYPE_CHANGED\norg.cyclonedx.model.LicenseChoice.setExpression | DELETION | METHOD_REMOVED\norg.cyclonedx.CycloneDxSchema.getXmlSchema | DELETION | METHOD_REMOVED\norg.cyclonedx.util.serializer.LicenseChoiceSerializer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.cyclonedx.util.BomUtils.calculateHashes | DELETION | METHOD_REMOVED\norg.cyclonedx.BomGeneratorFactory | DELETION | TYPE_REMOVED\norg.cyclonedx.util.serializer.MetadataSerializer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.cyclonedx.CycloneDxSchema.VERSION_LATEST | MUTATION | FIELD_TYPE_CHANGED\norg.cyclonedx.CycloneDxSchema$Version | DELETION | TYPE_REMOVED\norg.cyclonedx.CycloneDxSchema.getJsonSchema | DELETION | METHOD_REMOVED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "import org.cyclonedx.BomGeneratorFactory;\n    private CycloneDxSchema.Version effectiveSchemaVersion = null;\n    protected CycloneDxSchema.Version schemaVersion() {",
    "error_message": "[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[32,21] cannot find symbol  symbol:   class BomGeneratorFactory\n  location: package org.cyclonedx\n[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[85,28] cannot find symbol  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema\n[ERROR] /cyclonedx-maven-plugin/src/main/java/org/cyclonedx/maven/BaseCycloneDxMojo.java:[480,30] cannot find symbol  symbol:   class Version\n  location: class org.cyclonedx.CycloneDxSchema",
    "api_diff": "Format: element | nature | kind\norg.cyclonedx.model.LicenseChoice.getExpression | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.cyclonedx.CycloneDxSchema.ALL_VERSIONS | MUTATION | FIELD_TYPE_CHANGED\norg.cyclonedx.model.LicenseChoice.setExpression | DELETION | METHOD_REMOVED\norg.cyclonedx.CycloneDxSchema.getXmlSchema | DELETION | METHOD_REMOVED\norg.cyclonedx.util.serializer.LicenseChoiceSerializer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.cyclonedx.util.BomUtils.calculateHashes | DELETION | METHOD_REMOVED\norg.cyclonedx.BomGeneratorFactory | DELETION | TYPE_REMOVED\norg.cyclonedx.util.serializer.MetadataSerializer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.cyclonedx.CycloneDxSchema.VERSION_LATEST | MUTATION | FIELD_TYPE_CHANGED\norg.cyclonedx.CycloneDxSchema$Version | DELETION | TYPE_REMOVED\norg.cyclonedx.CycloneDxSchema.getJsonSchema | DELETION | METHOD_REMOVED",
    "original_code": "/*\n * This file is part of CycloneDX Maven Plugin.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n * Copyright (c) OWASP Foundation. All Rights Reserved.\n */\npackage org.cyclonedx.maven;\n\nimport org.apache.commons.io.FileUtils;\nimport org.apache.maven.artifact.Artifact;\nimport org.apache.maven.model.Plugin;\nimport org.apache.maven.model.PluginExecution;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.MavenProjectHelper;\nimport org.apache.maven.shared.dependency.analyzer.ProjectDependencyAnalysis;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\nimport org.cyclonedx.BomGeneratorFactory;\nimport org.cyclonedx.CycloneDxSchema;\nimport org.cyclonedx.exception.GeneratorException;\nimport org.cyclonedx.generators.json.BomJsonGenerator;\nimport org.cyclonedx.generators.xml.BomXmlGenerator;\nimport org.cyclonedx.maven.ProjectDependenciesConverter.BomDependencies;\nimport org.cyclonedx.model.Bom;\nimport org.cyclonedx.model.Component;\nimport org.cyclonedx.model.Dependency;\nimport org.cyclonedx.model.ExternalReference;\nimport org.cyclonedx.model.LifecycleChoice;\nimport org.cyclonedx.model.Lifecycles;\nimport org.cyclonedx.model.Metadata;\nimport org.cyclonedx.model.Property;\nimport org.cyclonedx.parsers.JsonParser;\nimport org.cyclonedx.parsers.Parser;\nimport org.cyclonedx.parsers.XmlParser;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\n\npublic abstract class BaseCycloneDxMojo extends AbstractMojo {\n\n    @Parameter(property = \"project\", readonly = true, required = true)\n    private MavenProject project;\n\n    /**\n     * The component type associated to the SBOM metadata. See\n     * <a href=\"https://cyclonedx.org/docs/1.5/json/#metadata_component_type\">CycloneDX reference</a> for supported\n     * values. \n     *\n     * @since 2.0.0\n     */\n    @Parameter(property = \"projectType\", defaultValue = \"library\", required = false)\n    private String projectType;\n\n    /**\n     * The CycloneDX schema version the BOM will comply with.\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"schemaVersion\", defaultValue = \"1.5\", required = false)\n    private String schemaVersion;\n    private CycloneDxSchema.Version effectiveSchemaVersion = null;\n\n    /**\n     * The CycloneDX output format that should be generated (<code>xml</code>, <code>json</code> or <code>all</code>).\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"outputFormat\", defaultValue = \"all\", required = false)\n    private String outputFormat;\n\n    /**\n     * The CycloneDX output file name (without extension) that should be generated (in {@code outputDirectory} directory).\n     *\n     * @since 2.2.0\n     */\n    @Parameter(property = \"outputName\", defaultValue = \"bom\", required = false)\n    private String outputName;\n\n    /**\n     * The output directory where to store generated CycloneDX output files.\n     *\n     * @since 2.7.5\n     */\n    @Parameter(property = \"outputDirectory\", defaultValue = \"${project.build.directory}\", required = false)\n    private File outputDirectory;\n\n    /**\n     * Should the resulting BOM contain a unique serial number?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeBomSerialNumber\", defaultValue = \"true\", required = false)\n    private boolean includeBomSerialNumber;\n\n    /**\n     * Should compile scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeCompileScope\", defaultValue = \"true\", required = false)\n    private boolean includeCompileScope;\n\n    /**\n     * Should provided scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeProvidedScope\", defaultValue = \"true\", required = false)\n    private boolean includeProvidedScope;\n\n    /**\n     * Should runtime scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeRuntimeScope\", defaultValue = \"true\", required = false)\n    private boolean includeRuntimeScope;\n\n    /**\n     * Should test scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeTestScope\", defaultValue = \"false\", required = false)\n    private boolean includeTestScope;\n\n    /**\n     * Should system scoped Maven dependencies be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeSystemScope\", defaultValue = \"true\", required = false)\n    private boolean includeSystemScope;\n\n    /**\n     * Should license text be included in bom?\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"includeLicenseText\", defaultValue = \"false\", required = false)\n    private boolean includeLicenseText;\n\n    /**\n     * Excluded types.\n     *\n     * @since 2.1.0\n     */\n    @Parameter(property = \"excludeTypes\", required = false)\n    private String[] excludeTypes;\n\n    /**\n     * Use the original mechanism for determining whether a component has OPTIONAL or REQUIRED scope,\n     * relying on bytecode analysis of the compiled classes instead of the Maven dependency declaration of optional.\n     *\n     * @since 2.7.9\n     */\n    @Parameter(property = \"detectUnusedForOptionalScope\", defaultValue = \"false\")\n    protected boolean detectUnusedForOptionalScope;\n\n    /**\n     * Skip CycloneDX execution.\n     *\n     * @since 1.1.3\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.skip\", defaultValue = \"false\", required = false)\n    private boolean skip = false;\n\n    /**\n     * Don't attach bom.\n     *\n     * @since 2.1.0\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.skipAttach\", defaultValue = \"false\", required = false)\n    private boolean skipAttach = false;\n\n    /**\n     * Classifier of the attached sbom\n     *\n     * @since 2.8.1\n     */\n    @Parameter(property = \"cyclonedx.classifier\", defaultValue = \"cyclonedx\")\n    private String classifier;\n\n    /**\n     * Verbose output.\n     *\n     * @since 2.6.0\n     */\n    @SuppressWarnings(\"CanBeFinal\")\n    @Parameter(property = \"cyclonedx.verbose\", defaultValue = \"false\", required = false)\n    private boolean verbose = false;\n\n    /**\n     * Timestamp for reproducible output archive entries, either formatted as ISO 8601\n     * <code>yyyy-MM-dd'T'HH:mm:ssXXX</code> or as an int representing seconds since the epoch (like\n     * <a href=\"https://reproducible-builds.org/docs/source-date-epoch/\">SOURCE_DATE_EPOCH</a>).\n     *\n     * @since 2.7.9\n     */\n    @Parameter( defaultValue = \"${project.build.outputTimestamp}\" )\n    private String outputTimestamp;\n\n    /**\n     * <a href=\"https://cyclonedx.org/docs/1.5/json/#metadata_component_externalReferences_items_type\">External references</a>\n     * to be added to the component the BOM describes <code>$.metadata.component.externalReferences[]</code>:\n     * <pre>\n     * &lt;externalReferences&gt;\n     *   &lt;externalReference&gt;\n     *     &lt;type>EXTERNAL_REFERENCE_TYPE&lt;/type&gt;&lt;-- constant id corresponding to \"external-reference-type\" SBOM type --&gt;\n     *     &lt;url>https://...&lt;/url&gt;\n     *     &lt;comment>(optional) comment&lt;/comment&gt;\n     *   &lt;/externalReference&gt;\n     * &lt;/externalReferences&gt;\n     * </pre>\n     *\n     * @see <a href=\"https://cyclonedx.github.io/cyclonedx-core-java/org/cyclonedx/model/ExternalReference.Type.html\">ExternalReference.Type constants</a>\n     * @since 2.7.11\n     */\n    @Parameter\n    private ExternalReference[] externalReferences;\n\n    @org.apache.maven.plugins.annotations.Component\n    private MavenProjectHelper mavenProjectHelper;\n\n    @org.apache.maven.plugins.annotations.Component\n    private ModelConverter modelConverter;\n\n    @org.apache.maven.plugins.annotations.Component\n    private ProjectDependenciesConverter projectDependenciesConverter;\n\n    /**\n     * Various messages sent to console.\n     */\n    protected static final String MESSAGE_RESOLVING_DEPS = \"CycloneDX: Resolving Dependencies\";\n    protected static final String MESSAGE_RESOLVING_AGGREGATED_DEPS = \"CycloneDX: Resolving Aggregated Dependencies\";\n    protected static final String MESSAGE_CREATING_BOM = \"CycloneDX: Creating BOM version %s with %d component(s)\";\n    static final String MESSAGE_CALCULATING_HASHES = \"CycloneDX: Calculating Hashes\";\n    protected static final String MESSAGE_WRITING_BOM = \"CycloneDX: Writing and validating BOM (%s): %s\";\n    protected static final String MESSAGE_ATTACHING_BOM = \"           attaching as %s-%s-cyclonedx.%s\";\n    protected static final String MESSAGE_VALIDATION_FAILURE = \"The BOM does not conform to the CycloneDX BOM standard as defined by the XSD\";\n\n    /**\n     * Maven plugins that deploy artifacts.\n     */\n    private static final String MAVEN_DEPLOY_PLUGIN = \"org.apache.maven.plugins:maven-deploy-plugin\";\n    private static final String NEXUS_STAGING_PLUGIN = \"org.sonatype.plugins:nexus-staging-maven-plugin\";\n\n    /**\n     * Returns a reference to the current project.\n     *\n     * @return returns a reference to the current project\n     */\n    protected MavenProject getProject() {\n        return project;\n    }\n\n    protected String generatePackageUrl(final Artifact artifact) {\n        return modelConverter.generatePackageUrl(artifact);\n    }\n\n    protected Component convertMavenDependency(Artifact artifact) {\n        return modelConverter.convertMavenDependency(artifact, schemaVersion(), includeLicenseText);\n    }\n\n    /**\n     * Analyze the current Maven project to extract the BOM components list and their dependencies.\n     *\n     * @param topLevelComponents the PURLs for all top level components\n     * @param components the components map to fill\n     * @param dependencies the dependencies map to fill\n     * @return the name of the analysis done to store as a BOM, or {@code null} to not save result.\n     * @throws MojoExecutionException something weird happened...\n     */\n    protected abstract String extractComponentsAndDependencies(Set<String> topLevelComponents, Map<String, Component> components, Map<String, Dependency> dependencies) throws MojoExecutionException;\n\n    /**\n     * @return {@literal true} if the execution should be skipped.\n     */\n    protected boolean shouldSkip() {\n        return Boolean.parseBoolean(System.getProperty(\"cyclonedx.skip\", Boolean.toString(skip)));\n    }\n\n    protected String getSkipReason() {\n        return null;\n    }\n\n    public void execute() throws MojoExecutionException {\n        if (shouldSkip()) {\n            final String skipReason = getSkipReason();\n            if (skipReason != null) {\n                getLog().info(\"Skipping CycloneDX goal, because \" + skipReason);\n            } else {\n                getLog().info(\"Skipping CycloneDX goal\");\n            }\n            return;\n        }\n        if (!schemaVersion().getVersionString().equals(schemaVersion)) {\n            getLog().warn(\"Invalid schemaVersion configured '\" + schemaVersion +\"', using \" + effectiveSchemaVersion.getVersionString());\n            schemaVersion = effectiveSchemaVersion.getVersionString();\n        }\n        logParameters();\n\n        // top level components do not currently set their scope, we track these to prevent merging of scopes\n        final Set<String> topLevelComponents = new LinkedHashSet<>();\n        final Map<String, Component> componentMap = new LinkedHashMap<>();\n        final Map<String, Dependency> dependencyMap = new LinkedHashMap<>();\n\n        String analysis = extractComponentsAndDependencies(topLevelComponents, componentMap, dependencyMap);\n        if (analysis != null) {\n            final Metadata metadata = modelConverter.convertMavenProject(project, projectType, schemaVersion(), includeLicenseText, externalReferences);\n\n            if (schemaVersion().getVersion() >= 1.3) {\n                metadata.addProperty(newProperty(\"maven.goal\", analysis));\n\n                List<String> scopes = new ArrayList<>();\n                if (includeCompileScope) scopes.add(\"compile\");\n                if (includeProvidedScope) scopes.add(\"provided\");\n                if (includeRuntimeScope) scopes.add(\"runtime\");\n                if (includeSystemScope) scopes.add(\"system\");\n                if (includeTestScope) scopes.add(\"test\");\n                metadata.addProperty(newProperty(\"maven.scopes\", String.join(\",\", scopes)));\n\n                if (detectUnusedForOptionalScope) {\n                    metadata.addProperty(newProperty(\"maven.optional.unused\", Boolean.toString(detectUnusedForOptionalScope)));\n                }\n            }\n\n            final Component rootComponent = metadata.getComponent();\n            componentMap.remove(rootComponent.getPurl());\n\n            projectDependenciesConverter.cleanupBomDependencies(metadata, componentMap, dependencyMap);\n\n            generateBom(analysis, metadata, new ArrayList<>(componentMap.values()), new ArrayList<>(dependencyMap.values()));\n        }\n    }\n\n    private Property newProperty(String name, String value) {\n        Property property = new Property();\n        property.setName(name);\n        property.setValue(value);\n        return property;\n    }\n\n    private void generateBom(String analysis, Metadata metadata, List<Component> components, List<Dependency> dependencies) throws MojoExecutionException {\n        try {\n            getLog().info(String.format(MESSAGE_CREATING_BOM, schemaVersion, components.size()));\n            final Bom bom = new Bom();\n            bom.setComponents(components);\n\n            if (outputTimestamp != null) {\n                // activate Reproducible Builds mode\n                metadata.setTimestamp(null);\n                if (schemaVersion().getVersion() >= 1.3) {\n                    metadata.addProperty(newProperty(\"cdx:reproducible\", \"enabled\"));\n                }\n            }\n\n            if (schemaVersion().getVersion() >= 1.1 && includeBomSerialNumber) {\n                String serialNumber = generateSerialNumber(metadata.getProperties());\n                bom.setSerialNumber(serialNumber);\n            }\n\n            if (schemaVersion().getVersion() >= 1.2) {\n                bom.setMetadata(metadata);\n                bom.setDependencies(dependencies);\n            }\n\n            /*if (schemaVersion().getVersion() >= 1.3) {\n                if (excludeArtifactId != null && excludeTypes.length > 0) { // TODO\n                    final Composition composition = new Composition();\n                    composition.setAggregate(Composition.Aggregate.INCOMPLETE);\n                    composition.setDependencies(Collections.singletonList(new Dependency(bom.getMetadata().getComponent().getBomRef())));\n                    bom.setCompositions(Collections.singletonList(composition));\n                }\n            }*/\n\n            if (schemaVersion().getVersion() >= 1.5) {\n                LifecycleChoice build = new LifecycleChoice();\n                build.setPhase(LifecycleChoice.Phase.BUILD);\n                Lifecycles lifecycles = new Lifecycles();\n                lifecycles.setLifecycleChoice(Collections.singletonList(build));\n                metadata.setLifecycles(lifecycles);\n            }\n\n            if (\"all\".equalsIgnoreCase(outputFormat)\n                    || \"xml\".equalsIgnoreCase(outputFormat)\n                    || \"json\".equalsIgnoreCase(outputFormat)) {\n                saveBom(bom);\n            } else {\n                getLog().error(\"Unsupported output format. Valid options are XML and JSON\");\n            }\n        } catch (GeneratorException | ParserConfigurationException | IOException e) {\n            throw new MojoExecutionException(\"An error occurred executing \" + this.getClass().getName() + \": \" + e.getMessage(), e);\n        }\n    }\n\n    private String generateSerialNumber(List<Property> properties) {\n        String gav = String.format(\"%s:%s:%s\", project.getGroupId(), project.getArtifactId(), project.getVersion());\n        StringBuilder sb = new StringBuilder(gav);\n        if (properties != null) {\n            for(Property prop: properties) {\n                sb.append(';');\n                sb.append(prop.getName());\n                sb.append('=');\n                sb.append(prop.getValue());\n            }\n        }\n        UUID uuid = UUID.nameUUIDFromBytes(sb.toString().getBytes(StandardCharsets.UTF_8));\n        return String.format(\"urn:uuid:%s\", uuid);\n    }\n\n    private void saveBom(Bom bom) throws ParserConfigurationException, IOException, GeneratorException,\n            MojoExecutionException {\n        if (\"all\".equalsIgnoreCase(outputFormat) || \"xml\".equalsIgnoreCase(outputFormat)) {\n            final BomXmlGenerator bomGenerator = BomGeneratorFactory.createXml(schemaVersion(), bom);\n            //bomGenerator.generate();\n\n            final String bomString = bomGenerator.toXmlString();\n            saveBomToFile(bomString, \"xml\", new XmlParser());\n        }\n        if (\"all\".equalsIgnoreCase(outputFormat) || \"json\".equalsIgnoreCase(outputFormat)) {\n            final BomJsonGenerator bomGenerator = BomGeneratorFactory.createJson(schemaVersion(), bom);\n\n            final String bomString = bomGenerator.toJsonString();\n            saveBomToFile(bomString, \"json\", new JsonParser());\n        }\n    }\n\n    private void saveBomToFile(String bomString, String extension, Parser bomParser) throws IOException, MojoExecutionException {\n        final File bomFile = new File(outputDirectory, outputName + \".\" + extension);\n\n        getLog().info(String.format(MESSAGE_WRITING_BOM, extension.toUpperCase(), bomFile.getAbsolutePath()));\n        FileUtils.write(bomFile, bomString, StandardCharsets.UTF_8, false);\n\n        if (!bomParser.isValid(bomFile, schemaVersion())) {\n            throw new MojoExecutionException(MESSAGE_VALIDATION_FAILURE);\n        }\n\n        if (!skipAttach) {\n            getLog().info(String.format(MESSAGE_ATTACHING_BOM, project.getArtifactId(), project.getVersion(), extension));\n            mavenProjectHelper.attachArtifact(project, extension, classifier, bomFile);\n        }\n    }\n\n    protected BomDependencies extractBOMDependencies(MavenProject mavenProject) throws MojoExecutionException {\n        ProjectDependenciesConverter.MavenDependencyScopes include = new ProjectDependenciesConverter.MavenDependencyScopes(includeCompileScope, includeProvidedScope, includeRuntimeScope, includeTestScope, includeSystemScope);\n        return projectDependenciesConverter.extractBOMDependencies(mavenProject, include, excludeTypes);\n    }\n\n    /**\n     * Resolves the CycloneDX schema the mojo has been requested to use.\n     * @return the CycloneDX schema to use\n     */\n    protected CycloneDxSchema.Version schemaVersion() {\n        if (effectiveSchemaVersion == null) {\n            if (\"1.0\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_10;\n            } else if (\"1.1\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_11;\n            } else if (\"1.2\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_12;\n            } else if (\"1.3\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_13;\n            } else if (\"1.4\".equals(schemaVersion)) {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_14;\n            } else {\n                effectiveSchemaVersion = CycloneDxSchema.Version.VERSION_15;\n            }\n        }\n        return effectiveSchemaVersion;\n    }\n\n    protected void logAdditionalParameters() {\n        // no additional parameters\n    }\n\n    protected void logParameters() {\n        if (verbose && getLog().isInfoEnabled()) {\n            getLog().info(\"CycloneDX: Parameters\");\n            getLog().info(\"------------------------------------------------------------------------\");\n            getLog().info(\"schemaVersion          : \" + schemaVersion().getVersionString());\n            getLog().info(\"includeBomSerialNumber : \" + includeBomSerialNumber);\n            getLog().info(\"includeCompileScope    : \" + includeCompileScope);\n            getLog().info(\"includeProvidedScope   : \" + includeProvidedScope);\n            getLog().info(\"includeRuntimeScope    : \" + includeRuntimeScope);\n            getLog().info(\"includeTestScope       : \" + includeTestScope);\n            getLog().info(\"includeSystemScope     : \" + includeSystemScope);\n            getLog().info(\"includeLicenseText     : \" + includeLicenseText);\n            getLog().info(\"outputFormat           : \" + outputFormat);\n            getLog().info(\"outputName             : \" + outputName);\n            logAdditionalParameters();\n            getLog().info(\"------------------------------------------------------------------------\");\n        }\n    }\n\n    protected void populateComponents(final Set<String> topLevelComponents, final Map<String, Component> components, final Map<String, Artifact> artifacts, final ProjectDependencyAnalysis dependencyAnalysis) {\n        for (Map.Entry<String, Artifact> entry: artifacts.entrySet()) {\n            final String purl = entry.getKey();\n            final Artifact artifact = entry.getValue();\n            final Component.Scope artifactScope = getComponentScope(artifact, dependencyAnalysis);\n            final Component component = components.get(purl);\n            if (component == null) {\n                final Component newComponent = convertMavenDependency(artifact);\n                newComponent.setScope(artifactScope);\n                components.put(purl, newComponent);\n            } else if (!topLevelComponents.contains(purl)) {\n                component.setScope(mergeScopes(component.getScope(), artifactScope));\n            }\n        }\n    }\n\n    /**\n     * Get the BOM component scope (required/optional/excluded).  The scope can either be determined through bytecode\n     * analysis or through maven dependency resolution.\n     *\n     * @param artifact Artifact from maven project\n     * @param projectDependencyAnalysis Maven Project Dependency Analysis data\n     *\n     * @return Component.Scope - REQUIRED, OPTIONAL or null if it cannot be determined\n     *\n     * @see #detectUnusedForOptionalScope\n     */\n    private Component.Scope getComponentScope(Artifact artifact, ProjectDependencyAnalysis projectDependencyAnalysis) {\n        if (detectUnusedForOptionalScope) {\n            return inferComponentScope(artifact, projectDependencyAnalysis);\n        } else {\n            return (artifact.isOptional() ? Component.Scope.OPTIONAL : Component.Scope.REQUIRED);\n        }\n    }\n\n    /**\n     * Infer BOM component scope (required/optional/excluded) based on Maven project dependency analysis.\n     *\n     * @param artifact Artifact from maven project\n     * @param projectDependencyAnalysis Maven Project Dependency Analysis data\n     *\n     * @return Component.Scope - REQUIRED: If the component is used (as detected by project dependency analysis). OPTIONAL: If it is unused\n     */\n    private Component.Scope inferComponentScope(Artifact artifact, ProjectDependencyAnalysis projectDependencyAnalysis) {\n        if (projectDependencyAnalysis == null) {\n            return null;\n        }\n\n        Set<Artifact> usedDeclaredArtifacts = projectDependencyAnalysis.getUsedDeclaredArtifacts();\n        Set<Artifact> usedUndeclaredArtifacts = projectDependencyAnalysis.getUsedUndeclaredArtifacts();\n        Set<Artifact> unusedDeclaredArtifacts = projectDependencyAnalysis.getUnusedDeclaredArtifacts();\n        Set<Artifact> testArtifactsWithNonTestScope = projectDependencyAnalysis.getTestArtifactsWithNonTestScope();\n\n        // Is the artifact used?\n        if (usedDeclaredArtifacts.contains(artifact) || usedUndeclaredArtifacts.contains(artifact)) {\n            return Component.Scope.REQUIRED;\n        }\n\n        // Is the artifact unused or test?\n        if (unusedDeclaredArtifacts.contains(artifact) || testArtifactsWithNonTestScope.contains(artifact)) {\n            return Component.Scope.OPTIONAL;\n        }\n\n        return null;\n    }\n\n    // Merging of scopes follows the method previously implemented in the aggregate code.  This needs to be fixed in a future PR.\n    private Component.Scope mergeScopes(final Component.Scope existing, final Component.Scope project) {\n        if ((Component.Scope.REQUIRED == existing) || (Component.Scope.REQUIRED == project)) {\n            return Component.Scope.REQUIRED;\n        }\n        if (null == existing) {\n            return project;\n        }\n        return existing;\n    }\n\n    static boolean isDeployable(final MavenProject project) {\n        return isDeployable(project,\n                        MAVEN_DEPLOY_PLUGIN,\n                        \"skip\",\n                        \"maven.deploy.skip\")\n                || isDeployable(project,\n                        NEXUS_STAGING_PLUGIN,\n                        \"skipNexusStagingDeployMojo\",\n                        \"skipNexusStagingDeployMojo\");\n    }\n\n    private static boolean isDeployable(final MavenProject project,\n                                        final String pluginKey,\n                                        final String parameter,\n                                        final String propertyName) {\n        final Plugin plugin = project.getPlugin(pluginKey);\n        if (plugin != null) {\n            // Default skip value\n            final String property = System.getProperty(propertyName, project.getProperties().getProperty(propertyName));\n            final boolean defaultSkipValue = property != null ? Boolean.parseBoolean(property) : false;\n            // Find an execution that is not skipped\n            for (final PluginExecution execution : plugin.getExecutions()) {\n                if (execution.getGoals().contains(\"deploy\")) {\n                    final Xpp3Dom executionConf = (Xpp3Dom) execution.getConfiguration();\n                    boolean skipValue = defaultSkipValue;\n                    if (executionConf != null) {\n                        Xpp3Dom target = executionConf.getChild(parameter);\n                        if (target != null) {\n                            skipValue = Boolean.parseBoolean(target.getValue());\n                        }\n                    }\n                    if (!skipValue) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}\n",
    "project": "cyclonedx-maven-plugin",
    "libraryName": "cyclonedx-core-java",
    "libraryGroupID": "org.cyclonedx",
    "newVersion": "9.0.2",
    "previousVersion": "8.0.3",
    "breakingCommit": "465aedb044d437742bb8e27a9f39f270f8a8982f"
}