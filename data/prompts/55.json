{
    "relative_path": "nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java",
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nthe following client code fails: \n'''java\npackage org.nem.specific.deploy.appconfig;\n\nimport org.flywaydb.core.Flyway;\nimport org.hibernate.SessionFactory;\nimport org.nem.core.model.*;\nimport org.nem.core.model.primitive.*;\nimport org.nem.core.node.NodeFeature;\nimport org.nem.core.time.TimeProvider;\nimport org.nem.deploy.*;\nimport org.nem.nis.*;\nimport org.nem.nis.audit.AuditCollection;\nimport org.nem.nis.boot.*;\nimport org.nem.nis.cache.*;\nimport org.nem.nis.connect.*;\nimport org.nem.nis.controller.interceptors.LocalHostDetector;\nimport org.nem.nis.dao.*;\nimport org.nem.nis.harvesting.*;\nimport org.nem.nis.mappers.*;\nimport org.nem.nis.pox.ImportanceCalculator;\nimport org.nem.nis.pox.poi.*;\nimport org.nem.nis.pox.pos.PosImportanceCalculator;\nimport org.nem.nis.secret.*;\nimport org.nem.nis.service.BlockChainLastBlockLayer;\nimport org.nem.nis.state.*;\nimport org.nem.nis.sync.*;\nimport org.nem.nis.validators.*;\nimport org.nem.peer.connect.CommunicationMode;\nimport org.nem.peer.node.*;\nimport org.nem.peer.services.ChainServices;\nimport org.nem.peer.trust.*;\nimport org.nem.specific.deploy.*;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.*;\nimport org.springframework.jdbc.datasource.DriverManagerDataSource;\nimport org.springframework.orm.hibernate4.HibernateTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\n\nimport javax.sql.DataSource;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.function.*;\n\n@Configuration\n@ComponentScan(basePackages = {\n\t\t\"org.nem.nis\"\n}, excludeFilters = {\n\t\t@ComponentScan.Filter(type = FilterType.ANNOTATION, value = org.springframework.stereotype.Controller.class),\n\t\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = {\n\t\t\t\t\"org.nem.nis.websocket.*\"\n\t\t})\n})\n@EnableTransactionManagement\npublic class NisAppConfig {\n\n\t@Autowired\n\tprivate AccountDao accountDao;\n\n\t@Autowired\n\tprivate BlockDao blockDao;\n\n\t@Autowired\n\tprivate BlockChainLastBlockLayer blockChainLastBlockLayer;\n\n\t@Autowired\n\t@SuppressWarnings(\"unused\")\n\tprivate TransferDao transferDao;\n\n\tprivate static final int MAX_AUDIT_HISTORY_SIZE = 50;\n\n\t@Bean\n\tprotected AuditCollection outgoingAudits() {\n\t\treturn this.createAuditCollection();\n\t}\n\n\t@Bean\n\tprotected AuditCollection incomingAudits() {\n\t\treturn this.createAuditCollection();\n\t}\n\n\tprivate AuditCollection createAuditCollection() {\n\t\treturn new AuditCollection(MAX_AUDIT_HISTORY_SIZE, this.timeProvider());\n\t}\n\n\t@Bean\n\tpublic DataSource dataSource() throws IOException {\n\t\tfinal NisConfiguration configuration = this.nisConfiguration();\n\t\tfinal String nemFolder = configuration.getNemFolder();\n\t\tfinal Properties prop = new Properties();\n\t\tprop.load(NisAppConfig.class.getClassLoader().getResourceAsStream(\"db.properties\"));\n\n\t\t// replace url parameters with values from configuration\n\t\tfinal String jdbcUrl = prop.getProperty(\"jdbc.url\").replace(\"${nem.folder}\", nemFolder).replace(\"${nem.network}\",\n\t\t\t\tconfiguration.getNetworkName());\n\n\t\tfinal DriverManagerDataSource dataSource = new DriverManagerDataSource();\n\t\tdataSource.setDriverClassName(prop.getProperty(\"jdbc.driverClassName\"));\n\t\tdataSource.setUrl(jdbcUrl);\n\t\tdataSource.setUsername(prop.getProperty(\"jdbc.username\"));\n\t\tdataSource.setPassword(prop.getProperty(\"jdbc.password\"));\n\t\treturn dataSource;\n\t}\n\n\t@Bean(initMethod = \"migrate\")\n\tpublic Flyway flyway() throws IOException {\n\t\tfinal Properties prop = new Properties();\n\t\tprop.load(NisAppConfig.class.getClassLoader().getResourceAsStream(\"db.properties\"));\n\n\t\tfinal org.flywaydb.core.Flyway flyway = new Flyway();\n\t\tflyway.setDataSource(this.dataSource());\n\t\tflyway.setClassLoader(NisAppConfig.class.getClassLoader());\n\t\tflyway.setLocations(prop.getProperty(\"flyway.locations\"));\n\t\tflyway.setValidateOnMigrate(Boolean.valueOf(prop.getProperty(\"flyway.validate\")));\n\t\treturn flyway;\n\t}\n\n\t@Bean\n\t@DependsOn(\"flyway\")\n\tpublic SessionFactory sessionFactory() throws IOException {\n\t\treturn SessionFactoryLoader.load(this.dataSource());\n\t}\n\n\t@Bean\n\tpublic BlockChain blockChain() {\n\t\treturn new BlockChain(this.blockChainLastBlockLayer, this.blockChainUpdater());\n\t}\n\n\t@Bean\n\tpublic BlockChainServices blockChainServices() {\n\t\treturn new BlockChainServices(this.blockDao, this.blockTransactionObserverFactory(), this.blockValidatorFactory(),\n\t\t\t\tthis.transactionValidatorFactory(), this.nisMapperFactory(), this.nisConfiguration().getForkConfiguration());\n\t}\n\n\t@Bean\n\tpublic BlockChainUpdater blockChainUpdater() {\n\t\treturn new BlockChainUpdater(this.nisCache(), this.blockChainLastBlockLayer, this.blockDao, this.blockChainContextFactory(),\n\t\t\t\tthis.unconfirmedTransactions(), this.nisConfiguration());\n\t}\n\n\t@Bean\n\tpublic BlockChainContextFactory blockChainContextFactory() {\n\t\treturn new BlockChainContextFactory(this.nisCache(), this.blockChainLastBlockLayer, this.blockDao, this.blockChainServices(),\n\t\t\t\tthis.unconfirmedTransactions());\n\t}\n\n\t// region mappers\n\n\t@Bean\n\tpublic MapperFactory mapperFactory() {\n\t\treturn new DefaultMapperFactory(this.mosaicIdCache());\n\t}\n\n\t@Bean\n\tpublic NisMapperFactory nisMapperFactory() {\n\t\treturn new NisMapperFactory(this.mapperFactory());\n\t}\n\n\t@Bean\n\tpublic NisModelToDbModelMapper nisModelToDbModelMapper() {\n\t\treturn new NisModelToDbModelMapper(this.mapperFactory().createModelToDbModelMapper(new AccountDaoLookupAdapter(this.accountDao)));\n\t}\n\n\t@Bean\n\tpublic NisDbModelToModelMapper nisDbModelToModelMapper() {\n\t\treturn this.nisMapperFactory().createDbModelToModelNisMapper(this.accountCache());\n\t}\n\n\t// endregion\n\n\t// region observers + validators\n\n\t@Bean\n\tpublic BlockTransactionObserverFactory blockTransactionObserverFactory() {\n\t\tfinal int estimatedBlocksPerYear = this.nisConfiguration().getBlockChainConfiguration().getEstimatedBlocksPerYear();\n\t\tfinal ForkConfiguration forkConfiguration = this.nisConfiguration().getForkConfiguration();\n\t\treturn new BlockTransactionObserverFactory(this.observerOptions(), estimatedBlocksPerYear, forkConfiguration);\n\t}\n\n\t@Bean\n\tpublic BlockValidatorFactory blockValidatorFactory() {\n\t\treturn new BlockValidatorFactory(this.timeProvider(), this.nisConfiguration().getForkConfiguration());\n\t}\n\n\t@Bean\n\tpublic TransactionValidatorFactory transactionValidatorFactory() {\n\t\treturn new TransactionValidatorFactory(this.timeProvider(), this.nisConfiguration().getNetworkInfo(),\n\t\t\t\tthis.nisConfiguration().getForkConfiguration(), this.nisConfiguration().ignoreFees());\n\t}\n\n\t@Bean\n\tpublic SingleTransactionValidator transactionValidator() {\n\t\t// this is only consumed by the TransactionController and used in transaction/prepare,\n\t\t// which should propagate incomplete transactions\n\t\treturn this.transactionValidatorFactory().createIncompleteSingleBuilder(this.nisCache()).build();\n\t}\n\n\t// endregion\n\n\t@Bean\n\tpublic Harvester harvester() {\n\t\tfinal NewBlockTransactionsProvider transactionsProvider = new DefaultNewBlockTransactionsProvider(this.nisCache(),\n\t\t\t\tthis.transactionValidatorFactory(), this.blockValidatorFactory(), this.blockTransactionObserverFactory(),\n\t\t\t\tthis.unconfirmedTransactionsFilter(), this.nisConfiguration().getForkConfiguration());\n\n\t\tfinal BlockGenerator generator = new BlockGenerator(this.nisCache(), transactionsProvider, this.blockDao,\n\t\t\t\tnew BlockScorer(this.accountStateCache()), this.blockValidatorFactory().create(this.nisCache()));\n\t\treturn new Harvester(this.timeProvider(), this.blockChainLastBlockLayer, this.unlockedAccounts(), this.nisDbModelToModelMapper(),\n\t\t\t\tgenerator);\n\t}\n\n\t@Bean\n\tpublic SynchronizedAccountCache accountCache() {\n\t\treturn new SynchronizedAccountCache(new DefaultAccountCache());\n\t}\n\n\t@Bean\n\tpublic SynchronizedAccountStateCache accountStateCache() {\n\t\treturn new SynchronizedAccountStateCache(new DefaultAccountStateCache());\n\t}\n\n\t@Bean\n\tpublic SynchronizedHashCache transactionHashCache() {\n\t\treturn new SynchronizedHashCache(new DefaultHashCache(50000, this.nisConfiguration().getTransactionHashRetentionTime()));\n\t}\n\n\t@Bean\n\tpublic SynchronizedPoxFacade poxFacade() {\n\t\treturn new SynchronizedPoxFacade(new DefaultPoxFacade(this.importanceCalculator()));\n\t}\n\n\t@Bean\n\tpublic SynchronizedNamespaceCache namespaceCache() {\n\t\tfinal BlockHeight mosaicRedefinitionForkHeight = this.nisConfiguration().getForkConfiguration().getMosaicRedefinitionForkHeight();\n\n\t\tNemNamespaceEntry.setDefault(mosaicRedefinitionForkHeight);\n\t\treturn new SynchronizedNamespaceCache(new DefaultNamespaceCache(mosaicRedefinitionForkHeight));\n\t}\n\n\t@Bean\n\tpublic ReadOnlyNisCache nisCache() {\n\t\treturn new DefaultNisCache(this.accountCache(), this.accountStateCache(), this.poxFacade(), this.transactionHashCache(),\n\t\t\t\tthis.namespaceCache());\n\t}\n\n\t@Bean\n\t@SuppressWarnings(\"serial\")\n\tpublic ImportanceCalculator importanceCalculator() {\n\t\tfinal Map<BlockChainFeature, Supplier<ImportanceCalculator>> featureSupplierMap = new HashMap<BlockChainFeature, Supplier<ImportanceCalculator>>() {\n\t\t\t{\n\t\t\t\tthis.put(BlockChainFeature.PROOF_OF_IMPORTANCE,\n\t\t\t\t\t\t() -> new PoiImportanceCalculator(new PoiScorer(), NisAppConfig::getBlockDependentPoiOptions));\n\t\t\t\tthis.put(BlockChainFeature.PROOF_OF_STAKE, PosImportanceCalculator::new);\n\t\t\t}\n\t\t};\n\n\t\treturn BlockChainFeatureDependentFactory.createObject(this.nisConfiguration().getBlockChainConfiguration(), \"consensus algorithm\",\n\t\t\t\tfeatureSupplierMap);\n\t}\n\n\t@Bean\n\tpublic UnlockedAccounts unlockedAccounts() {\n\t\treturn new UnlockedAccounts(this.accountCache(), this.accountStateCache(), this.blockChainLastBlockLayer,\n\t\t\t\tthis.canHarvestPredicate(), this.nisConfiguration().getUnlockedLimit());\n\t}\n\n\t@Bean\n\tpublic CanHarvestPredicate canHarvestPredicate() {\n\t\treturn new CanHarvestPredicate(this::getBlockDependentMinHarvesterBalance);\n\t}\n\n\tprivate Amount getBlockDependentMinHarvesterBalance(final BlockHeight height) {\n\t\treturn getBlockDependentPoiOptions(height).getMinHarvesterBalance();\n\t}\n\n\tprivate static org.nem.nis.pox.poi.PoiOptions getBlockDependentPoiOptions(final BlockHeight height) {\n\t\treturn new PoiOptionsBuilder(height).create();\n\t}\n\n\t@Bean\n\tpublic Supplier<BlockHeight> lastBlockHeight() {\n\t\treturn this.blockChainLastBlockLayer::getLastBlockHeight;\n\t}\n\n\t@Bean\n\tpublic UnconfirmedTransactions unconfirmedTransactions() {\n\t\tfinal BlockChainConfiguration blockChainConfiguration = this.nisConfiguration().getBlockChainConfiguration();\n\t\tfinal UnconfirmedStateFactory unconfirmedStateFactory = new UnconfirmedStateFactory(this.transactionValidatorFactory(),\n\t\t\t\tthis.blockTransactionObserverFactory()::createExecuteCommitObserver, this.timeProvider(), this.lastBlockHeight(),\n\t\t\t\tblockChainConfiguration.getMaxTransactionsPerBlock(), this.nisConfiguration().getForkConfiguration());\n\t\tfinal UnconfirmedTransactions unconfirmedTransactions = new DefaultUnconfirmedTransactions(unconfirmedStateFactory,\n\t\t\t\tthis.nisCache());\n\t\treturn new SynchronizedUnconfirmedTransactions(unconfirmedTransactions);\n\t}\n\n\t@Bean\n\tpublic UnconfirmedTransactionsFilter unconfirmedTransactionsFilter() {\n\t\treturn this.unconfirmedTransactions().asFilter();\n\t}\n\n\t@Bean\n\tpublic HibernateTransactionManager transactionManager() throws IOException {\n\t\treturn new HibernateTransactionManager(this.sessionFactory());\n\t}\n\n\t@Bean\n\tpublic NisMain nisMain() {\n\t\tfinal NisConfiguration nisConfiguration = this.nisConfiguration();\n\n\t\t// initialize network info\n\t\tNetworkInfos.setDefault(nisConfiguration.getNetworkInfo());\n\n\t\t// initialize other globals\n\t\tfinal NamespaceCacheLookupAdapters adapters = new NamespaceCacheLookupAdapters(this.namespaceCache());\n\t\tif (nisConfiguration.ignoreFees()) {\n\t\t\tNemGlobals.setTransactionFeeCalculator(new ZeroTransactionFeeCalculator());\n\t\t} else {\n\t\t\tNemGlobals.setTransactionFeeCalculator(new DefaultTransactionFeeCalculator(adapters.asMosaicFeeInformationLookup(),\n\t\t\t\t\t() -> this.blockChainLastBlockLayer.getLastBlockHeight().next(), new BlockHeight[]{\n\t\t\t\t\t\t\tnisConfiguration.getForkConfiguration().getFeeFork().getFirstHeight(),\n\t\t\t\t\t\t\tnisConfiguration.getForkConfiguration().getFeeFork().getSecondHeight()\n\t\t\t\t\t}));\n\t\t}\n\n\t\tNemGlobals.setBlockChainConfiguration(nisConfiguration.getBlockChainConfiguration());\n\t\tNemStateGlobals.setWeightedBalancesSupplier(this.weighedBalancesSupplier());\n\n\t\treturn new NisMain(this.blockDao, this.nisCache(), this.networkHostBootstrapper(), this.nisModelToDbModelMapper(), nisConfiguration,\n\t\t\t\tthis.blockAnalyzer(), System::exit);\n\t}\n\n\t@SuppressWarnings(\"serial\")\n\tprivate Supplier<WeightedBalances> weighedBalancesSupplier() {\n\t\tfinal Map<BlockChainFeature, Supplier<Supplier<WeightedBalances>>> featureSupplierMap = new HashMap<BlockChainFeature, Supplier<Supplier<WeightedBalances>>>() {\n\t\t\t{\n\t\t\t\tthis.put(BlockChainFeature.WB_TIME_BASED_VESTING, () -> TimeBasedVestingWeightedBalances::new);\n\t\t\t\tthis.put(BlockChainFeature.WB_IMMEDIATE_VESTING, () -> AlwaysVestedBalances::new);\n\t\t\t}\n\t\t};\n\n\t\treturn BlockChainFeatureDependentFactory.createObject(this.nisConfiguration().getBlockChainConfiguration(),\n\t\t\t\t\"weighted balance scheme\", featureSupplierMap);\n\t}\n\n\t@Bean\n\tpublic BlockAnalyzer blockAnalyzer() {\n\t\tfinal int estimatedBlocksPerYear = this.nisConfiguration().getBlockChainConfiguration().getEstimatedBlocksPerYear();\n\t\tfinal ForkConfiguration forkConfiguration = this.nisConfiguration().getForkConfiguration();\n\t\treturn new BlockAnalyzer(this.blockDao, this.blockChainUpdater(), this.blockChainLastBlockLayer, this.nisMapperFactory(),\n\t\t\t\testimatedBlocksPerYear, forkConfiguration);\n\t}\n\n\t@Bean\n\tpublic HttpConnectorPool httpConnectorPool() {\n\t\tfinal CommunicationMode communicationMode = this.nisConfiguration().useBinaryTransport()\n\t\t\t\t? CommunicationMode.BINARY\n\t\t\t\t: CommunicationMode.JSON;\n\t\treturn new HttpConnectorPool(communicationMode, this.outgoingAudits());\n\t}\n\n\t@Bean\n\tpublic NisPeerNetworkHost nisPeerNetworkHost() {\n\t\tfinal HarvestingTask harvestingTask = new HarvestingTask(this.blockChain(), this.harvester(), this.unconfirmedTransactions());\n\n\t\tfinal PeerNetworkScheduler scheduler = new PeerNetworkScheduler(this.timeProvider(), harvestingTask);\n\n\t\tfinal CountingBlockSynchronizer synchronizer = new CountingBlockSynchronizer(this.blockChain());\n\n\t\treturn new NisPeerNetworkHost(this.nisCache(), synchronizer, scheduler, this.chainServices(), this.nodeCompatibilityChecker(),\n\t\t\t\tthis.nisConfiguration(), this.httpConnectorPool(), this.trustProvider(), this.incomingAudits(), this.outgoingAudits());\n\t}\n\n\t@Bean\n\tpublic NetworkHostBootstrapper networkHostBootstrapper() {\n\t\treturn new HarvestAwareNetworkHostBootstrapper(this.nisPeerNetworkHost(), this.unlockedAccounts(), this.nisConfiguration());\n\t}\n\n\t@Bean\n\tpublic NisConfiguration nisConfiguration() {\n\t\treturn new NisConfiguration();\n\t}\n\n\t@Bean\n\tpublic TimeProvider timeProvider() {\n\t\treturn CommonStarter.TIME_PROVIDER;\n\t}\n\n\t@Bean\n\tpublic TrustProvider trustProvider() {\n\t\tfinal int LOW_COMMUNICATION_NODE_WEIGHT = 30;\n\t\tfinal int TRUST_CACHE_TIME = 15 * 60;\n\t\treturn new CachedTrustProvider(new LowComTrustProvider(new EigenTrustPlusPlus(), LOW_COMMUNICATION_NODE_WEIGHT), TRUST_CACHE_TIME,\n\t\t\t\tthis.timeProvider());\n\t}\n\n\t@Bean\n\tpublic NemConfigurationPolicy configurationPolicy() {\n\t\treturn new NisConfigurationPolicy();\n\t}\n\n\t@Bean\n\tpublic ChainServices chainServices() {\n\t\treturn new DefaultChainServices(this.blockChainLastBlockLayer, this.httpConnectorPool());\n\t}\n\n\t@Bean\n\tpublic CommonStarter commonStarter() {\n\t\treturn CommonStarter.INSTANCE;\n\t}\n\n\t@Bean\n\tpublic ValidationState validationState() {\n\t\treturn NisCacheUtils.createValidationState(this.nisCache());\n\t}\n\n\t@Bean\n\tpublic LocalHostDetector localHostDetector() {\n\t\treturn new LocalHostDetector(this.nisConfiguration().getAdditionalLocalIps());\n\t}\n\n\t@Bean\n\tpublic NodeCompatibilityChecker nodeCompatibilityChecker() {\n\t\treturn new DefaultNodeCompatibilityChecker();\n\t}\n\n\t@Bean\n\tpublic EnumSet<ObserverOption> observerOptions() {\n\t\tfinal EnumSet<ObserverOption> observerOptions = EnumSet.noneOf(ObserverOption.class);\n\t\tif (this.nisConfiguration().isFeatureSupported(NodeFeature.HISTORICAL_ACCOUNT_DATA)) {\n\t\t\tobserverOptions.add(ObserverOption.NoHistoricalDataPruning);\n\t\t}\n\n\t\tfinal BlockChainConfiguration blockChainConfiguration = this.nisConfiguration().getBlockChainConfiguration();\n\t\tif (blockChainConfiguration.isBlockChainFeatureSupported(BlockChainFeature.PROOF_OF_STAKE)) {\n\t\t\tobserverOptions.add(ObserverOption.NoOutlinkObserver);\n\t\t}\n\n\t\treturn observerOptions;\n\t}\n\n\t@Bean\n\tpublic Function<Address, Collection<Address>> cosignatoryLookup() {\n\t\treturn a -> this.accountStateCache().findStateByAddress(a).getMultisigLinks().getCosignatories();\n\t}\n\n\t@Bean\n\tpublic MosaicIdCache mosaicIdCache() {\n\t\treturn new SynchronizedMosaicIdCache(new DefaultMosaicIdCache());\n\t}\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n\nwith the following error message:\n[ERROR] /nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java:[108,57] constructor Flyway in class org.flywaydb.core.Flyway cannot be applied to given types;  required: org.flywaydb.core.api.configuration.Configuration\n  found: no arguments\n  reason: actual and formal argument lists differ in length\n[ERROR] /nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java:[109,23] cannot find symbol  symbol:   method setDataSource(javax.sql.DataSource)\n  location: variable flyway of type org.flywaydb.core.Flyway\n[ERROR] /nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java:[110,23] cannot find symbol  symbol:   method setClassLoader(java.lang.ClassLoader)\n  location: variable flyway of type org.flywaydb.core.Flyway\n[ERROR] /nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java:[111,23] cannot find symbol  symbol:   method setLocations(java.lang.String)\n  location: variable flyway of type org.flywaydb.core.Flyway\n[ERROR] /nem/nis/src/main/java/org/nem/specific/deploy/appconfig/NisAppConfig.java:[112,23] cannot find symbol  symbol:   method setValidateOnMigrate(java.lang.Boolean)\n  location: variable flyway of type org.flywaydb.core.Flyway\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.flywaydb.core.Flyway.setEncoding | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getSqlMigrationSeparator | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getClassLoader | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.baseline | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.flywaydb.core.Flyway.setValidateOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.isPlaceholderReplacement | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.clean | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.flywaydb.core.Flyway.setOutOfOrder | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setResolversAsClassNames | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setLocations | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setTable | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setPlaceholderPrefix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setResolvers | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getSqlMigrationSuffix | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.resolver.CompositeMigrationResolver.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.internal.resolver.ResolvedMigrationImpl.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getDataSource | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.configure | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setInitOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setSqlMigrationSuffix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.isIgnoreFailedFutureMigration | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setInitVersion | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.setClassLoader | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.info.MigrationInfoImpl.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.setBaselineOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setPlaceholderReplacement | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setBaselineDescription | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.init | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getInitDescription | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.command.DbMigrate.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.isValidateOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getPlaceholders | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setCleanOnValidationError | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setIgnoreFailedFutureMigration | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.resolver.sql.SqlMigrationResolver.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getTable | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setTarget | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.isCleanOnValidationError | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.command.DbRepair.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getTarget | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setInitDescription | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setCallbacks | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getPlaceholderPrefix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setBaselineVersion | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.isBaselineOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.repair | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.flywaydb.core.Flyway.getBaselineVersion | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.migrate | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.flywaydb.core.internal.command.DbValidate.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.isOutOfOrder | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getBaselineDescription | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getCallbacks | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setDataSource | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getSqlMigrationPrefix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setCallbacksAsClassNames | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.info.MigrationInfoServiceImpl.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.setSchemas | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setBaselineVersionAsString | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.resolver.sql.SqlMigrationExecutor.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getEncoding | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getResolvers | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.isInitOnMigrate | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.command.DbBaseline.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.setTargetAsString | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setSqlMigrationSeparator | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.command.DbSchemas.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getLocations | DELETION | METHOD_REMOVED\norg.flywaydb.core.internal.util.Pair.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.flywaydb.core.Flyway.getSchemas | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setPlaceholders | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setSqlMigrationPrefix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.setPlaceholderSuffix | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getInitVersion | DELETION | METHOD_REMOVED\norg.flywaydb.core.Flyway.getPlaceholderSuffix | DELETION | METHOD_REMOVED\nBefore proposing a fix, please analyze the situation and plan your approach within\n<repair strategy> tags:\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "project": "nem",
    "libraryName": "flyway-core",
    "libraryGroupID": "org.flywaydb",
    "newVersion": "9.21.1",
    "previousVersion": "3.2.1"
}