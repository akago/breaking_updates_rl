{
    "absolute_path_to_file_in_container": "/openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java",
    "errors": [
        {
            "line_number": 18,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[18,26] cannot find symbol",
            "additional_info": "  symbol:   class Cluster\n  location: package com.hazelcast.core",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "66407460-9a95-5765-adbc-5f9ab88df5d9"
        },
        {
            "line_number": 23,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[23,26] cannot find symbol",
            "additional_info": "  symbol:   class Member\n  location: package com.hazelcast.core",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "dfac0bdc-079f-55d7-8b7b-ddf27de2882b"
        },
        {
            "line_number": 24,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[24,26] cannot find symbol",
            "additional_info": "  symbol:   class MemberAttributeEvent\n  location: package com.hazelcast.core",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MemberAttributeEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "0853396f-0aee-52c3-b957-1a6305e5cb6a"
        },
        {
            "line_number": 25,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[25,26] cannot find symbol",
            "additional_info": "  symbol:   class MembershipEvent\n  location: package com.hazelcast.core",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MembershipEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)"
            ],
            "uid": "9bb82334-cff0-59d7-89fb-0c7d39c576e7"
        },
        {
            "line_number": 26,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[26,26] cannot find symbol",
            "additional_info": "  symbol:   class MembershipListener\n  location: package com.hazelcast.core",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.MembershipListener",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.MembershipListener",
                "++ public abstract interface null com.hazelcast.cluster.MembershipListener"
            ],
            "uid": "daa0b553-9d23-55c7-a4f3-39b5bc47e2b7"
        },
        {
            "line_number": 52,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[52,41] cannot find symbol",
            "additional_info": "  symbol: class MembershipListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.MembershipListener",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.MembershipListener",
                "++ public abstract interface null com.hazelcast.cluster.MembershipListener"
            ],
            "uid": "5d0efe94-b03b-52a6-b8c8-bd082b6a0b5a"
        },
        {
            "line_number": 60,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[60,19] cannot find symbol",
            "additional_info": "  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "26070e28-31dd-5ee2-a9a5-86c95bd44a5e"
        },
        {
            "line_number": 75,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[75,27] cannot find symbol",
            "additional_info": "  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "26070e28-31dd-5ee2-a9a5-86c95bd44a5e"
        },
        {
            "line_number": 155,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[155,35] cannot find symbol",
            "additional_info": "  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MembershipEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)"
            ],
            "uid": "029ae109-9920-5251-bbf4-5402ff49f8aa"
        },
        {
            "line_number": 228,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[228,37] cannot find symbol",
            "additional_info": "  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MembershipEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public null com.hazelcast.cluster.MembershipEvent",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)",
                "++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)"
            ],
            "uid": "029ae109-9920-5251-bbf4-5402ff49f8aa"
        },
        {
            "line_number": 271,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[271,46] cannot find symbol",
            "additional_info": "  symbol:   class MemberAttributeEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
            "file_name": "ClusterListener.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MemberAttributeEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "0dc8ed27-65f3-521c-9915-c5dc6881980d"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.LifecycleEvent;\nimport com.hazelcast.core.LifecycleEvent.LifecycleState;\nimport com.hazelcast.core.LifecycleListener;\nimport com.hazelcast.core.Member;\nimport com.hazelcast.core.MemberAttributeEvent;\nimport com.hazelcast.core.MembershipEvent;\nimport com.hazelcast.core.MembershipListener;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state\n * of the routing table and the sessions within it when a node which manages those sessions goes down.\n */\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);\n\n    private boolean seniorClusterMember = false;\n\n    private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();\n    \n    private final Cluster cluster;\n    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n    \n    /**\n     * Flag that indicates if the listener has done all clean up work when noticed that the\n     * cluster has been stopped. This will force Openfire to wait until all clean\n     * up (e.g. changing caches implementations) is done before destroying the plugin.\n     */\n    private boolean done = true;\n    /**\n     * Flag that indicates if we've joined a cluster or not\n     */\n    private boolean clusterMember = false;\n    private boolean isSenior;\n\n    ClusterListener(final Cluster cluster) {\n\n        this.cluster = cluster;\n        for (final Member member : cluster.getMembers()) {\n            clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),\n                    new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));\n        }\n    }\n\n    private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {\n        if (cache instanceof CacheWrapper) {\n            final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();\n            if (wrapped instanceof ClusteredCache) {\n                ((ClusteredCache)wrapped).addEntryListener(listener);\n                // Keep track of the listener that we added to the cache\n                entryListeners.put(cache, listener);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private boolean isDone() {\n        return done;\n    }\n\n    synchronized void joinCluster() {\n        if (!isDone()) { // already joined\n            return;\n        }\n\n        // Trigger events\n        clusterMember = true;\n        seniorClusterMember = isSeniorClusterMember();\n\n        ClusterManager.fireJoinedCluster(false);\n\n        if (seniorClusterMember) {\n            ClusterManager.fireMarkedAsSeniorClusterMember();\n        }\n\n        waitForClusterCacheToBeInstalled();\n\n        // Let the other nodes know that we joined the cluster\n        logger.debug(\"Done joining the cluster. Now proceed informing other nodes that we joined the cluster.\");\n        CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n\n        logger.info(\"Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});\n        done = false;\n    }\n\n    boolean isSeniorClusterMember() {\n        // first cluster member is the oldest\n        final Iterator<Member> members = cluster.getMembers().iterator();\n        return members.next().getUuid().equals(cluster.getLocalMember().getUuid());\n    }\n\n    private synchronized void leaveCluster() {\n        if (isDone()) { // not a cluster member\n            return;\n        }\n        clusterMember = false;\n        final boolean wasSeniorClusterMember = seniorClusterMember;\n        seniorClusterMember = false;\n\n        // Trigger event. Wait until the listeners have processed the event. Caches will be populated\n        // again with local content.\n        ClusterManager.fireLeftCluster();\n\n        if (!XMPPServer.getInstance().isShuttingDown()) {\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        logger.info(\"Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});\n        done = true;\n    }\n\n    @Override\n    public void memberAdded(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberAdded event {}\", event);\n\n        final boolean wasSenior = isSenior;\n        isSenior = isSeniorClusterMember();\n        // local member only\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n        if (event.getMember().localMember()) { // We left and re-joined the cluster\n            joinCluster();\n\n        } else {\n            if (wasSenior && !isSenior) {\n                logger.warn(\"Recovering from split-brain; firing leftCluster()/joinedCluster() events\");\n                ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n                logger.debug(\"Firing joinedCluster() event\");\n                ClusterManager.fireJoinedCluster(false);\n\n                try {\n                    logger.debug(\"Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.\");\n                    Thread.sleep(30000L);\n                } catch (InterruptedException e) {\n                    logger.warn(\"30 Second wait was interrupted.\", e);\n                }\n\n                // The following line was intended to wait until all local handling finishes before informing other\n                // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.\n                // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.\n                waitForClusterCacheToBeInstalled();\n\n                // Let the other nodes know that we joined the cluster\n                logger.debug(\"Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.\");\n                CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n            }\n        }\n        clusterNodesInfo.put(nodeID,\n                new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));\n    }\n\n    /**\n     * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful\n     * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still\n     * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently\n     * discarded.\n     *\n     * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.\n     *\n     * @return Boolean indicating whether the clustered cache was actually observed to be installed.\n     */\n    private boolean waitForClusterCacheToBeInstalled() {\n        boolean failed = false;\n        if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {\n            logger.debug(\"This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.\", ClusteredCacheFactory.PLUGIN_NAME);\n            LocalTime deadLine = LocalTime.now().plusMinutes(10L);\n            while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    logger.trace(\"Thread was interrupted while waiting for cache strategy to change.\");\n                    failed = true;\n                    break;\n                }\n            }\n            if (!deadLine.isAfter(LocalTime.now())) {\n                failed = true;\n                logger.warn(\"Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.\", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());\n            }\n            logger.debug(\"Cache factory has been swapped to '{}'. Cluster join is considered complete.\", ClusteredCacheFactory.PLUGIN_NAME);\n        }\n\n        return !failed;\n    }\n\n    @Override\n    public void memberRemoved(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberRemoved event {}\", event);\n\n        isSenior = isSeniorClusterMember();\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n\n        if (event.getMember().localMember()) {\n            logger.info(\"Leaving cluster: \" + nodeID);\n            // This node may have realized that it got kicked out of the cluster\n            leaveCluster();\n        } else {\n            // Trigger event that a node left the cluster\n            ClusterManager.fireLeftCluster(nodeID.toByteArray());\n\n            if (!seniorClusterMember && isSeniorClusterMember()) {\n                seniorClusterMember = true;\n                ClusterManager.fireMarkedAsSeniorClusterMember();\n            }\n\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist.\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        // Delete nodeID instance (release from memory)\n        NodeID.deleteInstance(nodeID.toByteArray());\n        clusterNodesInfo.remove(nodeID);\n    }\n    \n    @SuppressWarnings(\"WeakerAccess\")\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return new ArrayList<>(clusterNodesInfo.values());\n    }\n\n    @Override\n    public void stateChanged(final LifecycleEvent event) {\n        if (event.getState().equals(LifecycleState.SHUTDOWN)) {\n            leaveCluster();\n        } else if (event.getState().equals(LifecycleState.STARTED)) {\n            joinCluster();\n        }\n    }\n\n    @Override\n    public void memberAttributeChanged(final MemberAttributeEvent event) {\n        logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);\n        isSenior = isSeniorClusterMember();\n        final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));\n        clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),\n                new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));\n    }\n\n    boolean isClusterMember() {\n        return clusterMember;\n    }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: hazelcast 3.12.5->4.0.5. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap\n\nThe error is triggered in the following specific lines in the previous code:\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Member;\nimport com.hazelcast.core.MemberAttributeEvent;\nimport com.hazelcast.core.MembershipEvent;\nimport com.hazelcast.core.MembershipListener;\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n    private final Cluster cluster;\n    ClusterListener(final Cluster cluster) {\n    public void memberAdded(final MembershipEvent event) {\n    public void memberRemoved(final MembershipEvent event) {\n    public void memberAttributeChanged(final MemberAttributeEvent event) {\nwith the following error message:\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[18,26] cannot find symbol  symbol:   class Cluster\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[23,26] cannot find symbol  symbol:   class Member\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[24,26] cannot find symbol  symbol:   class MemberAttributeEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[25,26] cannot find symbol  symbol:   class MembershipEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[26,26] cannot find symbol  symbol:   class MembershipListener\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[52,41] cannot find symbol  symbol: class MembershipListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[60,19] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[75,27] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[155,35] cannot find symbol  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[228,37] cannot find symbol  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[271,46] cannot find symbol  symbol:   class MemberAttributeEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Member;\nimport com.hazelcast.core.MemberAttributeEvent;\nimport com.hazelcast.core.MembershipEvent;\nimport com.hazelcast.core.MembershipListener;\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n    private final Cluster cluster;\n    ClusterListener(final Cluster cluster) {\n    public void memberAdded(final MembershipEvent event) {\n    public void memberRemoved(final MembershipEvent event) {\n    public void memberAttributeChanged(final MemberAttributeEvent event) {",
    "error_message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[18,26] cannot find symbol  symbol:   class Cluster\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[23,26] cannot find symbol  symbol:   class Member\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[24,26] cannot find symbol  symbol:   class MemberAttributeEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[25,26] cannot find symbol  symbol:   class MembershipEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[26,26] cannot find symbol  symbol:   class MembershipListener\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[52,41] cannot find symbol  symbol: class MembershipListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[60,19] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[75,27] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[155,35] cannot find symbol  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[228,37] cannot find symbol  symbol:   class MembershipEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusterListener.java:[271,46] cannot find symbol  symbol:   class MemberAttributeEvent\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusterListener",
    "api_diff": "-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap",
    "original_code": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.LifecycleEvent;\nimport com.hazelcast.core.LifecycleEvent.LifecycleState;\nimport com.hazelcast.core.LifecycleListener;\nimport com.hazelcast.core.Member;\nimport com.hazelcast.core.MemberAttributeEvent;\nimport com.hazelcast.core.MembershipEvent;\nimport com.hazelcast.core.MembershipListener;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.muc.cluster.NewClusterMemberJoinedTask;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.Duration;\nimport java.time.LocalTime;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * ClusterListener reacts to membership changes in the cluster. It takes care of cleaning up the state\n * of the routing table and the sessions within it when a node which manages those sessions goes down.\n */\npublic class ClusterListener implements MembershipListener, LifecycleListener {\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusterListener.class);\n\n    private boolean seniorClusterMember = false;\n\n    private final Map<Cache<?,?>, EntryListener> entryListeners = new HashMap<>();\n    \n    private final Cluster cluster;\n    private final Map<NodeID, ClusterNodeInfo> clusterNodesInfo = new ConcurrentHashMap<>();\n    \n    /**\n     * Flag that indicates if the listener has done all clean up work when noticed that the\n     * cluster has been stopped. This will force Openfire to wait until all clean\n     * up (e.g. changing caches implementations) is done before destroying the plugin.\n     */\n    private boolean done = true;\n    /**\n     * Flag that indicates if we've joined a cluster or not\n     */\n    private boolean clusterMember = false;\n    private boolean isSenior;\n\n    ClusterListener(final Cluster cluster) {\n\n        this.cluster = cluster;\n        for (final Member member : cluster.getMembers()) {\n            clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(member),\n                    new HazelcastClusterNodeInfo(member, cluster.getClusterTime()));\n        }\n    }\n\n    private void addEntryListener(final Cache<?, ?> cache, final EntryListener listener) {\n        if (cache instanceof CacheWrapper) {\n            final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();\n            if (wrapped instanceof ClusteredCache) {\n                ((ClusteredCache)wrapped).addEntryListener(listener);\n                // Keep track of the listener that we added to the cache\n                entryListeners.put(cache, listener);\n            }\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private boolean isDone() {\n        return done;\n    }\n\n    synchronized void joinCluster() {\n        if (!isDone()) { // already joined\n            return;\n        }\n\n        // Trigger events\n        clusterMember = true;\n        seniorClusterMember = isSeniorClusterMember();\n\n        ClusterManager.fireJoinedCluster(false);\n\n        if (seniorClusterMember) {\n            ClusterManager.fireMarkedAsSeniorClusterMember();\n        }\n\n        waitForClusterCacheToBeInstalled();\n\n        // Let the other nodes know that we joined the cluster\n        logger.debug(\"Done joining the cluster. Now proceed informing other nodes that we joined the cluster.\");\n        CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n\n        logger.info(\"Joined cluster. XMPPServer node={}, Hazelcast UUID={}, seniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});\n        done = false;\n    }\n\n    boolean isSeniorClusterMember() {\n        // first cluster member is the oldest\n        final Iterator<Member> members = cluster.getMembers().iterator();\n        return members.next().getUuid().equals(cluster.getLocalMember().getUuid());\n    }\n\n    private synchronized void leaveCluster() {\n        if (isDone()) { // not a cluster member\n            return;\n        }\n        clusterMember = false;\n        final boolean wasSeniorClusterMember = seniorClusterMember;\n        seniorClusterMember = false;\n\n        // Trigger event. Wait until the listeners have processed the event. Caches will be populated\n        // again with local content.\n        ClusterManager.fireLeftCluster();\n\n        if (!XMPPServer.getInstance().isShuttingDown()) {\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        logger.info(\"Left cluster. XMPPServer node={}, Hazelcast UUID={}, wasSeniorClusterMember={}\",\n            new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});\n        done = true;\n    }\n\n    @Override\n    public void memberAdded(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberAdded event {}\", event);\n\n        final boolean wasSenior = isSenior;\n        isSenior = isSeniorClusterMember();\n        // local member only\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n        if (event.getMember().localMember()) { // We left and re-joined the cluster\n            joinCluster();\n\n        } else {\n            if (wasSenior && !isSenior) {\n                logger.warn(\"Recovering from split-brain; firing leftCluster()/joinedCluster() events\");\n                ClusteredCacheFactory.fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n                logger.debug(\"Firing joinedCluster() event\");\n                ClusterManager.fireJoinedCluster(false);\n\n                try {\n                    logger.debug(\"Postponing notification of other nodes for 30 seconds. This allows all local leave/join processing to be finished and local cache backups to be stabilized before receiving events from other nodes.\");\n                    Thread.sleep(30000L);\n                } catch (InterruptedException e) {\n                    logger.warn(\"30 Second wait was interrupted.\", e);\n                }\n\n                // The following line was intended to wait until all local handling finishes before informing other\n                // nodes. However that proved to be insufficient. Hence the 30 second default wait in the lines above.\n                // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.\n                waitForClusterCacheToBeInstalled();\n\n                // Let the other nodes know that we joined the cluster\n                logger.debug(\"Done joining the cluster in split brain recovery. Now proceed informing other nodes that we joined the cluster.\");\n                CacheFactory.doClusterTask(new NewClusterMemberJoinedTask());\n            }\n        }\n        clusterNodesInfo.put(nodeID,\n                new HazelcastClusterNodeInfo(event.getMember(), cluster.getClusterTime()));\n    }\n\n    /**\n     * Blocks the current thread until the cluster cache is guaranteed to support clustering. This is especially useful\n     * for executing cluster tasks immediately after joining. If this wait is not performed, the cache factory may still\n     * be using the 'default' strategy instead of the 'hazelcast' strategy, which leads to cluster tasks being silently\n     * discarded.\n     *\n     * The method will keep trying this for 10 minutes. After that the thread is released regardless of the result.\n     *\n     * @return Boolean indicating whether the clustered cache was actually observed to be installed.\n     */\n    private boolean waitForClusterCacheToBeInstalled() {\n        boolean failed = false;\n        if (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName())) {\n            logger.debug(\"This node now joined a cluster, but the cache factory has not been swapped to '{}' yet. Waiting for that to happen.\", ClusteredCacheFactory.PLUGIN_NAME);\n            LocalTime deadLine = LocalTime.now().plusMinutes(10L);\n            while (!ClusteredCacheFactory.PLUGIN_NAME.equals(CacheFactory.getPluginName()) && deadLine.isAfter(LocalTime.now())) {\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    logger.trace(\"Thread was interrupted while waiting for cache strategy to change.\");\n                    failed = true;\n                    break;\n                }\n            }\n            if (!deadLine.isAfter(LocalTime.now())) {\n                failed = true;\n                logger.warn(\"Cache factory was not swapped to '{}', but still remains '{}' after a 10 minute wait. Cluster join is not guaranteed to have completed.\", ClusteredCacheFactory.PLUGIN_NAME, CacheFactory.getPluginName());\n            }\n            logger.debug(\"Cache factory has been swapped to '{}'. Cluster join is considered complete.\", ClusteredCacheFactory.PLUGIN_NAME);\n        }\n\n        return !failed;\n    }\n\n    @Override\n    public void memberRemoved(final MembershipEvent event) {\n        logger.info(\"Received a Hazelcast memberRemoved event {}\", event);\n\n        isSenior = isSeniorClusterMember();\n        final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());\n\n        if (event.getMember().localMember()) {\n            logger.info(\"Leaving cluster: \" + nodeID);\n            // This node may have realized that it got kicked out of the cluster\n            leaveCluster();\n        } else {\n            // Trigger event that a node left the cluster\n            ClusterManager.fireLeftCluster(nodeID.toByteArray());\n\n            if (!seniorClusterMember && isSeniorClusterMember()) {\n                seniorClusterMember = true;\n                ClusterManager.fireMarkedAsSeniorClusterMember();\n            }\n\n            // Remove traces of directed presences sent from local entities to handlers that no longer exist.\n            // At this point c2s sessions are gone from the routing table so we can identify expired sessions\n            XMPPServer.getInstance().getPresenceUpdateHandler().removedExpiredPresences();\n        }\n        // Delete nodeID instance (release from memory)\n        NodeID.deleteInstance(nodeID.toByteArray());\n        clusterNodesInfo.remove(nodeID);\n    }\n    \n    @SuppressWarnings(\"WeakerAccess\")\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return new ArrayList<>(clusterNodesInfo.values());\n    }\n\n    @Override\n    public void stateChanged(final LifecycleEvent event) {\n        if (event.getState().equals(LifecycleState.SHUTDOWN)) {\n            leaveCluster();\n        } else if (event.getState().equals(LifecycleState.STARTED)) {\n            joinCluster();\n        }\n    }\n\n    @Override\n    public void memberAttributeChanged(final MemberAttributeEvent event) {\n        logger.info(\"Received a Hazelcast memberAttributeChanged event {}\", event);\n        isSenior = isSeniorClusterMember();\n        final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));\n        clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),\n                new HazelcastClusterNodeInfo(event.getMember(), priorNodeInfo.getJoinedTime()));\n    }\n\n    boolean isClusterMember() {\n        return clusterMember;\n    }\n}\n",
    "project": "openfire-hazelcast-plugin",
    "libraryName": "hazelcast",
    "libraryGroupID": "com.hazelcast",
    "newVersion": "4.0.5",
    "previousVersion": "3.12.5",
    "breakingCommit": "2b4d49d68112941b8abb818549389709d8327963"
}