{
    "absolute_path_to_file_in_container": "/polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelConstructor.java",
    "errors": [
        {
            "line_number": 43,
            "message": "[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelConstructor.java:[43,5] The constructor Constructor(Class<Model>) is undefined",
            "additional_info": "",
            "file_name": "ModelConstructor.java",
            "uid": "8299eb13-4fd3-5e1b-a496-c8e50bd1c684"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: snakeyaml 1.17->2.0\n\nthe following client code fails: \n'''java\n/**\n * Copyright (c) 2012 to original author or authors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n */\npackage org.sonatype.maven.polyglot.yaml;\n\nimport org.apache.maven.model.*;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\nimport org.yaml.snakeyaml.TypeDescription;\nimport org.yaml.snakeyaml.constructor.Construct;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.error.YAMLException;\nimport org.yaml.snakeyaml.nodes.*;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.lang.String.format;\n\n/**\n * YAML model constructor.\n *\n * @author jvanzyl\n * @author bentmann\n * @author <a href=\"mailto:jason@planet57.com\">Jason Dillon</a>\n * @since 0.7\n */\npublic final class ModelConstructor extends Constructor {\n\n  private static final Tag XPP3DOM_TAG = new Tag(\"!!\" + Xpp3Dom.class.getName());\n\n  /**\n   * It maps the runtime class to its Construct implementation.\n   */\n  private final Map<Class<?>, Construct> pomConstructors = new HashMap<>();\n\n  public ModelConstructor() {\n    super(Model.class);\n\n    yamlConstructors.put(XPP3DOM_TAG, new ConstructXpp3Dom());\n    yamlClassConstructors.put(NodeId.mapping, new MavenObjectConstruct());\n    pomConstructors.put(Dependency.class, new ConstructDependency());\n    pomConstructors.put(Parent.class, new ConstructParent());\n    pomConstructors.put(Extension.class, new ConstructExtension());\n    pomConstructors.put(Plugin.class, new ConstructPlugin());\n    pomConstructors.put(ReportPlugin.class, new ConstructReportPlugin());\n\n    TypeDescription desc;\n\n    desc = new TypeDescription(Model.class);\n    desc.putListPropertyType(\"licenses\", License.class);\n    desc.putListPropertyType(\"mailingLists\", MailingList.class);\n    desc.putListPropertyType(\"dependencies\", Dependency.class);\n    desc.putListPropertyType(\"modules\", String.class);\n    desc.putListPropertyType(\"profiles\", Profile.class);\n    desc.putListPropertyType(\"repositories\", Repository.class);\n    desc.putListPropertyType(\"pluginRepositories\", Repository.class);\n    desc.putListPropertyType(\"developers\", Developer.class);\n    desc.putListPropertyType(\"contributors\", Contributor.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Dependency.class);\n    desc.putListPropertyType(\"exclusions\", Exclusion.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(DependencyManagement.class);\n    desc.putListPropertyType(\"dependencies\", Dependency.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Build.class);\n    desc.putListPropertyType(\"extensions\", Extension.class);\n    desc.putListPropertyType(\"resources\", Resource.class);\n    desc.putListPropertyType(\"testResources\", Resource.class);\n    desc.putListPropertyType(\"filters\", String.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(BuildBase.class);\n    desc.putListPropertyType(\"resources\", Resource.class);\n    desc.putListPropertyType(\"testResources\", Resource.class);\n    desc.putListPropertyType(\"filters\", String.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(PluginManagement.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Plugin.class);\n    desc.putListPropertyType(\"executions\", PluginExecution.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(PluginExecution.class);\n    desc.putListPropertyType(\"goals\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Reporting.class);\n    desc.putListPropertyType(\"plugins\", ReportPlugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(ReportPlugin.class);\n    desc.putListPropertyType(\"reportSets\", ReportSet.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(ReportSet.class);\n    desc.putListPropertyType(\"reports\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(CiManagement.class);\n    desc.putListPropertyType(\"notifiers\", Notifier.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Developer.class);\n    desc.putListPropertyType(\"roles\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Contributor.class);\n    desc.putListPropertyType(\"roles\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(MailingList.class);\n    desc.putListPropertyType(\"otherArchives\", String.class);\n    addTypeDescription(desc);\n\n    // Simple types\n    addTypeDescription(new TypeDescription(DistributionManagement.class));\n    addTypeDescription(new TypeDescription(Scm.class));\n    addTypeDescription(new TypeDescription(IssueManagement.class));\n    addTypeDescription(new TypeDescription(Parent.class));\n    addTypeDescription(new TypeDescription(Organization.class));\n  }\n\n  @Override\n  protected Construct getConstructor(Node node) {\n    if (pomConstructors.containsKey(node.getType()) && node instanceof ScalarNode) {\n      //construct compact form from scalar\n      return pomConstructors.get(node.getType());\n    } else {\n      return super.getConstructor(node);\n    }\n  }\n\n  private class ConstructXpp3Dom implements Construct {\n    private static final String ATTRIBUTE_PREFIX = \"attr/\";\n\n    private Xpp3Dom toDom(Xpp3Dom parent, Map<Object, Object> map) {\n\n      for (Map.Entry<Object, Object> entry : map.entrySet()) {\n        String key = entry.getKey().toString();\n        Object entryValue = entry.getValue();\n        Xpp3Dom child = new Xpp3Dom(key);\n\n        if (key.startsWith(ATTRIBUTE_PREFIX)) {\n          toAttribute(parent, key.replace(ATTRIBUTE_PREFIX, \"\"), entryValue);\n          continue;\n        }\n\n        // lists need the insertion of intermediate XML DOM nodes which hold the actual values\n        if (entryValue instanceof List && !((List) entryValue).isEmpty()) {\n          toDom(child, key, (List) entryValue);\n        } else if (entryValue instanceof Map) {\n          //noinspection unchecked\n          child = toDom(child, (Map) entryValue);\n        } else { // if not a list or map then copy the string value\n          child.setValue(entryValue.toString());\n        }\n        parent.addChild(child);\n      }\n      return parent;\n    }\n\n    private void toDom(Xpp3Dom parent, String parentKey, List list) {\n      Object firstItem = list.get(0);\n\n      String childKey;\n\n      // deal with YAML explicit pairs which are mapped to Object[] by SnakeYAML\n      if (firstItem.getClass().isArray()) {\n        for (Object item : list) {\n          Object[] pair = (Object[]) item;\n          childKey = \"\" + pair[0];\n          Xpp3Dom itemNode = new Xpp3Dom(childKey);\n          if (pair[1] != null && pair[1] instanceof Map)\n            //noinspection unchecked\n            toDom(itemNode, (Map) pair[1]);\n          else\n            itemNode.setValue(\"\" + pair[1]);\n          parent.addChild(itemNode);\n        }\n      } else { // automagically determine the node's child key using the collection node's name\n        if (!parentKey.endsWith(\"s\")) {\n          throw new RuntimeException(format(\"collection key '%s' does not end in 's'. Please resort to the \" +\n              \"documentation on how to use explicit pairs for specifying child node names\", parentKey));\n        }\n\n        if (\"reportPlugins\".equals(parentKey)) {\n          childKey = \"plugin\";\n        } else {\n          childKey = parentKey.substring(0, parentKey.length() - 1);\n          if (childKey.endsWith(\"ie\")) {\n            childKey = childKey.substring(0, childKey.length() - 2) + \"y\";\n          }\n        }\n\n        for (Object item : list) {\n          Xpp3Dom itemNode = new Xpp3Dom(childKey);\n          if (item instanceof Map)\n            //noinspection unchecked\n            toDom(itemNode, (Map) item);\n          else\n            itemNode.setValue(item.toString());\n          parent.addChild(itemNode);\n        }\n      }\n    }\n\n    private void toAttribute(Xpp3Dom parent, String key, Object value) {\n      if (value instanceof List || value instanceof Map) {\n        throw new YAMLException(\"Attribute's value has to be a plain string. Node: \" + parent);\n      }\n\n      parent.setAttribute(key, value.toString());\n    }\n\n    public Object construct(Node node) {\n      Map<Object, Object> mapping = constructMapping((MappingNode) node);\n      Xpp3Dom parent = new Xpp3Dom(\"configuration\");\n      return toDom(parent, mapping);\n    }\n\n    public void construct2ndStep(Node node, Object object) {\n      throw new YAMLException(\"Unexpected recursive mapping structure. Node: \" + node);\n    }\n  }\n\n  class MavenObjectConstruct extends Constructor.ConstructMapping {\n    @Override\n    protected Object constructJavaBean2ndStep(MappingNode node, Object object) {\n      Class<?> type = node.getType();\n\n      List<Class> specialCases = Arrays.<Class>asList(Dependency.class, Model.class, Plugin.class, ReportPlugin.class);\n      List<Class> configurationContainers = Arrays.<Class>asList(Plugin.class, PluginExecution.class,\n          ReportPlugin.class, ReportSet.class);\n\n      if (configurationContainers.contains(type)) {\n        for (NodeTuple valueNode : node.getValue()) {\n          Node keyNode = valueNode.getKeyNode();\n          Node childValueNode = valueNode.getValueNode();\n          if (keyNode instanceof ScalarNode && \"configuration\".equals(((ScalarNode) keyNode).getValue())) {\n            childValueNode.setTag(XPP3DOM_TAG);\n          }\n        }\n      }\n\n      if (specialCases.contains(type)) {\n        String coordinate = removeId(node);\n        if (coordinate == null) {\n          return super.constructJavaBean2ndStep(node, object);\n        }\n        if (type.equals(Dependency.class)) {\n          Dependency dep = (Dependency) super.constructJavaBean2ndStep(node, object);\n          return ConstructDependency.createDependency(coordinate, dep);\n        } else if (type.equals(Model.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          Model model = (Model) super.constructJavaBean2ndStep(node, object);\n          return coord.mergeModel(model);\n        } else if (type.equals(Plugin.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          Plugin plugin = (Plugin) super.constructJavaBean2ndStep(node, object);\n          return coord.mergePlugin(plugin);\n        } else if (type.equals(ReportPlugin.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          ReportPlugin plugin = (ReportPlugin) super.constructJavaBean2ndStep(node, object);\n          return coord.mergeReportPlugin(plugin);\n        }\n      }\n      // create JavaBean\n      return super.constructJavaBean2ndStep(node, object);\n    }\n  }\n\n  /**\n   * Dirty hack - remove 'id' if it is present.\n   *\n   * @param node - the node to remove the coordinate from\n   * @return removed coordinate if it was removed\n   */\n  private String removeId(MappingNode node) {\n    NodeTuple id = null;\n    String scalar = null;\n    for (NodeTuple tuple : node.getValue()) {\n      ScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\n      String key = keyNode.getValue();\n      if (\"id\".equals(key)) {\n        id = tuple;\n        ScalarNode valueNode = (ScalarNode) tuple.getValueNode();\n        scalar = valueNode.getValue();\n      }\n    }\n    if (id != null) {\n      node.getValue().remove(id);\n    }\n    return scalar;\n  }\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n    super(Model.class);\nwith the following error message:\n[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelConstructor.java:[43,5] The constructor Constructor(Class<Model>) is undefined\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.yaml.snakeyaml.introspector.PropertyUtils.getProperties | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.introspector.PropertyUtils.getProperty | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.introspector.Property | ADDITION | METHOD_ABSTRACT_ADDED_TO_CLASS\norg.yaml.snakeyaml.introspector.PropertyUtils.createPropertySet | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.representer.Representer.getProperties | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.representer.Representer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.yaml.snakeyaml.introspector.PropertyUtils.getPropertiesMap | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "    super(Model.class);",
    "error_message": "[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelConstructor.java:[43,5] The constructor Constructor(Class<Model>) is undefined",
    "api_diff": "Format: element | nature | kind\norg.yaml.snakeyaml.introspector.PropertyUtils.getProperties | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.introspector.PropertyUtils.getProperty | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.introspector.Property | ADDITION | METHOD_ABSTRACT_ADDED_TO_CLASS\norg.yaml.snakeyaml.introspector.PropertyUtils.createPropertySet | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.representer.Representer.getProperties | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.yaml.snakeyaml.representer.Representer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.yaml.snakeyaml.introspector.PropertyUtils.getPropertiesMap | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION",
    "original_code": "/**\n * Copyright (c) 2012 to original author or authors\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n */\npackage org.sonatype.maven.polyglot.yaml;\n\nimport org.apache.maven.model.*;\nimport org.codehaus.plexus.util.xml.Xpp3Dom;\nimport org.yaml.snakeyaml.TypeDescription;\nimport org.yaml.snakeyaml.constructor.Construct;\nimport org.yaml.snakeyaml.constructor.Constructor;\nimport org.yaml.snakeyaml.error.YAMLException;\nimport org.yaml.snakeyaml.nodes.*;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.lang.String.format;\n\n/**\n * YAML model constructor.\n *\n * @author jvanzyl\n * @author bentmann\n * @author <a href=\"mailto:jason@planet57.com\">Jason Dillon</a>\n * @since 0.7\n */\npublic final class ModelConstructor extends Constructor {\n\n  private static final Tag XPP3DOM_TAG = new Tag(\"!!\" + Xpp3Dom.class.getName());\n\n  /**\n   * It maps the runtime class to its Construct implementation.\n   */\n  private final Map<Class<?>, Construct> pomConstructors = new HashMap<>();\n\n  public ModelConstructor() {\n    super(Model.class);\n\n    yamlConstructors.put(XPP3DOM_TAG, new ConstructXpp3Dom());\n    yamlClassConstructors.put(NodeId.mapping, new MavenObjectConstruct());\n    pomConstructors.put(Dependency.class, new ConstructDependency());\n    pomConstructors.put(Parent.class, new ConstructParent());\n    pomConstructors.put(Extension.class, new ConstructExtension());\n    pomConstructors.put(Plugin.class, new ConstructPlugin());\n    pomConstructors.put(ReportPlugin.class, new ConstructReportPlugin());\n\n    TypeDescription desc;\n\n    desc = new TypeDescription(Model.class);\n    desc.putListPropertyType(\"licenses\", License.class);\n    desc.putListPropertyType(\"mailingLists\", MailingList.class);\n    desc.putListPropertyType(\"dependencies\", Dependency.class);\n    desc.putListPropertyType(\"modules\", String.class);\n    desc.putListPropertyType(\"profiles\", Profile.class);\n    desc.putListPropertyType(\"repositories\", Repository.class);\n    desc.putListPropertyType(\"pluginRepositories\", Repository.class);\n    desc.putListPropertyType(\"developers\", Developer.class);\n    desc.putListPropertyType(\"contributors\", Contributor.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Dependency.class);\n    desc.putListPropertyType(\"exclusions\", Exclusion.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(DependencyManagement.class);\n    desc.putListPropertyType(\"dependencies\", Dependency.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Build.class);\n    desc.putListPropertyType(\"extensions\", Extension.class);\n    desc.putListPropertyType(\"resources\", Resource.class);\n    desc.putListPropertyType(\"testResources\", Resource.class);\n    desc.putListPropertyType(\"filters\", String.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(BuildBase.class);\n    desc.putListPropertyType(\"resources\", Resource.class);\n    desc.putListPropertyType(\"testResources\", Resource.class);\n    desc.putListPropertyType(\"filters\", String.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(PluginManagement.class);\n    desc.putListPropertyType(\"plugins\", Plugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Plugin.class);\n    desc.putListPropertyType(\"executions\", PluginExecution.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(PluginExecution.class);\n    desc.putListPropertyType(\"goals\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Reporting.class);\n    desc.putListPropertyType(\"plugins\", ReportPlugin.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(ReportPlugin.class);\n    desc.putListPropertyType(\"reportSets\", ReportSet.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(ReportSet.class);\n    desc.putListPropertyType(\"reports\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(CiManagement.class);\n    desc.putListPropertyType(\"notifiers\", Notifier.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Developer.class);\n    desc.putListPropertyType(\"roles\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(Contributor.class);\n    desc.putListPropertyType(\"roles\", String.class);\n    addTypeDescription(desc);\n\n    desc = new TypeDescription(MailingList.class);\n    desc.putListPropertyType(\"otherArchives\", String.class);\n    addTypeDescription(desc);\n\n    // Simple types\n    addTypeDescription(new TypeDescription(DistributionManagement.class));\n    addTypeDescription(new TypeDescription(Scm.class));\n    addTypeDescription(new TypeDescription(IssueManagement.class));\n    addTypeDescription(new TypeDescription(Parent.class));\n    addTypeDescription(new TypeDescription(Organization.class));\n  }\n\n  @Override\n  protected Construct getConstructor(Node node) {\n    if (pomConstructors.containsKey(node.getType()) && node instanceof ScalarNode) {\n      //construct compact form from scalar\n      return pomConstructors.get(node.getType());\n    } else {\n      return super.getConstructor(node);\n    }\n  }\n\n  private class ConstructXpp3Dom implements Construct {\n    private static final String ATTRIBUTE_PREFIX = \"attr/\";\n\n    private Xpp3Dom toDom(Xpp3Dom parent, Map<Object, Object> map) {\n\n      for (Map.Entry<Object, Object> entry : map.entrySet()) {\n        String key = entry.getKey().toString();\n        Object entryValue = entry.getValue();\n        Xpp3Dom child = new Xpp3Dom(key);\n\n        if (key.startsWith(ATTRIBUTE_PREFIX)) {\n          toAttribute(parent, key.replace(ATTRIBUTE_PREFIX, \"\"), entryValue);\n          continue;\n        }\n\n        // lists need the insertion of intermediate XML DOM nodes which hold the actual values\n        if (entryValue instanceof List && !((List) entryValue).isEmpty()) {\n          toDom(child, key, (List) entryValue);\n        } else if (entryValue instanceof Map) {\n          //noinspection unchecked\n          child = toDom(child, (Map) entryValue);\n        } else { // if not a list or map then copy the string value\n          child.setValue(entryValue.toString());\n        }\n        parent.addChild(child);\n      }\n      return parent;\n    }\n\n    private void toDom(Xpp3Dom parent, String parentKey, List list) {\n      Object firstItem = list.get(0);\n\n      String childKey;\n\n      // deal with YAML explicit pairs which are mapped to Object[] by SnakeYAML\n      if (firstItem.getClass().isArray()) {\n        for (Object item : list) {\n          Object[] pair = (Object[]) item;\n          childKey = \"\" + pair[0];\n          Xpp3Dom itemNode = new Xpp3Dom(childKey);\n          if (pair[1] != null && pair[1] instanceof Map)\n            //noinspection unchecked\n            toDom(itemNode, (Map) pair[1]);\n          else\n            itemNode.setValue(\"\" + pair[1]);\n          parent.addChild(itemNode);\n        }\n      } else { // automagically determine the node's child key using the collection node's name\n        if (!parentKey.endsWith(\"s\")) {\n          throw new RuntimeException(format(\"collection key '%s' does not end in 's'. Please resort to the \" +\n              \"documentation on how to use explicit pairs for specifying child node names\", parentKey));\n        }\n\n        if (\"reportPlugins\".equals(parentKey)) {\n          childKey = \"plugin\";\n        } else {\n          childKey = parentKey.substring(0, parentKey.length() - 1);\n          if (childKey.endsWith(\"ie\")) {\n            childKey = childKey.substring(0, childKey.length() - 2) + \"y\";\n          }\n        }\n\n        for (Object item : list) {\n          Xpp3Dom itemNode = new Xpp3Dom(childKey);\n          if (item instanceof Map)\n            //noinspection unchecked\n            toDom(itemNode, (Map) item);\n          else\n            itemNode.setValue(item.toString());\n          parent.addChild(itemNode);\n        }\n      }\n    }\n\n    private void toAttribute(Xpp3Dom parent, String key, Object value) {\n      if (value instanceof List || value instanceof Map) {\n        throw new YAMLException(\"Attribute's value has to be a plain string. Node: \" + parent);\n      }\n\n      parent.setAttribute(key, value.toString());\n    }\n\n    public Object construct(Node node) {\n      Map<Object, Object> mapping = constructMapping((MappingNode) node);\n      Xpp3Dom parent = new Xpp3Dom(\"configuration\");\n      return toDom(parent, mapping);\n    }\n\n    public void construct2ndStep(Node node, Object object) {\n      throw new YAMLException(\"Unexpected recursive mapping structure. Node: \" + node);\n    }\n  }\n\n  class MavenObjectConstruct extends Constructor.ConstructMapping {\n    @Override\n    protected Object constructJavaBean2ndStep(MappingNode node, Object object) {\n      Class<?> type = node.getType();\n\n      List<Class> specialCases = Arrays.<Class>asList(Dependency.class, Model.class, Plugin.class, ReportPlugin.class);\n      List<Class> configurationContainers = Arrays.<Class>asList(Plugin.class, PluginExecution.class,\n          ReportPlugin.class, ReportSet.class);\n\n      if (configurationContainers.contains(type)) {\n        for (NodeTuple valueNode : node.getValue()) {\n          Node keyNode = valueNode.getKeyNode();\n          Node childValueNode = valueNode.getValueNode();\n          if (keyNode instanceof ScalarNode && \"configuration\".equals(((ScalarNode) keyNode).getValue())) {\n            childValueNode.setTag(XPP3DOM_TAG);\n          }\n        }\n      }\n\n      if (specialCases.contains(type)) {\n        String coordinate = removeId(node);\n        if (coordinate == null) {\n          return super.constructJavaBean2ndStep(node, object);\n        }\n        if (type.equals(Dependency.class)) {\n          Dependency dep = (Dependency) super.constructJavaBean2ndStep(node, object);\n          return ConstructDependency.createDependency(coordinate, dep);\n        } else if (type.equals(Model.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          Model model = (Model) super.constructJavaBean2ndStep(node, object);\n          return coord.mergeModel(model);\n        } else if (type.equals(Plugin.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          Plugin plugin = (Plugin) super.constructJavaBean2ndStep(node, object);\n          return coord.mergePlugin(plugin);\n        } else if (type.equals(ReportPlugin.class)) {\n          Coordinate coord = Coordinate.createCoordinate(coordinate);\n          ReportPlugin plugin = (ReportPlugin) super.constructJavaBean2ndStep(node, object);\n          return coord.mergeReportPlugin(plugin);\n        }\n      }\n      // create JavaBean\n      return super.constructJavaBean2ndStep(node, object);\n    }\n  }\n\n  /**\n   * Dirty hack - remove 'id' if it is present.\n   *\n   * @param node - the node to remove the coordinate from\n   * @return removed coordinate if it was removed\n   */\n  private String removeId(MappingNode node) {\n    NodeTuple id = null;\n    String scalar = null;\n    for (NodeTuple tuple : node.getValue()) {\n      ScalarNode keyNode = (ScalarNode) tuple.getKeyNode();\n      String key = keyNode.getValue();\n      if (\"id\".equals(key)) {\n        id = tuple;\n        ScalarNode valueNode = (ScalarNode) tuple.getValueNode();\n        scalar = valueNode.getValue();\n      }\n    }\n    if (id != null) {\n      node.getValue().remove(id);\n    }\n    return scalar;\n  }\n}\n",
    "project": "polyglot-maven",
    "libraryName": "snakeyaml",
    "libraryGroupID": "org.yaml",
    "newVersion": "2.0",
    "previousVersion": "1.17",
    "breakingCommit": "1e17e176460ab4283e463e62fece844d341da7f0"
}