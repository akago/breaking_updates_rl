{
    "absolute_path_to_file_in_container": "/openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java",
    "errors": [
        {
            "line_number": 20,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[20,26] cannot find symbol",
            "additional_info": "  symbol:   class IMap\n  location: package com.hazelcast.core",
            "file_name": "ClusteredCache.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.IMap",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.map.IMap",
                "++ public abstract interface null com.hazelcast.map.IMap"
            ],
            "uid": "1c52b5ad-cffb-5645-ab3d-bcbae6764632"
        },
        {
            "line_number": 21,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[21,26] cannot find symbol",
            "additional_info": "  symbol:   class MapEvent\n  location: package com.hazelcast.core",
            "file_name": "ClusteredCache.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.MapEvent",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public null com.hazelcast.map.MapEvent",
                "++ public null com.hazelcast.map.MapEvent",
                "++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)",
                "++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)"
            ],
            "uid": "445aa0c5-42c0-58f0-aa36-c9708d0ee04a"
        },
        {
            "line_number": 23,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[23,29] package com.hazelcast.monitor does not exist",
            "additional_info": "",
            "file_name": "ClusteredCache.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "7f2a7871-8032-5de5-8c4a-ebdb2a87d2a9"
        },
        {
            "line_number": 58,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[58,11] cannot find symbol",
            "additional_info": "  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>",
            "file_name": "ClusteredCache.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.IMap",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.map.IMap",
                "++ public abstract interface null com.hazelcast.map.IMap"
            ],
            "uid": "6881557a-bd2a-5c14-b535-5d6c55f16a77"
        },
        {
            "line_number": 74,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[74,55] cannot find symbol",
            "additional_info": "  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>",
            "file_name": "ClusteredCache.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.IMap",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.map.IMap",
                "++ public abstract interface null com.hazelcast.map.IMap"
            ],
            "uid": "6881557a-bd2a-5c14-b535-5d6c55f16a77"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.EntryEvent;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.IMap;\nimport com.hazelcast.core.MapEvent;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.container.PluginManager;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Clustered implementation of the Cache interface using Hazelcast.\n *\n */\npublic class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {\n\n    private final Logger logger;\n\n    private final Set<String> listeners = ConcurrentHashMap.newKeySet();\n\n    /**\n     * The map is used for distributed operations such as get, put, etc.\n     */\n    final IMap<K, V> map;\n    private String name;\n    private long numberOfGets = 0;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private Instant lastPluginClassLoaderWarning = Instant.EPOCH;\n    private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);\n\n    /**\n     * Create a new cache using the supplied named cache as the actual cache implementation\n     *\n     * @param name a name for the cache, which should be unique per vm.\n     * @param cache the cache implementation\n     */\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {\n        this.map = cache;\n        this.name = name;\n        logger = LoggerFactory.getLogger(ClusteredCache.class.getName() + \"[cache: \"+name+\"]\");\n    }\n\n    void addEntryListener(final MapListener listener) {\n        listeners.add(map.addEntryListener(listener, false));\n    }\n\n    @Override\n    public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)\n    {\n        final EntryListener<K, V> listener = new EntryListener<K, V>() {\n            @Override\n            public void mapEvicted(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map evicted event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapEvicted(eventNodeId);\n                }\n            }\n\n            @Override\n            public void mapCleared(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map cleared event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapCleared(eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryUpdated(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry update event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryRemoved(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry removed event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryRemoved((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry evicted event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryAdded(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry added event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryAdded((K) event.getKey(), (V) event.getValue(), eventNodeId);\n                }\n            }\n        };\n\n        final String listenerId = map.addEntryListener(listener, includeValues);\n        listeners.add(listenerId);\n        logger.debug(\"Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'\", includeValues, includeEventsFromLocalNode, listenerId);\n        return listenerId;\n    }\n\n    @Override\n    public void removeClusteredCacheEntryListener(@Nonnull final String listenerId) {\n        logger.debug(\"Removing clustered cache entry listener: '{}'\", listenerId);\n        map.removeEntryListener(listenerId);\n        listeners.remove(listenerId);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    @Override\n    public V put(final K key, final V object) {\n        if (object == null) { return null; }\n        checkForPluginClassLoader(key);\n        checkForPluginClassLoader(object);\n        return map.put(key, object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        numberOfGets++;\n        return map.get(key);\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public int size() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return (int) (stats.getOwnedEntryCount() + stats.getBackupEntryCount());\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return map.entrySet();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> entries) {\n        map.putAll(entries);\n\n        // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.\n        entries.entrySet().stream().findAny().ifPresent(\n            e -> {\n                checkForPluginClassLoader(e.getKey());\n                checkForPluginClassLoader(e.getValue());\n            }\n        );\n    }\n\n    @Override\n    public Collection<V> values() {\n        return map.values();\n    }\n\n    @Override\n    public long getCacheHits() {\n        return map.getLocalMapStats().getHits();\n    }\n\n    @Override\n    public long getCacheMisses() {\n        final long hits = map.getLocalMapStats().getHits();\n        return numberOfGets > hits ? numberOfGets - hits : 0;\n    }\n\n    @Override\n    public int getCacheSize() {\n        return (int) getLongCacheSize();\n    }\n\n    @Override\n    public long getLongCacheSize() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();\n    }\n\n    @Override\n    public long getMaxCacheSize() {\n        return CacheFactory.getMaxCacheSize(getName());\n    }\n\n    @Override\n    public void setMaxCacheSize(int i) {\n        setMaxCacheSize((long) i);\n    }\n\n    @Override\n    public void setMaxCacheSize(final long maxSize) {\n        CacheFactory.setMaxSizeProperty(getName(), maxSize);\n    }\n\n    @Override\n    public long getMaxLifetime() {\n        return CacheFactory.getMaxCacheLifetime(getName());\n    }\n\n    @Override\n    public void setMaxLifetime(final long maxLifetime) {\n        CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);\n    }\n\n    void destroy() {\n        listeners.forEach(map::removeEntryListener);\n        map.destroy();\n    }\n\n    boolean lock(final K key, final long timeout) {\n        boolean result = true;\n        if (timeout < 0) {\n            map.lock(key);\n        } else if (timeout == 0) {\n            result = map.tryLock(key);\n        } else {\n            try {\n                result = map.tryLock(key, timeout, TimeUnit.MILLISECONDS);\n            } catch (final InterruptedException e) {\n                logger.error(\"Failed to get cluster lock\", e);\n                result = false;\n            }\n        }\n        return result;\n    }\n\n    void unlock(final K key) {\n        try {\n            map.unlock(key);\n        } catch (final IllegalMonitorStateException e) {\n            logger.error(\"Failed to release cluster lock\", e);\n        }\n    }\n\n    /**\n     * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause\n     * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected void checkForPluginClassLoader(final Object o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is loaded by {} has been added to the cache. \" +\n                \"This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.\",\n                o.getClass(), pluginName != null ? pluginName : \"a PluginClassLoader\");\n            lastPluginClassLoaderWarning = Instant.now();\n        }\n    }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: hazelcast 3.12.5->4.0.5. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap\n\nThe error is triggered in the following specific lines in the previous code:\nimport com.hazelcast.core.IMap;\nimport com.hazelcast.core.MapEvent;\nimport com.hazelcast.monitor.LocalMapStats;\n    final IMap<K, V> map;\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {\nwith the following error message:\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[20,26] cannot find symbol  symbol:   class IMap\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[21,26] cannot find symbol  symbol:   class MapEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[23,29] package com.hazelcast.monitor does not exist\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[58,11] cannot find symbol  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[74,55] cannot find symbol  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import com.hazelcast.core.IMap;\nimport com.hazelcast.core.MapEvent;\nimport com.hazelcast.monitor.LocalMapStats;\n    final IMap<K, V> map;\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {",
    "error_message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[20,26] cannot find symbol  symbol:   class IMap\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[21,26] cannot find symbol  symbol:   class MapEvent\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[23,29] package com.hazelcast.monitor does not exist\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[58,11] cannot find symbol  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCache.java:[74,55] cannot find symbol  symbol:   class IMap\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCache<K,V>",
    "api_diff": "-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap",
    "original_code": "/*\n * Copyright (C) 1999-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.core.EntryEvent;\nimport com.hazelcast.core.EntryListener;\nimport com.hazelcast.core.IMap;\nimport com.hazelcast.core.MapEvent;\nimport com.hazelcast.map.listener.MapListener;\nimport com.hazelcast.monitor.LocalMapStats;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusteredCacheEntryListener;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.container.PluginManager;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.annotation.Nonnull;\nimport java.io.Serializable;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * Clustered implementation of the Cache interface using Hazelcast.\n *\n */\npublic class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {\n\n    private final Logger logger;\n\n    private final Set<String> listeners = ConcurrentHashMap.newKeySet();\n\n    /**\n     * The map is used for distributed operations such as get, put, etc.\n     */\n    final IMap<K, V> map;\n    private String name;\n    private long numberOfGets = 0;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private Instant lastPluginClassLoaderWarning = Instant.EPOCH;\n    private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);\n\n    /**\n     * Create a new cache using the supplied named cache as the actual cache implementation\n     *\n     * @param name a name for the cache, which should be unique per vm.\n     * @param cache the cache implementation\n     */\n    protected ClusteredCache(final String name, final IMap<K, V> cache) {\n        this.map = cache;\n        this.name = name;\n        logger = LoggerFactory.getLogger(ClusteredCache.class.getName() + \"[cache: \"+name+\"]\");\n    }\n\n    void addEntryListener(final MapListener listener) {\n        listeners.add(map.addEntryListener(listener, false));\n    }\n\n    @Override\n    public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)\n    {\n        final EntryListener<K, V> listener = new EntryListener<K, V>() {\n            @Override\n            public void mapEvicted(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map evicted event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapEvicted(eventNodeId);\n                }\n            }\n\n            @Override\n            public void mapCleared(MapEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing map cleared event of node '{}'\", eventNodeId);\n                    clusteredCacheEntryListener.mapCleared(eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryUpdated(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry update event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryRemoved(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry removed event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryRemoved((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryEvicted(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry evicted event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);\n                }\n            }\n\n            @Override\n            public void entryAdded(EntryEvent event) {\n                if (includeEventsFromLocalNode || !event.getMember().localMember()) {\n                    final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());\n                    logger.trace(\"Processing entry added event of node '{}' for key '{}'\", eventNodeId, event.getKey());\n                    clusteredCacheEntryListener.entryAdded((K) event.getKey(), (V) event.getValue(), eventNodeId);\n                }\n            }\n        };\n\n        final String listenerId = map.addEntryListener(listener, includeValues);\n        listeners.add(listenerId);\n        logger.debug(\"Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'\", includeValues, includeEventsFromLocalNode, listenerId);\n        return listenerId;\n    }\n\n    @Override\n    public void removeClusteredCacheEntryListener(@Nonnull final String listenerId) {\n        logger.debug(\"Removing clustered cache entry listener: '{}'\", listenerId);\n        map.removeEntryListener(listenerId);\n        listeners.remove(listenerId);\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    @Override\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    @Override\n    public V put(final K key, final V object) {\n        if (object == null) { return null; }\n        checkForPluginClassLoader(key);\n        checkForPluginClassLoader(object);\n        return map.put(key, object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        numberOfGets++;\n        return map.get(key);\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return map.remove(key);\n    }\n\n    @Override\n    public void clear() {\n        map.clear();\n    }\n\n    @Override\n    public int size() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return (int) (stats.getOwnedEntryCount() + stats.getBackupEntryCount());\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return map.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return map.containsValue(value);\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return map.entrySet();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return map.keySet();\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> entries) {\n        map.putAll(entries);\n\n        // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.\n        entries.entrySet().stream().findAny().ifPresent(\n            e -> {\n                checkForPluginClassLoader(e.getKey());\n                checkForPluginClassLoader(e.getValue());\n            }\n        );\n    }\n\n    @Override\n    public Collection<V> values() {\n        return map.values();\n    }\n\n    @Override\n    public long getCacheHits() {\n        return map.getLocalMapStats().getHits();\n    }\n\n    @Override\n    public long getCacheMisses() {\n        final long hits = map.getLocalMapStats().getHits();\n        return numberOfGets > hits ? numberOfGets - hits : 0;\n    }\n\n    @Override\n    public int getCacheSize() {\n        return (int) getLongCacheSize();\n    }\n\n    @Override\n    public long getLongCacheSize() {\n        final LocalMapStats stats = map.getLocalMapStats();\n        return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();\n    }\n\n    @Override\n    public long getMaxCacheSize() {\n        return CacheFactory.getMaxCacheSize(getName());\n    }\n\n    @Override\n    public void setMaxCacheSize(int i) {\n        setMaxCacheSize((long) i);\n    }\n\n    @Override\n    public void setMaxCacheSize(final long maxSize) {\n        CacheFactory.setMaxSizeProperty(getName(), maxSize);\n    }\n\n    @Override\n    public long getMaxLifetime() {\n        return CacheFactory.getMaxCacheLifetime(getName());\n    }\n\n    @Override\n    public void setMaxLifetime(final long maxLifetime) {\n        CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);\n    }\n\n    void destroy() {\n        listeners.forEach(map::removeEntryListener);\n        map.destroy();\n    }\n\n    boolean lock(final K key, final long timeout) {\n        boolean result = true;\n        if (timeout < 0) {\n            map.lock(key);\n        } else if (timeout == 0) {\n            result = map.tryLock(key);\n        } else {\n            try {\n                result = map.tryLock(key, timeout, TimeUnit.MILLISECONDS);\n            } catch (final InterruptedException e) {\n                logger.error(\"Failed to get cluster lock\", e);\n                result = false;\n            }\n        }\n        return result;\n    }\n\n    void unlock(final K key) {\n        try {\n            map.unlock(key);\n        } catch (final IllegalMonitorStateException e) {\n            logger.error(\"Failed to release cluster lock\", e);\n        }\n    }\n\n    /**\n     * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause\n     * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected void checkForPluginClassLoader(final Object o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is loaded by {} has been added to the cache. \" +\n                \"This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.\",\n                o.getClass(), pluginName != null ? pluginName : \"a PluginClassLoader\");\n            lastPluginClassLoaderWarning = Instant.now();\n        }\n    }\n}\n",
    "project": "openfire-hazelcast-plugin",
    "libraryName": "hazelcast",
    "libraryGroupID": "com.hazelcast",
    "newVersion": "4.0.5",
    "previousVersion": "3.12.5",
    "breakingCommit": "2b4d49d68112941b8abb818549389709d8327963"
}