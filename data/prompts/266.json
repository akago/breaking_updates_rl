{
    "absolute_path_to_file_in_container": "/pdb/src/test/java/com/feedzai/commons/sql/abstraction/engine/impl/abs/EngineGeneralTest.java",
    "errors": [
        {
            "line_number": 181,
            "message": "[ERROR] /pdb/src/test/java/com/feedzai/commons/sql/abstraction/engine/impl/abs/EngineGeneralTest.java:[181,49] cannot access org.slf4j.spi.LoggingEventAware",
            "additional_info": "  class file for org.slf4j.spi.LoggingEventAware not found",
            "file_name": "EngineGeneralTest.java",
            "uid": "8ced97bb-84b7-5e5e-9435-4f065ae989bc"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nthe following client code fails: \n'''java\n/*\n * Copyright 2014 Feedzai\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.feedzai.commons.sql.abstraction.engine.impl.abs;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport com.feedzai.commons.sql.abstraction.ddl.AlterColumn;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumn;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumnType;\nimport com.feedzai.commons.sql.abstraction.ddl.DbEntity;\nimport com.feedzai.commons.sql.abstraction.ddl.Rename;\nimport com.feedzai.commons.sql.abstraction.dml.Expression;\nimport com.feedzai.commons.sql.abstraction.dml.K;\nimport com.feedzai.commons.sql.abstraction.dml.Query;\nimport com.feedzai.commons.sql.abstraction.dml.Truncate;\nimport com.feedzai.commons.sql.abstraction.dml.Update;\nimport com.feedzai.commons.sql.abstraction.dml.Values;\nimport com.feedzai.commons.sql.abstraction.dml.With;\nimport com.feedzai.commons.sql.abstraction.dml.dialect.Dialect;\nimport com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder;\nimport com.feedzai.commons.sql.abstraction.dml.result.ResultColumn;\nimport com.feedzai.commons.sql.abstraction.dml.result.ResultIterator;\nimport com.feedzai.commons.sql.abstraction.engine.AbstractDatabaseEngine;\nimport com.feedzai.commons.sql.abstraction.engine.ConnectionResetException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngine;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngineException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngineRuntimeException;\nimport com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseFactory;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseFactoryException;\nimport com.feedzai.commons.sql.abstraction.engine.MappedEntity;\nimport com.feedzai.commons.sql.abstraction.engine.NameAlreadyExistsException;\nimport com.feedzai.commons.sql.abstraction.engine.OperationNotSupportedRuntimeException;\nimport com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.BlobTest;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseConfiguration;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseTestUtil;\nimport com.feedzai.commons.sql.abstraction.entry.EntityEntry;\nimport com.google.common.collect.ImmutableSet;\nimport java.sql.SQLException;\nimport mockit.Expectations;\nimport mockit.Invocation;\nimport mockit.Mock;\nimport mockit.MockUp;\nimport mockit.Verifications;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.sql.Connection;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint.NOT_NULL;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BLOB;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BOOLEAN;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.CLOB;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.DOUBLE;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.INT;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.LONG;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.STRING;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.L;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.all;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.avg;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.between;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.caseWhen;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.cast;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.ceiling;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.coalesce;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.column;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.concat;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.count;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.createView;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbColumn;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbEntity;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbFk;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.delete;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.div;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dropPK;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.entry;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.eq;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.f;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.floor;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.in;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.k;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.like;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lit;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lower;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.max;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.min;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.mod;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.neq;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notBetween;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notIn;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.or;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.select;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stddev;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stringAgg;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.sum;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.table;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.udf;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.union;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.update;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.upper;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.values;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.with;\nimport static com.feedzai.commons.sql.abstraction.engine.EngineTestUtils.buildEntity;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.ENGINE;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.JDBC;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.PASSWORD;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.SCHEMA_POLICY;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.USERNAME;\nimport static com.feedzai.commons.sql.abstraction.util.StringUtils.quotize;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.junit.Assume.assumeFalse;\nimport static org.junit.Assume.assumeTrue;\n\n/**\n * @author Rui Vilao (rui.vilao@feedzai.com)\n * @since 2.0.0\n */\n@RunWith(Parameterized.class)\npublic class EngineGeneralTest {\n\n\n    private static final double DELTA = 1e-7;\n\n    protected DatabaseEngine engine;\n    protected Properties properties;\n\n    @Parameterized.Parameters\n    public static Collection<DatabaseConfiguration> data() throws Exception {\n        return DatabaseTestUtil.loadConfigurations();\n    }\n\n    @Parameterized.Parameter\n    public DatabaseConfiguration config;\n\n    @BeforeClass\n    public static void initStatic() {\n        ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);\n    }\n\n    @Before\n    public void init() throws DatabaseFactoryException {\n        properties = new Properties() {\n            {\n                setProperty(JDBC, config.jdbc);\n                setProperty(USERNAME, config.username);\n                setProperty(PASSWORD, config.password);\n                setProperty(ENGINE, config.engine);\n                setProperty(SCHEMA_POLICY, \"drop-create\");\n            }\n        };\n\n        engine = DatabaseFactory.getConnection(properties);\n    }\n\n    @After\n    public void cleanup() {\n        engine.close();\n    }\n\n    @Test\n    public void createEntityTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithTwoColumnsBeingPKTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityAlreadyExistsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException e) {\n            assertEquals(\"\", \"Entity 'TEST' is already defined\", e.getMessage());\n            throw e;\n        }\n    }\n\n    @Test\n    public void createUniqueIndexTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(true, \"COL4\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createIndexWithTwoColumnsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(\"COL4\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createTwoIndexesTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(\"COL4\")\n                .addIndex(\"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithTheSameNameButLowerCasedTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n\n        DbEntity entity2 = dbEntity()\n                .name(\"test\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity2);\n\n    }\n\n    @Test\n    public void createEntityWithSequencesTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithIndexesTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addIndex(\"COL4\")\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void insertWithControlledTransactionTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\").build();\n\n        engine.beginTransaction();\n\n        try {\n\n            engine.persist(\"TEST\", entry);\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void insertWithAutoCommitTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void insertWithControlledTransactionUsingSequenceTest() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry().set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.beginTransaction();\n\n        try {\n\n            engine.persist(\"TEST\", entry);\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 1, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void queryWithIteratorWithDataTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        Map<String, ResultColumn> res;\n        res = it.next();\n        assertNotNull(\"result is not null\", res);\n        assertTrue(\"COL1 exists\", res.containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 1, (int) res.get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", res.containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", res.get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", res.containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, res.get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", res.containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) res.get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", res.containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", res.get(\"COL5\").toString());\n\n        assertNull(\"no more data to consume?\", it.next());\n\n        assertTrue(\"result set is closed?\", it.isClosed());\n        assertNull(\"next on a closed result set must return null\", it.next());\n\n        // calling close on a closed result set has no effect.\n        it.close();\n    }\n\n    @Test\n    public void queryWithIteratorWithNoDataTest() throws Exception {\n        create5ColumnsEntity();\n\n        ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        assertNull(\"result is null\", it.next());\n\n        assertNull(\"no more data to consume?\", it.next());\n\n        assertTrue(\"result set is closed?\", it.isClosed());\n        assertNull(\"next on a closed result set must return null\", it.next());\n\n        // calling close on a closed result set has no effect.\n        it.close();\n    }\n\n    /**\n     * Tests that an iterator created in a try-with-resources' resource specification header is automatically closed\n     * once the block is exited from.\n     *\n     * @throws Exception If an unexpected error occurs.\n     *\n     * @since 2.1.12\n     */\n    @Test\n    public void queryWithIteratorInTryWithResources() throws Exception {\n        create5ColumnsEntity();\n\n        final EntityEntry entry = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        final ResultIterator resultIterator;\n        try (final ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")))) {\n\n            resultIterator = it;\n\n            assertFalse(\n                    \"Result iterator should not be closed before exiting try-with-resources block\",\n                    resultIterator.isClosed()\n            );\n        }\n\n        assertTrue(\n                \"Result iterator should be closed after exiting try-with-resources block\",\n                resultIterator.isClosed()\n        );\n    }\n\n    @Test\n    public void batchInsertTest() throws Exception {\n        create5ColumnsEntity();\n\n        engine.beginTransaction();\n\n        try {\n            EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                    .build();\n\n            engine.addBatch(\"TEST\", entry);\n\n            entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"COL3\", 3D).set(\"COL4\", 4L).set(\"COL5\", \"OLA\")\n                    .build();\n\n            engine.addBatch(\"TEST\", entry);\n\n            engine.flush();\n\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL1\").asc()));\n\n        // 1st\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n\n        // 2nd\n\n        assertTrue(\"COL1 exists\", query.get(1).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 3, (int) query.get(1).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(1).containsKey(\"COL2\"));\n        assertTrue(\"COL2 ok?\", query.get(1).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(1).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 3D, query.get(1).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(1).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 4L, (long) query.get(1).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(1).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"OLA\", query.get(1).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void batchInsertAutocommitTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.addBatch(\"TEST\", entry);\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"COL3\", 3D).set(\"COL4\", 4L).set(\"COL5\", \"OLA\")\n                .build();\n\n        engine.addBatch(\"TEST\", entry);\n\n        // autocommit set to true.\n        engine.flush();\n\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL1\").asc()));\n\n        // 1st\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n\n        // 2nd\n\n        assertTrue(\"COL1 exists\", query.get(1).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 3, (int) query.get(1).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(1).containsKey(\"COL2\"));\n        assertTrue(\"COL2 ok?\", query.get(1).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(1).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 3D, query.get(1).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(1).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 4L, (long) query.get(1).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(1).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"OLA\", query.get(1).get(\"COL5\").toString());\n    }\n\n    /**\n     * Tests that on a rollback situation, the prepared statement batches are cleared.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add batch to transaction and purposely fail to flush</li>\n     *     <li>Ensure the existence of the Exception and rollback transaction</li>\n     *     <li>Flush again successfully and ensure that the DB table doesn't have any rows</li>\n     * </ol>\n     *\n     * This is a regression test.\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     * @since 2.1.12\n     */\n    @Test\n    public void batchInsertRollback() throws DatabaseEngineException {\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .build();\n\n        new MockUp<AbstractDatabaseEngine>() {\n            @Mock\n            public synchronized void flush(final Invocation invocation) throws DatabaseEngineException {\n                if (latch.getCount() == 1) {\n                    throw new DatabaseEngineException(\"\");\n                }\n                invocation.proceed();\n            }\n        };\n\n        DatabaseEngineException expectedException = null;\n\n        engine.addEntity(entity);\n        engine.beginTransaction();\n\n        try {\n            final EntityEntry entry = entry().set(\"COL1\", 1).build();\n\n            engine.addBatch(\"TEST\", entry);\n            engine.flush();\n            fail(\"Was expecting the flush operation to fail\");\n        } catch (final DatabaseEngineException e) {\n            expectedException = e;\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        // Ensure we had an exception and therefore we didn't insert anything on the DB and that we cleared the batches.\n        assertNotNull(\"DB returned exception when flushing\", expectedException);\n\n        latch.countDown();\n        engine.beginTransaction();\n        engine.flush();\n        engine.commit();\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all())\n                                                                           .from(table(\"TEST\"))\n                                                                           .orderby(column(\"COL1\").asc()));\n\n        // Previously, we rolled back the transaction; now we are trying the flush an empty transaction.\n        // Therefore, we shouldn't have any rows on the table.\n        assertEquals(\"There are no rows on table TEST\", 0, query.size());\n    }\n\n    @Test\n    public void blobTest() throws DatabaseEngineException {\n        final double[] original = new double[]{5, 6, 7};\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n        EntityEntry entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", original)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        int i = 0;\n        for (double d : original) {\n            assertEquals(\"arrays are equal?\", d, query.get(0).get(\"COL2\").<double[]>toBlob()[i++], 0D);\n        }\n    }\n\n    @Test\n    public void limitNumberOfRowsTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(5));\n\n        assertEquals(\"number of rows ok?\", 5, query.size());\n    }\n\n    @Test\n    public void limitAndOffsetNumberOfRowsTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = offset, j = 0; i < offset + limit; i++, j++) {\n            assertEquals(\"Check correct row\", i, query.get(j).get(\"COL1\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void limitOffsetAndOrderNumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = offset, j = 0; i < offset + limit; i++, j++) {\n            assertEquals(\"Check correct row col1\", 19 - i, query.get(j).get(\"COL1\").toInt().intValue());\n            assertEquals(\"Check correct row col6\", i + 1, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void limitOffsetAndOrder2NumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .addColumn(\"COL3\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 0)\n                .set(\"COL2\", \"A\")\n                .set(\"COL3\", 6);\n        engine.persist(\"TEST\", entry.build());\n\n\n        entry.set(\"COL1\", 1);\n        entry.set(\"COL2\", \"B\");\n        entry.set(\"COL3\", 5);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 2);\n        entry.set(\"COL2\", \"C\");\n        entry.set(\"COL3\", 4);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 3);\n        entry.set(\"COL2\", \"D\");\n        entry.set(\"COL3\", 3);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 4);\n        entry.set(\"COL2\", \"E\");\n        entry.set(\"COL3\", 2);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 5);\n        entry.set(\"COL2\", \"F\");\n        entry.set(\"COL3\", 1);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 6);\n        entry.set(\"COL2\", \"G\");\n        entry.set(\"COL3\", 0);\n        engine.persist(\"TEST\", entry.build());\n\n        int limit = 2;\n        int offset = 3;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n\n        assertEquals(\"Check correct row col2\", \"D\", query.get(0).get(\"COL2\").toString());\n        assertEquals(\"Check correct row col2\", \"E\", query.get(1).get(\"COL2\").toString());\n\n        query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL2\").desc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n\n        assertEquals(\"Check correct row col2\", \"D\", query.get(0).get(\"COL2\").toString());\n        assertEquals(\"Check correct row col2\", \"C\", query.get(1).get(\"COL2\").toString());\n    }\n\n    @Test\n    public void offsetLessThanZero() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry.build());\n        }\n\n        int limit = 5;\n        int offset = -1;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = 0, j = 0; i < 5; i++, j++) {\n            assertEquals(\"Check correct row col1\", 19 - i, query.get(j).get(\"COL1\").toInt().intValue());\n            assertEquals(\"Check correct row col6\", i + 1, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void offsetBiggerThanSize() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 20;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 0, query.size());\n    }\n\n    @Test\n    public void limitZeroOrNegative() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 0;\n        int offset = 1;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 19, query.size());\n\n        limit = -1;\n        query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 19, query.size());\n    }\n\n    @Test\n    public void offsetOnlyNumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 2);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).offset(offset));\n        assertEquals(\"number of rows ok?\", 20 - offset, query.size());\n        for (int i = offset, j = 0; i < 20; i++, j++) {\n            assertEquals(\"Check correct row 1\", i, query.get(j).get(\"COL1\").toInt().intValue());\n        }\n\n        query = engine.query(select(all()).from(table(\"TEST\")).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", 20 - offset, query.size());\n        for (int i = offset, j = 0; i < 20; i++, j++) {\n            assertEquals(\"Check correct row 6\", offset + 1 + j, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void stddevTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(stddev(column(\"COL1\")).alias(\"STDDEV\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 3.0276503540974917D, query.get(0).get(\"STDDEV\").toDouble(), 0.0001D);\n    }\n\n    @Test\n    public void sumTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(sum(column(\"COL1\")).alias(\"SUM\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 45, (int) query.get(0).get(\"SUM\").toInt());\n    }\n\n    @Test\n    public void countTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(count(column(\"COL1\")).alias(\"COUNT\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 10, (int) query.get(0).get(\"COUNT\").toInt());\n    }\n\n    @Test\n    public void avgTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(avg(column(\"COL1\")).alias(\"AVG\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 4.5D, query.get(0).get(\"AVG\").toDouble(), 0);\n    }\n\n    @Test\n    public void maxTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(max(column(\"COL1\")).alias(\"MAX\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 9, (int) query.get(0).get(\"MAX\").toInt());\n    }\n\n    @Test\n    public void minTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(min(column(\"COL1\")).alias(\"MIN\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 0, (int) query.get(0).get(\"MIN\").toInt());\n    }\n\n    @Test\n    public void floorTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2.5D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(floor(column(\"COL3\")).alias(\"FLOOR\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 2.0, query.get(0).get(\"FLOOR\").toDouble(), DELTA);\n    }\n\n    @Test\n    public void ceilingTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2.5D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(ceiling(column(\"COL3\")).alias(\"CEILING\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 3.0, query.get(0).get(\"CEILING\").toDouble(), DELTA);\n    }\n\n    @Test\n    public void twoIntegerDivisionMustReturnADoubleTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", 2);\n\n        engine.persist(\"TEST\", ee\n                .build());\n\n        List<Map<String, ResultColumn>> query = engine.query(select(div(column(\"COL1\"), column(\"COL2\")).alias(\"DIV\")).from(table(\"TEST\")));\n\n        assertEquals(\"\", 0.5D, query.get(0).get(\"DIV\").toDouble(), 0);\n    }\n\n    @Test\n    public void selectWithoutFromTest() throws DatabaseEngineException {\n        List<Map<String, ResultColumn>> query = engine.query(select(k(1).alias(\"constant\")));\n\n        assertEquals(\"constant ok?\", 1, (int) query.get(0).get(\"constant\").toInt());\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNullNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(null)\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You have to define the entity name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNoNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You have to define the entity name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNameThatExceedsTheMaximumAllowedTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"0123456789012345678901234567891\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"Entity name '0123456789012345678901234567891' exceeds the maximum number of characters (30)\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithColumnThatDoesNotHaveNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"entname\")\n                .addColumn(\"\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"Column in entity 'entname' must have a name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithMoreThanOneAutoIncColumn() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"entname\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT, true)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You can only define one auto incremented column\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoIncTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        Long persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(1), persist);\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoInc2Test() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        Long persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(1), persist);\n\n        ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(2), persist);\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoIncWithTransactionTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        engine.beginTransaction();\n\n        try {\n            EntityEntry ee = entry()\n                    .set(\"COL2\", 2)\n                    .build();\n\n            Long persist = engine.persist(\"TEST\", ee);\n\n            assertEquals(\"ret ok?\", new Long(1), persist);\n\n            ee = entry()\n                    .set(\"COL2\", 2)\n                    .build();\n\n            persist = engine.persist(\"TEST\", ee);\n\n            assertEquals(\"ret ok?\", new Long(2), persist);\n\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n    }\n\n    /**\n     * Tests that when persisting an entity in table that does not contain any auto generated values, the\n     * {@link DatabaseEngine#persist(String, EntityEntry)} method returns {@code null}.\n     *\n     * @throws DatabaseEngineException If any error occurs.\n     */\n    @Test\n    public void getGeneratedKeysWithNoAutoIncTest() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n            .name(\"TEST\")\n            .addColumn(\"COL1\", STRING)\n            .addColumn(\"COL2\", STRING)\n            // Set the two columns as fields of primary key, so they belong to the generated keys.\n            .pkFields(ImmutableSet.of(\"COL1\", \"COL2\"))\n            .build();\n\n        this.engine.addEntity(entity);\n\n        final EntityEntry ee = entry()\n                .set(\"COL1\", \"VAL1\")\n                .set(\"COL2\", \"VAL2\")\n                .build();\n\n        assertThat(this.engine.persist(\"TEST\", ee))\n            .as(\"The auto generated value should be null!\")\n            .isNull();\n    }\n\n    /**\n     * Tests that when trying to add {@link DbEntity} with multiple columns with auto incremented values, the\n     * {@link DatabaseEngine#addEntity(DbEntity)} method throws a {@link DatabaseEngineException}.\n     */\n    @Test\n    public void addMultipleAutoIncColumnsTest() {\n        final DbEntity entity = dbEntity()\n            .name(\"TEST\")\n            .addColumn(\"COL1\", INT, true)\n            .addColumn(\"COL2\", INT, true)\n            .build();\n\n        assertThatCode(() -> this.engine.addEntity(entity))\n            .as(\"The DatabaseEngine should not allow to setup a DbEntity with multiple auto incremented columns\")\n            .isInstanceOf(DatabaseEngineException.class);\n\n    }\n\n    @Test\n    public void abortTransactionTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        engine.beginTransaction();\n        try {\n            EntityEntry ee = entry()\n                    .set(\"COL1\", 1)\n                    .set(\"COL2\", 2)\n                    .build();\n\n            engine.persist(\"TEST\", ee);\n\n            throw new Exception();\n        } catch (final Exception e) {\n            // ignore\n        } finally {\n            assertTrue(\"tx active?\", engine.isTransactionActive());\n\n            engine.rollback();\n\n            assertFalse(\"tx active?\", engine.isTransactionActive());\n\n            assertEquals(\"ret 0?\", 0, engine.query(select(all()).from(table(\"TEST\"))).size());\n        }\n    }\n\n    @Test\n    public void createEntityDropItAndCreateItAgainTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"USER\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n        DbEntity removeEntity = engine.removeEntity(\"USER\");\n\n        assertNotNull(removeEntity);\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void dropEntityThatDoesNotExistTest() {\n        DbEntity removeEntity = engine.removeEntity(\"TABLETHATDOESNOTEXIST\");\n\n        assertNull(removeEntity);\n    }\n\n    @Test\n    public void joinsTest() throws DatabaseEngineException {\n\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").innerJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\")\n                                        .innerJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                                        .innerJoin(table(\"ROLE\").alias(\"c\"), eq(column(\"b\", \"COL2\"), column(\"c\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").rightOuterJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").leftOuterJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n    }\n\n    @Test\n    public void joinATableWithQueryTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinAQueryWithATableTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"b\")\n                                        .innerJoin(\n                                                table(\"USER\").alias(\"a\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinTwoQueriesTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinThreeQueriesTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                                        .rightOuterJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"c\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"c\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    // unimplemented in CockroachDB: views do not currently support * expressions\n    // https://github.com/cockroachdb/cockroach/issues/10028\n    public void createAndDropViewTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.executeUpdate(\n                createView(\"VN\").as(select(all()).from(table(\"TEST\")))\n        );\n\n        engine.dropView(\"VN\");\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    // unimplemented in CockroachDB: views do not currently support * expressions\n    // https://github.com/cockroachdb/cockroach/issues/10028\n    public void createOrReplaceViewTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.executeUpdate(\n                createView(\"VN\").as(select(all()).from(table(\"TEST\"))).replace()\n        );\n\n        engine.dropView(\"VN\");\n    }\n\n    @Test\n    public void distinctTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all()).distinct()\n                        .from(table(\"TEST\"))\n        );\n    }\n\n    @Test\n    public void distinctAndLimitTogetherTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all()).distinct()\n                        .from(table(\"TEST\")).limit(2)\n        );\n    }\n\n    @Test\n    public void notEqualTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(neq(column(\"COL1\"), k(1)))\n        );\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with a value filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inTest() throws DatabaseEngineException {\n        runInClauseTest(in(column(\"COL1\"), L((k(1)))));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with SELECT filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inSelectTest() throws DatabaseEngineException {\n        runInClauseTest(in(\n                column(\"COL1\"),\n                select(column(\"COL1\")).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(1)))\n        ));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with values filters a row correctly,\n     * when many values are provided.\n     * <p>\n     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses\n     * 20000 values.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inManyValuesTest() throws DatabaseEngineException {\n        final List<Expression> numExprs = IntStream.rangeClosed(-19998, 1)\n                .mapToObj(SqlBuilder::k)\n                .collect(Collectors.toList());\n\n        runInClauseTest(in(column(\"COL1\"), L(numExprs)));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) (Expression, Expression) negated IN} clause\n     * with a value filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInTest() throws DatabaseEngineException {\n        runInClauseTest(notIn(column(\"COL1\"), L((k(2)))));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with SELECT filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInSelectTest() throws DatabaseEngineException {\n        runInClauseTest(notIn(\n                column(\"COL1\"),\n                select(column(\"COL1\")).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(2)))\n        ));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with a value filters a row\n     * correctly, when many values are provided.\n     * <p>\n     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses\n     * 20000 values.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInManyValuesTest() throws DatabaseEngineException {\n        final List<Expression> numExprs = IntStream.rangeClosed(2, 20001)\n                .mapToObj(SqlBuilder::k)\n                .collect(Collectors.toList());\n\n        runInClauseTest(notIn(column(\"COL1\"), L(numExprs)));\n    }\n\n    /**\n     * Common code to run IN clause tests.\n     * <p>\n     * This creates 2 entries in the database:\n     * <table>\n     *     <tr><td>COL1</td><td>COL5</td></tr>\n     *     <tr><td>1</td><td>s1</td></tr>\n     *     <tr><td>2</td><td>s2</td></tr>\n     * </table>\n     * <p>\n     * The verifications expect the provided {@code whereInExpression} to filter the entries such that only the first\n     * one is returned.\n     *\n     * @param whereInExpression The {@link Expression} to use in the WHERE clause of the query.\n     * @throws DatabaseEngineException If a DB error occurs.\n     */\n    private void runInClauseTest(final Expression whereInExpression) throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"s1\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"s2\").build());\n\n        final List<Map<String, ResultColumn>> results = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(whereInExpression)\n        );\n\n        assertThat(results)\n                .as(\"query should return only 1 result\")\n                .hasSize(1)\n                .element(0)\n                .as(\"result should have have value '1'\")\n                .extracting(result -> result.get(\"COL1\").toInt())\n                .isEqualTo(1);\n    }\n\n    @Test\n    public void booleanTrueComparisonTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry1 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry1, false);\n\n        EntityEntry entry2 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry2, false);\n\n        List<Map<String, ResultColumn>> rows = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(column(\"COL2\"), k(true))\n                        )\n        );\n\n        assertEquals(1, rows.size());\n    }\n\n    @Test\n    public void booleanFalseComparisonTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry1 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry1, false);\n\n        EntityEntry entry2 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry2, false);\n\n        List<Map<String, ResultColumn>> rows = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(column(\"COL2\"), k(false))\n                        )\n        );\n\n        assertEquals(1, rows.size());\n    }\n\n    @Test\n    public void coalesceTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(coalesce(column(\"COL2\"), k(false)), k(false))\n                        )\n        );\n    }\n\n    @Test\n    public void multipleCoalesceTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(coalesce(column(\"COL2\"), k(false), k(true)), k(false))\n                        )\n        );\n    }\n\n    @Test\n    public void betweenTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(column(\"COL1\"), k(1), k(2))\n                        )\n        );\n    }\n\n\n\n    @Test\n    public void testCast() throws DatabaseEngineException {\n\n        final Query query = select(\n                cast(k(\"22\"), INT).alias(\"int\"),\n                cast(k(22), STRING).alias(\"string\"),\n                cast(k(\"1\"), BOOLEAN).alias(\"bool\"),\n                cast(k(\"22\"), DOUBLE).alias(\"double\"),\n                cast(k(22), LONG).alias(\"long\")\n        );\n\n        final Map<String, ResultColumn> result = engine.query(query).get(0);\n\n        assertEquals(\"Result must be 22\", new Integer(22), result.get(\"int\").toInt());\n        assertEquals(\"Result must be '22'\", \"22\", result.get(\"string\").toString());\n        assertEquals(\"Result must be true\", true, result.get(\"bool\").toBoolean());\n        assertEquals(\"Result must be 22.0\", new Double(22), result.get(\"double\").toDouble());\n        assertEquals(\"Result must be 22\", new Long(22), result.get(\"long\").toLong());\n    }\n\n    @Test\n    public void testCastColumns() throws DatabaseEngineException {\n\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL_INT\", INT)\n                .addColumn(\"COL_STRING\", STRING)\n                .addColumn(\"COL_CAST_INT\", INT)\n                .addColumn(\"COL_CAST_STRING\", STRING)\n                .pkFields(\"COL_INT\")\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry()\n                .set(\"COL_INT\", 123)\n                .set(\"COL_STRING\", \"321\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        // test CAST when writing values\n        final Update update = update(table(\"TEST\"))\n                .set(eq(column(\"COL_CAST_INT\"), cast(k(\"3211\"), INT)),\n                        eq(column(\"COL_CAST_STRING\"), cast(k(1233), STRING)))\n                .where(eq(column(\"COL_INT\"), k(123)));\n\n        engine.executeUpdate(update);\n\n        // test CAST when reading values\n        Query query =\n                select(\n                        cast(column(\"COL_INT\"), STRING).alias(\"COL_INT_string\"),\n                        cast(column(\"COL_STRING\"), INT).alias(\"COL_STRING_int\"),\n                        column(\"COL_CAST_INT\"),\n                        column(\"COL_CAST_STRING\")\n                ).from(table(\"TEST\"));\n\n        Map<String, ResultColumn> result = engine.query(query).get(0);\n\n        assertEquals(\"The value of COL_INT cast to string must be '123'\", \"123\", result.get(\"COL_INT_string\").toString());\n        assertEquals(\"The value of COL_STRING cast to int must be 321\", new Integer(321), result.get(\"COL_STRING_int\").toInt());\n        assertEquals(\"The value of COL_CAST_INT must be 3211\", Integer.valueOf(3211), result.get(\"COL_CAST_INT\").toInt());\n        assertEquals(\"The value of COL_CAST_STRING must be '1233'\", \"1233\", result.get(\"COL_CAST_STRING\").toString());\n\n        /*\n         Until now the test only really checks if the CAST doesn't cause any errors because\n          - when writing values into the DB it automatically casts into the column data type\n          - when reading values from the DB, the test reads the results from the ResultColumn as the desired type\n         Even if we used a function, it is likely the DB would try to cast the parameters to the expected type.\n         To effectively test if CAST works, we need to check if DB sorting considers the column a string or a number.\n         */\n        entry = entry()\n                .set(\"COL_INT\", 1000)\n                .set(\"COL_STRING\", \"321000\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        query = select(column(\"COL_INT\")).from(table(\"TEST\")).orderby(column(\"COL_INT\"));\n        String firstResult = engine.query(query).get(0).get(\"COL_INT\").toString();\n        assertEquals(\"sorting should have considered the sort column as a number (123 < 1000)\", \"123\", firstResult);\n\n        query = select(column(\"COL_INT\"), cast(column(\"COL_INT\"), STRING).alias(\"COL_INT_string\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL_INT_string\"));\n        firstResult = engine.query(query).get(0).get(\"COL_INT\").toString();\n        assertEquals(\"sorting should have considered the sort column as a string (1000 < 123)\", \"1000\", firstResult);\n    }\n\n    /**\n     * Check if exception is thrown when trying to cast for an unsupported type.\n     *\n     * @throws DatabaseEngineException If something goes wrong executing the query.\n     */\n    @Test(expected = OperationNotSupportedRuntimeException.class)\n    public void testCastUnsupported() throws DatabaseEngineException {\n        engine.query(select(cast(k(\"22\"), BLOB)));\n    }\n\n    @Test\n    public void testWith() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with = with(\"friends\", select(all())\n                                                .from(table(\"TEST\")))\n                .then(\n                        select(column(\"COL5\").alias(\"name\"))\n                        .from(table(\"friends\"))\n                        .where(eq(column(\"COL1\"), k(1))));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", result.get(0).get(\"name\").toString());\n    }\n\n    @Test\n    public void testWithAll() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with =\n                with(\"friends\",\n                        select(all())\n                        .from(table(\"TEST\")))\n                .then(\n                        select(column(\"COL5\").alias(\"name\"))\n                        .from(table(\"friends\"))\n                        .orderby(column(\"COL5\")));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        assertEquals(\"Name must be 'ana'\", \"ana\", result.get(0).get(\"name\").toString());\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", result.get(1).get(\"name\").toString());\n        assertEquals(\"Name must be 'rita'\", \"rita\", result.get(2).get(\"name\").toString());\n        assertEquals(\"Name must be 'rui'\", \"rui\", result.get(3).get(\"name\").toString());\n    }\n\n    @Test\n    public void testWithMultiple() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with =\n                with(\"friendsA\",\n                        select(all())\n                        .from(table(\"TEST\"))\n                        .where(or(eq(column(\"COL1\"), k(1)), eq(column(\"COL1\"), k(2)))))\n\n                .andWith(\"friendsB\",\n                        select(all())\n                        .from(table(\"TEST\"))\n                        .where(or(eq(column(\"COL1\"), k(3)), eq(column(\"COL1\"), k(4)))))\n                .then(\n                        union(select(all()).from(table(\"friendsA\")),\n                              select(all()).from(table(\"friendsB\"))));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"Name must be 'ana'\", \"ana\", resultSorted.get(0));\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", resultSorted.get(1));\n        assertEquals(\"Name must be 'rita'\", \"rita\", resultSorted.get(2));\n        assertEquals(\"Name must be 'rui'\", \"rui\", resultSorted.get(3));\n    }\n\n    @Test\n    public void testCaseWhen() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\")).alias(\"case\"))\n                        .from(table(\"TEST\")));\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n    }\n\n    @Test\n    public void testCaseWhenElse() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\"))\n                               .otherwise(k(\"ROFL\")).alias(\"case\"))\n                        .from(table(\"TEST\"))\n        );\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(1).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(2).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n    }\n\n    @Test\n    public void testCaseMultipleWhenElse() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"pomme de terre\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\"))\n                                .when(eq(column(\"COL5\"), k(\"pomme de terre\")), k(\"KEK\"))\n                                .otherwise(k(\"ROFL\")).alias(\"case\"))\n                        .from(table(\"TEST\"))\n        );\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(1).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(2).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n        assertEquals(\"COL5 must be KEK\", \"KEK\", result.get(4).get(\"case\").toString());\n    }\n\n    @Test\n    public void testConcat() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(k(\".\"));\n\n        assertEquals(\"teste.teste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xpto.xpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xpto.xpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"teste.teste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terre.pomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatEmpty() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(k(\"\"));\n\n        assertEquals(\"testeteste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xptoxpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xptoxpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"testeteste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terrepomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatNullExpressions() throws DatabaseEngineException {\n        final Query query = select(concat(k(\",\"), k(\"lol\"), k(null), k(\"rofl\")).alias(\"concat\"));\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n        assertEquals(\"lol,rofl\", result.get(0).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatNullDelimiter() throws DatabaseEngineException {\n        final Query query = select(concat(k(null), k(\"lol\"), k(\"nop\"), k(\"rofl\")).alias(\"concat\"));\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n        assertEquals(\"lolnoprofl\", result.get(0).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatColumn() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(column(\"COL2\"));\n\n        assertEquals(\"testetesteteste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xptoxptoxpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xptoxptoxpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"testetesteteste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terrepomme de terrepomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    /**\n     * Runs a concat query on the test dataset, given a delimiter.\n     *\n     * @param delimiter the delimiter used in concat.\n     * @return the result set.\n     * @throws DatabaseEngineException if an issue when querying arises.\n     */\n    private List<Map<String, ResultColumn>> queryConcat(final Expression delimiter) throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .addColumn(\"COL3\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", \"teste\").set(\"COL3\", \"teste\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL2\", \"xpto\").set(\"COL3\", \"xpto\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL2\", \"xpto\").set(\"COL3\", \"xpto\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL2\", \"teste\").set(\"COL3\", \"teste\").build());\n        engine.persist(\n                \"TEST\",\n                entry().set(\"COL1\", 5).set(\"COL2\", \"pomme de terre\").set(\"COL3\", \"pomme de terre\").build()\n        );\n        engine.persist(\n                \"TEST\",\n                entry().set(\"COL1\", 6).set(\"COL2\", \"lol\").set(\"COL3\", null).build()\n        );\n\n        final Query query =\n                select(\n                        concat(delimiter, column(\"COL2\"), column(\"COL3\")).alias(\"concat\"))\n                .from(table(\"TEST\"));\n\n        return engine.query(query);\n    }\n\n    /**\n     * Reproduces an issue when using CASE ... WHEN expressions in SqlServer and MySql.\n     * <p>\n     * Since we don't have the type information for a column that is generated from the result of a WHEN expression,\n     * we need to rely on the user calling one of the ResultColumn.toXXX methods to understand what the user is\n     * expecting. In the case of ResultColumn.toBoolean(), we're first checking if the result is of boolean type,\n     * as happens normally when the driver knows that the column is of type boolean, but then we also try to parse the\n     * underlying database boolean representation. This is necessary because in WHEN expressions, the driver doesn't\n     * know the expected return type.\n     * <p>\n     * I also tried to fix this using {@code cast(1 as BIT)}, which seemed more appropriate because we would be hinting\n     * the driver about the type, but it's not possible to follow this approach in MySql because we cannot cast to\n     * tinyint(1), which is the native type for booleans in MySql.\n     *\n     * @throws DatabaseEngineException propagate\n     */\n    @Test\n    public void testCaseToBoolean() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", false).build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL5\", \"xpto\").build());\n\n        final Query query = select(\n                column(\"COL2\"),\n                caseWhen()\n                        .when(column(\"COL5\").isNotNull(), k(true))\n                        .otherwise(k(false))\n                        .alias(\"COL5_NOT_NULL\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL1\").asc());\n\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertFalse(\"COL2 should be false\", result.get(0).get(\"COL2\").toBoolean());\n        assertFalse(\"COL5_NOT_NULL should be false\", result.get(0).get(\"COL5_NOT_NULL\").toBoolean());\n        assertTrue(\"COL2 should be true\", result.get(1).get(\"COL2\").toBoolean());\n        assertTrue(\"COL5_NOT_NULL should be true\", result.get(1).get(\"COL5_NOT_NULL\").toBoolean());\n    }\n\n    @Test\n    public void testUnion() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"a\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"b\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"c\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"d\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"d\")\n                .build());\n\n        final String[] letters = new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"};\n        final Collection<Expression> queries = Arrays.stream(letters)\n                .map(literal ->\n                        select(column(\"COL5\"))\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL5\"), k(literal))))\n                .collect(Collectors.toList());\n\n        final Expression query = union(queries);\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertEquals(\"Must return 4 results due to distinct property\", 4, result.size());\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"COL5 must be a\", \"a\", resultSorted.get(0));\n        assertEquals(\"COL5 must be b\", \"b\", resultSorted.get(1));\n        assertEquals(\"COL5 must be c\", \"c\", resultSorted.get(2));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(3));\n    }\n\n    @Test\n    public void testUnionAll() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"a\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"b\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"c\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"d\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"d\")\n                .build());\n\n        final int[] ids = new int[] {1, 2, 3, 4, 5};\n        final Collection<Expression> queries = Arrays.stream(ids)\n                .mapToObj(literal ->\n                        select(column(\"COL5\"))\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL1\"), k(literal))))\n                .collect(Collectors.toList());\n\n        final Expression query = union(queries).all();\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertEquals(\"Must return 5 results\", 5, result.size());\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"COL5 must be a\", \"a\", resultSorted.get(0));\n        assertEquals(\"COL5 must be b\", \"b\", resultSorted.get(1));\n        assertEquals(\"COL5 must be c\", \"c\", resultSorted.get(2));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(3));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(4));\n    }\n\n    @Test\n    public void testValues() throws DatabaseEngineException {\n        final Values values =\n                values(\"id\", \"name\")\n                    .row(k(1), k(\"ana\"))\n                    .row(k(2), k(\"fred\"))\n                    .row(k(3), k(\"manuel\"))\n                    .row(k(4), k(\"rita\"));\n\n        final List<Map<String, ResultColumn>> result = engine.query(values);\n\n        final List<Integer> ids = result.stream()\n                .map(row -> row.get(\"id\").toInt())\n                .sorted()\n                .collect(Collectors.toList());\n\n        final List<String> names = result.stream()\n                .map(row -> row.get(\"name\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"id must be 1\", new Integer(1), ids.get(0));\n        assertEquals(\"id must be 2\", new Integer(2), ids.get(1));\n        assertEquals(\"id must be 3\", new Integer(3), ids.get(2));\n        assertEquals(\"id must be 4\", new Integer(4), ids.get(3));\n\n        assertEquals(\"name must be 'ana'\", \"ana\", names.get(0));\n        assertEquals(\"name must be 'fred'\", \"fred\", names.get(1));\n        assertEquals(\"name must be 'manuel'\", \"manuel\", names.get(2));\n        assertEquals(\"name must be 'rita'\", \"rita\", names.get(3));\n    }\n\n    @Test(expected = DatabaseEngineRuntimeException.class)\n    public void testValuesNoAliases() throws DatabaseEngineException {\n        final Values values =\n                values()\n                    .row(k(1), k(\"ana\"))\n                    .row(k(2), k(\"fred\"))\n                    .row(k(3), k(\"manuel\"))\n                    .row(k(4), k(\"rita\"));\n        try {\n            engine.query(values);\n        } catch (DatabaseEngineRuntimeException e) {\n            assertEquals(\"Values requires aliases to avoid ambiguous columns names.\", e.getMessage());\n            throw e;\n        }\n    }\n\n    @Test\n    public void testLargeValues() throws DatabaseEngineException {\n        final Values values = values(\"long\", \"uuid\");\n\n        for (int i = 0 ; i < 256 ; i++) {\n            values.row(k(ThreadLocalRandom.current().nextLong()),\n                    k(UUID.randomUUID().toString()));\n        }\n\n        // If it crashes, the test will fail.\n        engine.query(values);\n    }\n\n    @Test\n    public void betweenWithSelectTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(select(column(\"COL1\")).from(table(\"TEST\")).enclose(), k(1), k(2))\n                        )\n        );\n    }\n\n    @Test\n    public void betweenEnclosedTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(column(\"COL1\"), k(1), k(2)).enclose()\n                        )\n        );\n    }\n\n    @Test\n    public void notBetweenTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                notBetween(column(\"COL1\"), k(1), k(2)).enclose()\n                        )\n        );\n    }\n\n    @Test\n    public void modTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", INT)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry()\n                .set(\"COL1\", 12)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 5)\n                .set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(mod(column(\"COL1\"), column(\"COL4\")).alias(\"MODULO\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 2, (int) query.get(0).get(\"MODULO\").toInt());\n\n    }\n\n    @Test\n    public void subSelectTest() throws DatabaseEngineException {\n        List<Map<String, ResultColumn>> query = engine.query(\n                select(\n                        k(1000).alias(\"timestamp\"),\n                        column(\"sq_1\", \"one\").alias(\"first\"),\n                        column(\"sq_1\", \"two\").alias(\"second\"),\n                        column(\"sq_1\", \"three\").alias(\"third\"))\n                        .from(\n                                select(\n                                        k(1).alias(\"one\"),\n                                        k(2L).alias(\"two\"),\n                                        k(3.0).alias(\"three\")).alias(\"sq_1\")\n                        )\n        );\n\n        assertEquals(\"result ok?\", 1000, (long) query.get(0).get(\"timestamp\").toLong());\n        assertEquals(\"result ok?\", 1, (int) query.get(0).get(\"first\").toInt());\n        assertEquals(\"result ok?\", 2L, (long) query.get(0).get(\"second\").toLong());\n        assertEquals(\"result ok?\", 3.0, query.get(0).get(\"third\").toDouble(), 0.0);\n    }\n\n    @Test\n    public void update1ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\"))\n                        .set(eq(column(\"COL1\"), k(1)))\n        );\n    }\n\n    @Test\n    public void update2ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n        );\n    }\n\n    @Test\n    public void updateWithAliasTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\").alias(\"T\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n        );\n    }\n\n    @Test\n    public void updateWithWhereTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\").alias(\"T\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n                        .where(eq(column(\"COL1\"), k(5)))\n        );\n    }\n\n    @Test\n    public void updateFrom1ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        final DbEntity entity = dbEntity()\n                .name(\"TEST2\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"pomme de terre\")\n                                      .build());\n\n        engine.persist(\"TEST2\", entry().set(\"COL1\", 1).set(\"COL2\", \"update1\")\n                                      .build());\n        engine.persist(\"TEST2\", entry().set(\"COL1\", 5).set(\"COL2\", \"update2\")\n                                      .build());\n\n        final Update updateFrom =\n                update(table(\"TEST\"))\n                        .from(table(\"TEST2\"))\n                        .set(eq(column(\"COL5\"), column(\"TEST2\", \"COL2\")))\n                        .where(eq(column(\"TEST\", \"COL1\"), column(\"TEST2\", \"COL1\")));\n\n        engine.executeUpdate(updateFrom);\n\n        // check to see if TEST has changed\n        final Query query = select(column(\"COL5\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL1\"));\n\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        //check if only the 1st and the 5th were changed.\n        assertEquals(\"update1\", result.get(0).get(\"COL5\").toString());\n        assertEquals(\"xpto\", result.get(1).get(\"COL5\").toString());\n        assertEquals(\"xpto\", result.get(2).get(\"COL5\").toString());\n        assertEquals(\"teste\", result.get(3).get(\"COL5\").toString());\n        assertEquals(\"update2\", result.get(4).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void deleteTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                delete(table(\"TEST\"))\n        );\n    }\n\n    @Test\n    public void deleteWithWhereTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                delete(table(\"TEST\"))\n                        .where(eq(column(\"COL1\"), k(5)))\n        );\n    }\n\n    @Test\n    public void deleteCheckReturnTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 6)\n                .build());\n\n        int rowsDeleted = engine.executeUpdate(\n                delete(table(\"TEST\"))\n        );\n\n        assertEquals(2, rowsDeleted);\n    }\n\n    @Test\n    public void executePreparedStatementTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {\n        create5ColumnsEntity();\n\n        EntityEntry ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .build();\n\n        engine.persist(\"TEST\", ee);\n\n        String ec = engine.escapeCharacter();\n        engine.createPreparedStatement(\"test\", \"SELECT * FROM \" + quotize(\"TEST\", ec) + \" WHERE \" + quotize(\"COL1\", ec) + \" = ?\");\n        engine.setParameters(\"test\", 1);\n        engine.executePS(\"test\");\n        List<Map<String, ResultColumn>> res = engine.getPSResultSet(\"test\");\n\n        assertEquals(\"col1 ok?\", 1, (int) res.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", res.get(0).get(\"COL2\").toBoolean());\n    }\n\n    @Test\n    public void executePreparedStatementUpdateTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {\n        create5ColumnsEntity();\n\n        EntityEntry ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .build();\n\n        engine.persist(\"TEST\", ee);\n\n        engine.createPreparedStatement(\"test\", update(table(\"TEST\")).set(eq(column(\"COL1\"), lit(\"?\"))));\n        engine.setParameters(\"test\", 2);\n        engine.executePSUpdate(\"test\");\n\n        List<Map<String, ResultColumn>> res = engine.query(\"SELECT * FROM \" + quotize(\"TEST\", engine.escapeCharacter()));\n\n        assertEquals(\"col1 ok?\", 2, (int) res.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", res.get(0).get(\"COL2\").toBoolean());\n    }\n\n    @Test\n    public void metadataTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .addColumn(\"COL6\", BLOB)\n                        .build();\n\n        engine.addEntity(entity);\n\n        final Map<String, DbColumnType> metaMap = new LinkedHashMap<>();\n        metaMap.put(\"COL1\", INT);\n        metaMap.put(\"COL2\", BOOLEAN);\n        metaMap.put(\"COL3\", DOUBLE);\n        metaMap.put(\"COL4\", LONG);\n        metaMap.put(\"COL5\", STRING);\n        metaMap.put(\"COL6\", BLOB);\n\n        assertEquals(\"meta ok?\", metaMap, engine.getMetadata(\"TEST\"));\n    }\n\n    @Test\n    public void getMetadataOnATableThatDoesNotExistTest() throws DatabaseEngineException {\n        assertTrue(\"get metadata on table that does not exist is empty\", engine.getMetadata(\"TableThatDoesNotExist\").isEmpty());\n    }\n\n    @Test\n    public void testSqlInjection1() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS2\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")).where(eq(column(\"COL5\"), k(\"ADEUS' or 1 = 1 \" + engine.commentCharacter()))));\n\n        assertEquals(\"Testing sql injection\", 0, result.size());\n    }\n\n    @Test\n    public void testBlob() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", new BlobTest(1, \"name\"))\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(new BlobTest(1, \"name\"), result.get(0).get(\"COL2\").<BlobTest>toBlob());\n\n        BlobTest updBlob = new BlobTest(2, \"cenas\");\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(updBlob);\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"testBlob\", upd);\n\n        engine.setParameters(\"testBlob\", bos.toByteArray());\n\n        engine.executePSUpdate(\"testBlob\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updBlob, result.get(0).get(\"COL2\").<BlobTest>toBlob());\n    }\n\n    @Test\n    public void testBlobSettingWithIndexTest() throws Exception {\n        DbEntity entity = dbEntity().name(\"TEST\").addColumn(\"COL1\", STRING).addColumn(\"COL2\", BLOB)\n                .build();\n        engine.addEntity(entity);\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", new BlobTest(1, \"name\"))\n                .build();\n        engine.persist(\"TEST\", entry);\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(new BlobTest(1, \"name\"), result.get(0).get(\"COL2\").<BlobTest>toBlob());\n\n        BlobTest updBlob = new BlobTest(2, \"cenas\");\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(updBlob);\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n        engine.createPreparedStatement(\"testBlob\", upd);\n        engine.setParameter(\"testBlob\", 1, bos.toByteArray());\n        engine.executePSUpdate(\"testBlob\");\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updBlob, result.get(0).get(\"COL2\").<BlobTest>toBlob());\n    }\n\n    @Test\n    public void testBlobByteArray() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        // 10 mb\n        byte[] bb = new byte[1024 * 1024 * 10];\n        byte[] bb2 = new byte[1024 * 1024 * 10];\n        for (int i = 0; i < bb.length; i++) {\n            bb[i] = (byte) (Math.random() * 128);\n            bb2[i] = (byte) (Math.random() * 64);\n        }\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bb)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertArrayEquals(bb, result.get(0).get(\"COL2\").toBlob());\n\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(bb2);\n\n        engine.setParameters(\"upd\", bos.toByteArray());\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertArrayEquals(bb2, result.get(0).get(\"COL2\").toBlob());\n\n    }\n\n    @Test\n    public void testBlobString() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 4000; i++) {\n            sb.append(\"a\");\n        }\n\n        String bigString = sb.toString();\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bigString)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(bigString, result.get(0).get(\"COL2\").<String>toBlob());\n    }\n\n    @Test\n    public void testBlobJSON() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        String bigString = \"[{\\\"type\\\":\\\"placeholder\\\",\\\"conf\\\":{},\\\"row\\\":0,\\\"height\\\":280,\\\"width\\\":12}]\";\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bigString)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(bigString, result.get(0).get(\"COL2\").<String>toBlob());\n    }\n\n    @Test\n    public void addDropColumnWithDropCreateTest() throws DatabaseEngineException {\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"USER\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.addEntity(entity\n                .build());\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"USER\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        entity.removeColumn(\"USER\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity\n                .build());\n\n        // as the fields were removed the entity mapping ignores the fields.\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL3\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE);\n        engine.updateEntity(entity\n                .build());\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\").set(\"COL6\", new BlobTest(1, \"\")).set(\"COL7\", 2d)\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n\n    }\n\n    @Test\n    public void addDropColumnTest() throws Exception {\n        // First drop-create\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"USER\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.addEntity(entity.build());\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"USER\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        // Clone the connection with the create now.\n        final DatabaseEngine engine2 = this.engine.duplicate(new Properties() {\n            {\n                setProperty(SCHEMA_POLICY, \"create\");\n            }\n        }, true);\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n        entity.removeColumn(\"USER\");\n        entity.removeColumn(\"COL2\");\n        engine2.updateEntity(entity.build());\n\n        // as the fields were removed the entity mapping ignores the fields.\n        System.out.println(\"> \" + engine2.getMetadata(\"TEST\"));\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL3\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n\n        test = engine2.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE);\n        engine2.updateEntity(entity.build());\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\").set(\"COL6\", new BlobTest(1, \"\")).set(\"COL7\", 2d)\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n        test = engine2.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n\n    }\n\n    /**\n     * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a \"none\" schema policy\n     * still creates the in-memory {@link MappedEntity} with the prepared statements for the entities.\n     */\n    @Test\n    public void updateEntityNoneSchemaPolicyCreatesInMemoryPreparedStmtsTest() throws DatabaseEngineException, DatabaseFactoryException {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        properties.setProperty(SCHEMA_POLICY, \"none\");\n        DatabaseEngine schemaNoneEngine = DatabaseFactory.getConnection(properties);\n\n        EntityEntry entry = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1d)\n                .set(\"COL4\", 1L)\n                .set(\"COL5\", \"1\")\n                .build();\n\n        try {\n            schemaNoneEngine.persist(entity.getName(), entry);\n            fail(\"Should throw an exception if trying to persist an entity before calling addEntity/updateEntity a first time\");\n        } catch (final DatabaseEngineException e) {\n            assertTrue(\"Should fail because the entity is still unknown to this DatabaseEngine instance\",\n                e.getMessage().contains(\"Unknown entity\"));\n        }\n\n        schemaNoneEngine.updateEntity(entity);\n\n        assertTrue(\"DatabaseEngine should be aware of the entity even with a NONE schema policy.\", schemaNoneEngine.containsEntity(entity.getName()));\n\n        // Persist the entry and make sure it was successful\n        schemaNoneEngine.persist(entity.getName(), entry);\n        List<Map<String, ResultColumn>> result = schemaNoneEngine.query(select(all()).from(table(\"TEST\")));\n\n        assertEquals(\"There should be only one entry in the table.\", 1, result.size());\n\n        Map<String, ResultColumn> resultEntry = result.get(0);\n\n        assertEquals(\"COL1 was successfully inserted\", 1, resultEntry.get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL2 was successfully inserted\", true, resultEntry.get(\"COL2\").toBoolean());\n        assertEquals(\"COL3 was successfully inserted\", 1.0, resultEntry.get(\"COL3\").toDouble(), 0);\n        assertEquals(\"COL4 was successfully inserted\", 1L, resultEntry.get(\"COL4\").toLong().longValue());\n        assertEquals(\"COL5 was successfully inserted\", \"1\", resultEntry.get(\"COL5\").toString());\n    }\n\n    /**\n     * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a \"none\" schema policy\n     * doesn't execute DDL.\n     */\n    @Test\n    public void updateEntityNoneSchemaPolicyDoesntExecuteDDL() throws DatabaseFactoryException {\n        dropSilently(\"TEST\");\n\n        properties.setProperty(SCHEMA_POLICY, \"none\");\n        DatabaseEngine schemaNoneEngine = DatabaseFactory.getConnection(properties);\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        try {\n            schemaNoneEngine.updateEntity(entity);\n            schemaNoneEngine.query(select(all()).from(table(entity.getName())));\n            fail(\"Should have failed because updateEntity with schema policy NONE doesn't execute DDL\");\n        } catch (final DatabaseEngineException e) {\n            // Should fail because because updateEntity with schema policy NONE doesn't execute DDL\n        }\n    }\n\n    @Test\n    public void addDropColumnNonExistentDropCreateTest() throws DatabaseEngineException {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.updateEntity(entity.build());\n\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"COL3\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.removeColumn(\"COL3\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity\n                .build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE, DbColumnConstraint.NOT_NULL);\n        engine.updateEntity(entity\n                .build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n    }\n\n    @Test\n    public void addDropColumnNonExistentTest() throws Exception {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DatabaseEngine engine = this.engine.duplicate(new Properties() {\n            {\n                setProperty(SCHEMA_POLICY, \"create\");\n            }\n        }, true);\n\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.updateEntity(entity.build());\n\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"COL3\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.removeColumn(\"COL3\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity.build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE, DbColumnConstraint.NOT_NULL);\n        engine.updateEntity(entity.build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n    }\n\n    @Test\n    public void testInsertNullCLOB() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n        engine.addEntity(entity);\n\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        System.out.println(result.get(0).get(\"COL2\"));\n        assertNull(result.get(0).get(\"COL2\").toString());\n    }\n\n\n    @Test\n    public void testCLOB() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n        for (int x = 0; x < 500000; x++) {\n            sb.append(x);\n            sb1.append(x * 2);\n        }\n        String initialClob = sb.toString();\n        String updateClob = sb1.toString();\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", initialClob)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n\n\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(initialClob, result.get(0).get(\"COL2\").toString());\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        engine.setParameters(\"upd\", updateClob);\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updateClob, result.get(0).get(\"COL2\").toString());\n\n    }\n\n    @Test\n    public void testCLOBEncoding() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        String initialClob = \"\u00e1\u00e3\u00e7\";\n        String updateClob = \"\u00e1\u00e3\u00e7_\u00e1\u00e3\u00e7\";\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", initialClob)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(initialClob, result.get(0).get(\"COL2\").toString());\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        engine.setParameters(\"upd\", updateClob);\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updateClob, result.get(0).get(\"COL2\").toString());\n\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"MYTEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ent = entry().set(\"COL2\", \"CENAS1\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n        ent = entry().set(\"COL2\", \"CENAS2\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        ent = entry().set(\"COL2\", \"CENAS3\").set(\"COL1\", 3)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS5\").set(\"COL1\", 5)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n\n        ent = entry().set(\"COL2\", \"CENAS6\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        ent = entry().set(\"COL2\", \"CENAS7\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        final List<Map<String, ResultColumn>> query = engine.query(\"SELECT * FROM \" + quotize(\"MYTEST\", engine.escapeCharacter()));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            assertTrue(stringResultColumnMap.get(\"COL2\").toString().endsWith(stringResultColumnMap.get(\"COL1\").toString()));\n        }\n        engine.close();\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement2() throws Exception {\n        String APP_ID = \"APP_ID\";\n        DbColumn APP_ID_COLUMN = new DbColumn.Builder().name(APP_ID).type(INT).build();\n        String STM_TABLE = \"FDZ_APP_STREAM\";\n        String STM_ID = \"STM_ID\";\n        String STM_NAME = \"STM_NAME\";\n        DbEntity STREAM = dbEntity().name(STM_TABLE)\n                .addColumn(APP_ID_COLUMN)\n                .addColumn(STM_ID, INT, true)\n                .addColumn(STM_NAME, STRING, NOT_NULL)\n                .pkFields(STM_ID, APP_ID)\n                .build();\n\n        engine.addEntity(STREAM);\n\n        EntityEntry ent = entry().set(APP_ID, 1).set(STM_ID, 1).set(STM_NAME, \"NAME1\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 1).set(STM_NAME, \"NAME1\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 2).set(STM_NAME, \"NAME2\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 1).set(STM_ID, 10).set(STM_NAME, \"NAME10\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        ent = entry().set(APP_ID, 1).set(STM_ID, 2).set(STM_NAME, \"NAME11\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 11).set(STM_NAME, \"NAME11\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(STM_TABLE)));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            System.out.println(stringResultColumnMap);\n            assertTrue(\"Assert Stream Name with id\", stringResultColumnMap.get(STM_NAME).toString().endsWith(stringResultColumnMap.get(STM_ID).toString()));\n        }\n\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement3() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"MYTEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ent = entry().set(\"COL2\", \"CENAS1\").set(\"COL1\", 1)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS2\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n\n        ent = entry().set(\"COL2\", \"CENAS5\").set(\"COL1\", 5)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS6\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        final List<Map<String, ResultColumn>> query = engine.query(\"SELECT * FROM \" + quotize(\"MYTEST\", engine.escapeCharacter()));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            System.out.println(stringResultColumnMap);\n            assertTrue(stringResultColumnMap.get(\"COL2\").toString().endsWith(stringResultColumnMap.get(\"COL1\").toString()));\n        }\n        engine.close();\n    }\n\n    @Test\n    public void testTruncateTable() throws Exception {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        Truncate truncate = new Truncate(table(\"TEST\"));\n\n        engine.executeUpdate(truncate);\n\n        final List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertTrue(\"Test truncate query empty?\", test.isEmpty());\n\n    }\n\n    @Test\n    public void testRenameTables() throws Exception {\n        String oldName = \"TBL_OLD\";\n        String newName = \"TBL_NEW\";\n\n        // Drop tables for sanity.\n        dropSilently(oldName, newName);\n\n        // Create the \"old\" table.\n        DbEntity entity = dbEntity()\n                .name(oldName)\n                .addColumn(\"timestamp\", INT)\n                .build();\n        engine.addEntity(entity);\n        engine.persist(oldName, entry().set(\"timestamp\", 20)\n                .build());\n\n        // Rename it\n        Rename rename = new Rename(table(oldName), table(newName));\n        engine.executeUpdate(rename);\n\n        // Check whether the schema matches\n        final Map<String, DbColumnType> metaMap = new LinkedHashMap<>();\n        metaMap.put(\"timestamp\", INT);\n        assertEquals(\"Metamap ok?\", metaMap, engine.getMetadata(newName));\n\n        // Check the data\n        List<Map<String, ResultColumn>> resultSet = engine.query(select(all()).from(table(newName)));\n        assertEquals(\"Count ok?\", 1, resultSet.size());\n\n        assertEquals(\"Content ok?\", 20, (int) resultSet.get(0).get(\"timestamp\").toInt());\n\n        dropSilently(newName);\n    }\n\n    /**\n     * Drops a list of tables silently (i.e. if it fails, it will just keep on).\n     *\n     * @param tables The tables that we want to drop.\n     */\n    private void dropSilently(String... tables) {\n        for (String table : tables) {\n            try {\n                engine.dropEntity(dbEntity().name(table).build());\n            } catch (final Throwable e) {\n                // ignore\n            }\n        }\n    }\n\n    @Test\n    public void testLikeWithTransformation() throws Exception {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"tesTte\")\n                .build());\n\n        List<Map<String, ResultColumn>> query = engine.query(\n            select(all()).from(table(\"TEST\")).where(like(udf(\"lower\", column(\"COL5\")), k(\"%teste%\")))\n        );\n        assertEquals(3, query.size());\n        query = engine.query(select(all()).from(table(\"TEST\")).where(like(udf(\"lower\", column(\"COL5\")), k(\"%tt%\"))));\n        assertEquals(1, query.size());\n\n    }\n\n    @Test\n    public void createSequenceOnLongColumnTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG, true)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n        engine.addEntity(entity);\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"col1 ok?\", 1, (int) test.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", test.get(0).get(\"COL2\").toBoolean());\n        assertEquals(\"col4 ok?\", 1L, (long) test.get(0).get(\"COL4\").toLong());\n\n    }\n\n    @Test\n    public void insertWithNoAutoIncAndThatResumeTheAutoIncTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG, true)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n        engine.addEntity(entity);\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 1L, (long) test.get(0).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 2)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 2L, (long) test.get(1).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 3L, (long) test.get(2).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 4)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 4L, (long) test.get(3).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 5L, (long) test.get(4).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 6)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 6L, (long) test.get(5).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 7)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 7L, (long) test.get(6).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 8L, (long) test.get(7).get(\"COL4\").toLong());\n    }\n\n    /**\n     * Creates a {@link DbEntity} with 5 columns to be used in the tests.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the entity.\n     */\n    private void create5ColumnsEntity() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    /**\n     * Creates a {@link DbEntity} with 5 columns being the first the primary key to be used in the tests.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the entity.\n     */\n    private void create5ColumnsEntityWithPrimaryKey() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity().name(\"TEST\")\n                                          .addColumn(\"COL1\", INT)\n                                          .addColumn(\"COL2\", BOOLEAN)\n                                          .addColumn(\"COL3\", DOUBLE)\n                                          .addColumn(\"COL4\", LONG)\n                                          .addColumn(\"COL5\", STRING)\n                                          .pkFields(\"COL1\")\n                                          .build();\n\n        engine.addEntity(entity);\n    }\n\n    protected void userRolePermissionSchema() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"USER\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        entity = dbEntity()\n                .name(\"ROLE\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        entity = dbEntity()\n                .name(\"USER_ROLE\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .addFk(dbFk()\n                                .addColumn(\"COL1\")\n                                .referencedTable(\"USER\")\n                                .addReferencedColumn(\"COL1\")\n                                .build(),\n                        dbFk()\n                                .addColumn(\"COL2\")\n                                .referencedTable(\"ROLE\")\n                                .addReferencedColumn(\"COL1\")\n                                .build()\n                )\n                .pkFields(\"COL1\", \"COL2\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void testAndWhere() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(1))).andWhere(eq(column(\"COL5\"), k(\"teste\"))));\n\n        assertEquals(\"Resultset must have only one result\", 1, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testAndWhereMultiple() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                or(\n                                        eq(column(\"COL1\"), k(1)),\n                                        eq(column(\"COL1\"), k(4))\n                                )\n                        )\n                        .andWhere(\n                                or(\n                                        eq(column(\"COL5\"), k(\"teste\")),\n                                        eq(column(\"COL5\"), k(\"TESTE\"))\n                                )\n                        )\n        );\n\n        assertEquals(\"Resultset must have only one result\", 1, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testAndWhereMultipleCheckAndEnclosed() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                or(\n                                        eq(column(\"COL1\"), k(1)),\n                                        eq(column(\"COL1\"), k(4))\n                                )\n                        )\n                        .andWhere(\n                                or(\n                                        eq(column(\"COL5\"), k(\"teste\")),\n                                        eq(column(\"COL5\"), k(\"tesTte\"))\n                                )\n                        )\n        );\n\n        assertEquals(\"Resultset must have only one result\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n        assertEquals(\"COL1 must be 1\", 4, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"tesTte\", query.get(1).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testStringAgg() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TESTE,teste\", \"TESTE,teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE,tesTte\", \"TeStE,tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggDelimiter() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).delimiter(';').alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TESTE;teste\", \"TESTE;teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE;tesTte\", \"TeStE;tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggDistinct() throws DatabaseEngineException {\n        assumeTrue(\"This test is only valid for engines that support StringAggDistinct\",\n                this.engine.isStringAggDistinctCapable());\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).distinct().alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE,tesTte\", \"TeStE,tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggNotStrings() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL1\")).alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be 1,1\", \"1,1\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be 2,2\", \"2,2\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void dropPrimaryKeyWithOneColumnTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .pkFields(\"COL1\")\n                        .build();\n        engine.addEntity(entity);\n        engine.executeUpdate(dropPK(table(\"TEST\")));\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void dropPrimaryKeyWithTwoColumnsTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .pkFields(\"COL1\", \"COL4\")\n                        .build();\n        engine.addEntity(entity);\n        engine.executeUpdate(dropPK(table(\"TEST\")));\n    }\n\n    @Test\n    public void alterColumnWithConstraintTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n\n        engine.addEntity(entity);\n\n        engine.executeUpdate(new AlterColumn(table(\"TEST\"), new DbColumn.Builder().name(\"COL1\").type(DbColumnType.INT).addConstraint(DbColumnConstraint\n                .NOT_NULL)\n                .build()));\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void alterColumnToDifferentTypeTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n\n        engine.addEntity(entity);\n\n        engine.executeUpdate(new AlterColumn(table(\"TEST\"), dbColumn().name(\"COL1\").type(DbColumnType.STRING)\n                .build()));\n    }\n\n    @Test\n    public void createTableWithDefaultsTest() throws DatabaseEngineException, DatabaseFactoryException {\n        DbEntity.Builder entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT, new K(1))\n                        .addColumn(\"COL2\", BOOLEAN, new K(false))\n                        .addColumn(\"COL3\", DOUBLE, new K(2.2d))\n                        .addColumn(\"COL4\", LONG, new K(3L))\n                        .pkFields(\"COL1\");\n\n        engine.addEntity(entity.build());\n\n        final String ec = engine.escapeCharacter();\n        engine.executeUpdate(\"INSERT INTO \" + quotize(\"TEST\", ec) + \" (\" + quotize(\"COL1\", ec) + \") VALUES (10)\");\n\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"Check size of records\", 1, test.size());\n        Map<String, ResultColumn> record = test.get(0);\n        assertEquals(\"Check COL1\", 10, record.get(\"COL1\").toInt().intValue());\n        assertEquals(\"Check COL2\", false, record.get(\"COL2\").toBoolean());\n        assertEquals(\"Check COL3\", 2.2d, record.get(\"COL3\").toDouble(), 0);\n        assertEquals(\"Check COL4\", 3L, record.get(\"COL4\").toLong().longValue());\n\n\n        final DbEntity entity1 = entity\n                .addColumn(\"COL5\", STRING, new K(\"mantorras\"), NOT_NULL)\n                .addColumn(\"COL6\", BOOLEAN, new K(true), NOT_NULL)\n                .addColumn(\"COL7\", INT, new K(7), NOT_NULL)\n                .build();\n\n        final Properties propertiesCreate = new Properties();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            propertiesCreate.setProperty(prop.getKey().toString(), prop.getValue().toString());\n        }\n        propertiesCreate.setProperty(SCHEMA_POLICY, \"create\");\n\n        final DatabaseEngine connection2 = DatabaseFactory.getConnection(propertiesCreate);\n        connection2.updateEntity(entity1);\n\n        test = connection2.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"Check size of records\", 1, test.size());\n        record = test.get(0);\n        assertEquals(\"Check COL1\", 10, record.get(\"COL1\").toInt().intValue());\n        assertEquals(\"Check COL2\", false, record.get(\"COL2\").toBoolean());\n        assertEquals(\"Check COL3\", 2.2d, record.get(\"COL3\").toDouble(), 1e-9);\n        assertEquals(\"Check COL4\", 3L, record.get(\"COL4\").toLong().longValue());\n        assertEquals(\"Check COL5\", \"mantorras\", record.get(\"COL5\").toString());\n        assertEquals(\"Check COL6\", true, record.get(\"COL6\").toBoolean());\n        assertEquals(\"Check COL7\", 7, record.get(\"COL7\").toInt().intValue());\n        connection2.close();\n    }\n\n    @Test\n    public void defaultValueOnBooleanColumnsTest() throws DatabaseEngineException {\n        DbEntity.Builder entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT, new K(1))\n                        .addColumn(\"COL2\", BOOLEAN, new K(false), NOT_NULL)\n                        .addColumn(\"COL3\", DOUBLE, new K(2.2d))\n                        .addColumn(\"COL4\", LONG, new K(3L))\n                        .pkFields(\"COL1\");\n\n        engine.addEntity(entity.build());\n\n        engine.persist(\"TEST\", entry().build());\n        Map<String, ResultColumn> row = engine.query(select(all()).from(table(\"TEST\"))).get(0);\n\n        assertEquals(\"\", 1, row.get(\"COL1\").toInt().intValue());\n        assertFalse(\"\", row.get(\"COL2\").toBoolean());\n        assertEquals(\"\", 2.2d, row.get(\"COL3\").toDouble(), 0D);\n        assertEquals(\"\", 3L, row.get(\"COL4\").toLong().longValue());\n    }\n\n    @Test\n    public void upperTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"ola\").build());\n        assertEquals(\"text is uppercase\", \"OLA\", engine.query(select(upper(column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\").toString());\n    }\n\n    @Test\n    public void lowerTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"OLA\").build());\n        assertEquals(\"text is lowercase\", \"ola\", engine.query(select(lower(column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\").toString());\n    }\n\n    @Test\n    public void internalFunctionTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"OLA\").build());\n        assertEquals(\"text is uppercase\", \"ola\", engine.query(select(f(\"LOWER\", column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\")\n                .toString());\n    }\n\n    @Test\n    public void entityEntryHashcodeTest() {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id1\", \"val1\");\n        map.put(\"id2\", \"val2\");\n        map.put(\"id3\", \"val3\");\n        map.put(\"id4\", \"val4\");\n\n        EntityEntry entry = entry()\n                .set(map)\n                .build();\n\n        assertEquals(\"entry's hashCode() matches map's hashCode()\", map.hashCode(), entry.hashCode());\n    }\n\n    /**\n     * Tests that creating a {@link DatabaseEngine} using try-with-resources will close the engine\n     * (and thus the underlying connection to the database) once the block is exited from.\n     *\n     * @throws Exception if something goes wrong while checking if the connection of the engine is closed.\n     * @since 2.1.12\n     */\n    @Test\n    public void tryWithResourcesClosesEngine() throws Exception {\n        final AtomicReference<Connection> connReference = new AtomicReference<>();\n\n        try (final DatabaseEngine tryEngine = this.engine) {\n            connReference.set(tryEngine.getConnection());\n            assertFalse(\"close() method should not be called within the try-with-resources block, for an existing DatabaseEngine\",\n                    connReference.get().isClosed());\n        }\n\n        assertTrue(\"close() method should be called after exiting try-with-resources block, for an existing DatabaseEngine\",\n                connReference.get().isClosed());\n\n        try (final DatabaseEngine tryEngine = DatabaseFactory.getConnection(properties)) {\n            connReference.set(tryEngine.getConnection());\n            assertFalse(\"close() method should not be called within the try-with-resources block, for a DatabaseEngine created in the block\",\n                    connReference.get().isClosed());\n        }\n\n        assertTrue(\"close() method should be called after exiting try-with-resources block, for a DatabaseEngine created in the block\",\n                connReference.get().isClosed());\n\n    }\n\n    /**\n     * Test that closing a database engine a 'create-drop' policy with multiple entities closes all insert statements\n     * associated with each entity, regardless of the schema policy used.\n     *\n     * Each entity is associated with 3 prepared statements. This test ensures that 3 PSs per entity are closed.\n     *\n     * @throws DatabaseEngineException  If something goes wrong while adding an entity to the engine.\n     * @throws DatabaseFactoryException If the database engine class specified in the properties does not exist.\n     * @since 2.1.13\n     */\n    @Test\n    public void closingAnEngineUsingTheCreateDropPolicyShouldDropAllEntities()\n            throws DatabaseEngineException, DatabaseFactoryException {\n\n        // Force the schema policy to be 'create-drop'\n        properties.setProperty(SCHEMA_POLICY, \"create-drop\");\n        engine = DatabaseFactory.getConnection(properties);\n\n        engine.addEntity(buildEntity(\"ENTITY-1\"));\n        engine.addEntity(buildEntity(\"ENTITY-2\"));\n\n        // Force invocation counting to start here\n        new Expectations(engine) {};\n\n        engine.close();\n\n        new Verifications() {{\n            engine.dropEntity((DbEntity) any); times = 2;\n        }};\n\n    }\n\n    /**\n     * Assesses whether the current row count is incremented if the .next()/.nextResult()\n     * methods are called in the iterator.\n     *\n     * @throws DatabaseEngineException If a database access error happens.\n     */\n    @Test\n    public void doesRowCountIncrementTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        // Create 4 entries\n        for (int i = 0; i < 4; i++) {\n            engine.persist(\"TEST\", entry().set(\"COL1\", i).build());\n        }\n\n        final ResultIterator resultIterator = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        assertEquals(\"The current row count should be 0 if the iteration hasn't started\", 0, resultIterator.getCurrentRowCount());\n\n        // If the .next() method is called once then the current row count should be updated to 1\n        resultIterator.next();\n\n        assertEquals(\"The current row count is equal to 1\", 1,resultIterator.getCurrentRowCount());\n\n        // If for the same iterator the .nextResult() method is called 3 additional\n        // times then the current row count should be updated to 4\n        for(int i = 0; i < 3; i++) {\n            resultIterator.nextResult();\n        }\n\n        assertEquals(\"The current row count is equal to 4\", 4, resultIterator.getCurrentRowCount());\n    }\n\n    /**\n     * Tests that a {@link com.feedzai.commons.sql.abstraction.dml.K constant expression} with an enum value behaves\n     * as if the enum is a string (obtained from {@link Enum#name()}, both when persisting an entry and when using\n     * the enum value for filtering in a WHERE clause.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the test entity or persisting entries.\n     */\n    @Test\n    public void kEnumTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        // should fail here if enum is not supported, or it will just put garbage, which will be detected later\n        engine.persist(\"TEST\", entry().set(\"COL5\", TestEnum.TEST_ENUM_VAL).build());\n\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"something else\").build());\n\n        final List<Map<String, ResultColumn>> results = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL5\"), k(TestEnum.TEST_ENUM_VAL)))\n        );\n\n        assertThat(results)\n                .as(\"One (and only one) result expected.\")\n                .hasSize(1)\n                .element(0)\n                .extracting(element -> element.get(\"COL5\").toString())\n                .as(\"An enum value should be persisted as its string representation\")\n                .isEqualTo(TestEnum.TEST_ENUM_VAL.name());\n    }\n\n    /**\n     * Tests that when inserting duplicated entries in a table the right exception is returned.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add duplicated entries in a transaction and fail to persist</li>\n     *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>\n     * </ol>\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     */\n    @Test\n    public void insertDuplicateDBError() throws Exception {\n        create5ColumnsEntityWithPrimaryKey();\n\n        EntityEntry entry = entry().set(\"COL1\", 2)\n                                   .set(\"COL2\", false)\n                                   .set(\"COL3\", 2D)\n                                   .set(\"COL4\", 3L)\n                                   .set(\"COL5\", \"ADEUS\")\n                                   .build();\n\n        // Add the same entry twice (repeated value for COL1, id)\n        engine.persist(\"TEST\", entry);\n        assertThatCode(() -> engine.persist(\"TEST\", entry))\n                .as(\"Is unique constraint violation exception\")\n                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)\n                .as(\"Encapsulated exception is SQLException\")\n                .hasCauseInstanceOf(SQLException.class)\n                .hasMessage(\"Something went wrong persisting the entity [unique_constraint_violation]\");\n    }\n\n    /**\n     * Tests that on a duplicated batch entry situation the right exception is returned.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add duplicated batch entries to transaction and fail to flush</li>\n     *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>\n     * </ol>\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     */\n    @Test\n    public void batchInsertDuplicateDBError() throws DatabaseEngineException {\n        create5ColumnsEntityWithPrimaryKey();\n\n        EntityEntry entry = entry().set(\"COL1\", 2)\n                                   .set(\"COL2\", false)\n                                   .set(\"COL3\", 2D)\n                                   .set(\"COL4\", 3L)\n                                   .set(\"COL5\", \"ADEUS\")\n                                   .build();\n\n        // Add the same entry twice (repeated value for COL1, id)\n        engine.addBatch(\"TEST\", entry);\n        engine.addBatch(\"TEST\", entry);\n\n        // Flush the duplicated entries and check the exception\n        assertThatCode(() -> engine.flush())\n                .as(\"Is unique constraint violation exception\")\n                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)\n                .as(\"Encapsulated exception is SQLException\")\n                .hasCauseInstanceOf(SQLException.class)\n                .hasMessage(\"Something went wrong while flushing [unique_constraint_violation]\");\n    }\n\n    /**\n     * An enum for tests.\n     */\n    private enum TestEnum {\n        TEST_ENUM_VAL;\n\n        @Override\n        public String toString() {\n            return super.toString() + \" description\";\n        }\n    }\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n        ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);\nwith the following error message:\n[ERROR] /pdb/src/test/java/com/feedzai/commons/sql/abstraction/engine/impl/abs/EngineGeneralTest.java:[181,49] cannot access org.slf4j.spi.LoggingEventAware  class file for org.slf4j.spi.LoggingEventAware not found\nThe error is caused by a change in the API of the dependency: logback-classic 1.2.11->1.4.5. The new library version includes the following changes:\nFormat: element | nature | kind\norg.slf4j.Logger.makeLoggingEventBuilder | MUTATION | METHOD_NOW_FINAL\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the entire fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "        ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);",
    "error_message": "[ERROR] /pdb/src/test/java/com/feedzai/commons/sql/abstraction/engine/impl/abs/EngineGeneralTest.java:[181,49] cannot access org.slf4j.spi.LoggingEventAware  class file for org.slf4j.spi.LoggingEventAware not found",
    "api_diff": "Format: element | nature | kind\norg.slf4j.Logger.makeLoggingEventBuilder | MUTATION | METHOD_NOW_FINAL",
    "original_code": "/*\n * Copyright 2014 Feedzai\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.feedzai.commons.sql.abstraction.engine.impl.abs;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.Logger;\nimport com.feedzai.commons.sql.abstraction.ddl.AlterColumn;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumn;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint;\nimport com.feedzai.commons.sql.abstraction.ddl.DbColumnType;\nimport com.feedzai.commons.sql.abstraction.ddl.DbEntity;\nimport com.feedzai.commons.sql.abstraction.ddl.Rename;\nimport com.feedzai.commons.sql.abstraction.dml.Expression;\nimport com.feedzai.commons.sql.abstraction.dml.K;\nimport com.feedzai.commons.sql.abstraction.dml.Query;\nimport com.feedzai.commons.sql.abstraction.dml.Truncate;\nimport com.feedzai.commons.sql.abstraction.dml.Update;\nimport com.feedzai.commons.sql.abstraction.dml.Values;\nimport com.feedzai.commons.sql.abstraction.dml.With;\nimport com.feedzai.commons.sql.abstraction.dml.dialect.Dialect;\nimport com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder;\nimport com.feedzai.commons.sql.abstraction.dml.result.ResultColumn;\nimport com.feedzai.commons.sql.abstraction.dml.result.ResultIterator;\nimport com.feedzai.commons.sql.abstraction.engine.AbstractDatabaseEngine;\nimport com.feedzai.commons.sql.abstraction.engine.ConnectionResetException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngine;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngineException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseEngineRuntimeException;\nimport com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseFactory;\nimport com.feedzai.commons.sql.abstraction.engine.DatabaseFactoryException;\nimport com.feedzai.commons.sql.abstraction.engine.MappedEntity;\nimport com.feedzai.commons.sql.abstraction.engine.NameAlreadyExistsException;\nimport com.feedzai.commons.sql.abstraction.engine.OperationNotSupportedRuntimeException;\nimport com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.BlobTest;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseConfiguration;\nimport com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseTestUtil;\nimport com.feedzai.commons.sql.abstraction.entry.EntityEntry;\nimport com.google.common.collect.ImmutableSet;\nimport java.sql.SQLException;\nimport mockit.Expectations;\nimport mockit.Invocation;\nimport mockit.Mock;\nimport mockit.MockUp;\nimport mockit.Verifications;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.sql.Connection;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.UUID;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint.NOT_NULL;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BLOB;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BOOLEAN;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.CLOB;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.DOUBLE;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.INT;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.LONG;\nimport static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.STRING;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.L;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.all;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.avg;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.between;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.caseWhen;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.cast;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.ceiling;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.coalesce;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.column;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.concat;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.count;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.createView;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbColumn;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbEntity;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbFk;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.delete;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.div;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dropPK;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.entry;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.eq;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.f;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.floor;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.in;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.k;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.like;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lit;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lower;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.max;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.min;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.mod;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.neq;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notBetween;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notIn;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.or;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.select;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stddev;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stringAgg;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.sum;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.table;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.udf;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.union;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.update;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.upper;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.values;\nimport static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.with;\nimport static com.feedzai.commons.sql.abstraction.engine.EngineTestUtils.buildEntity;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.ENGINE;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.JDBC;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.PASSWORD;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.SCHEMA_POLICY;\nimport static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.USERNAME;\nimport static com.feedzai.commons.sql.abstraction.util.StringUtils.quotize;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatCode;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.junit.Assume.assumeFalse;\nimport static org.junit.Assume.assumeTrue;\n\n/**\n * @author Rui Vilao (rui.vilao@feedzai.com)\n * @since 2.0.0\n */\n@RunWith(Parameterized.class)\npublic class EngineGeneralTest {\n\n\n    private static final double DELTA = 1e-7;\n\n    protected DatabaseEngine engine;\n    protected Properties properties;\n\n    @Parameterized.Parameters\n    public static Collection<DatabaseConfiguration> data() throws Exception {\n        return DatabaseTestUtil.loadConfigurations();\n    }\n\n    @Parameterized.Parameter\n    public DatabaseConfiguration config;\n\n    @BeforeClass\n    public static void initStatic() {\n        ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);\n    }\n\n    @Before\n    public void init() throws DatabaseFactoryException {\n        properties = new Properties() {\n            {\n                setProperty(JDBC, config.jdbc);\n                setProperty(USERNAME, config.username);\n                setProperty(PASSWORD, config.password);\n                setProperty(ENGINE, config.engine);\n                setProperty(SCHEMA_POLICY, \"drop-create\");\n            }\n        };\n\n        engine = DatabaseFactory.getConnection(properties);\n    }\n\n    @After\n    public void cleanup() {\n        engine.close();\n    }\n\n    @Test\n    public void createEntityTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithTwoColumnsBeingPKTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityAlreadyExistsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException e) {\n            assertEquals(\"\", \"Entity 'TEST' is already defined\", e.getMessage());\n            throw e;\n        }\n    }\n\n    @Test\n    public void createUniqueIndexTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(true, \"COL4\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createIndexWithTwoColumnsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(\"COL4\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createTwoIndexesTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .addIndex(\"COL4\")\n                .addIndex(\"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithTheSameNameButLowerCasedTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity);\n\n        DbEntity entity2 = dbEntity()\n                .name(\"test\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\", \"COL3\")\n                .build();\n\n        engine.addEntity(entity2);\n\n    }\n\n    @Test\n    public void createEntityWithSequencesTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void createEntityWithIndexesTest() throws DatabaseEngineException {\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addIndex(\"COL4\")\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void insertWithControlledTransactionTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\").build();\n\n        engine.beginTransaction();\n\n        try {\n\n            engine.persist(\"TEST\", entry);\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void insertWithAutoCommitTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void insertWithControlledTransactionUsingSequenceTest() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry().set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.beginTransaction();\n\n        try {\n\n            engine.persist(\"TEST\", entry);\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 1, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void queryWithIteratorWithDataTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        Map<String, ResultColumn> res;\n        res = it.next();\n        assertNotNull(\"result is not null\", res);\n        assertTrue(\"COL1 exists\", res.containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 1, (int) res.get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", res.containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", res.get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", res.containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, res.get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", res.containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) res.get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", res.containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", res.get(\"COL5\").toString());\n\n        assertNull(\"no more data to consume?\", it.next());\n\n        assertTrue(\"result set is closed?\", it.isClosed());\n        assertNull(\"next on a closed result set must return null\", it.next());\n\n        // calling close on a closed result set has no effect.\n        it.close();\n    }\n\n    @Test\n    public void queryWithIteratorWithNoDataTest() throws Exception {\n        create5ColumnsEntity();\n\n        ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        assertNull(\"result is null\", it.next());\n\n        assertNull(\"no more data to consume?\", it.next());\n\n        assertTrue(\"result set is closed?\", it.isClosed());\n        assertNull(\"next on a closed result set must return null\", it.next());\n\n        // calling close on a closed result set has no effect.\n        it.close();\n    }\n\n    /**\n     * Tests that an iterator created in a try-with-resources' resource specification header is automatically closed\n     * once the block is exited from.\n     *\n     * @throws Exception If an unexpected error occurs.\n     *\n     * @since 2.1.12\n     */\n    @Test\n    public void queryWithIteratorInTryWithResources() throws Exception {\n        create5ColumnsEntity();\n\n        final EntityEntry entry = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        final ResultIterator resultIterator;\n        try (final ResultIterator it = engine.iterator(select(all()).from(table(\"TEST\")))) {\n\n            resultIterator = it;\n\n            assertFalse(\n                    \"Result iterator should not be closed before exiting try-with-resources block\",\n                    resultIterator.isClosed()\n            );\n        }\n\n        assertTrue(\n                \"Result iterator should be closed after exiting try-with-resources block\",\n                resultIterator.isClosed()\n        );\n    }\n\n    @Test\n    public void batchInsertTest() throws Exception {\n        create5ColumnsEntity();\n\n        engine.beginTransaction();\n\n        try {\n            EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                    .build();\n\n            engine.addBatch(\"TEST\", entry);\n\n            entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"COL3\", 3D).set(\"COL4\", 4L).set(\"COL5\", \"OLA\")\n                    .build();\n\n            engine.addBatch(\"TEST\", entry);\n\n            engine.flush();\n\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL1\").asc()));\n\n        // 1st\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n\n        // 2nd\n\n        assertTrue(\"COL1 exists\", query.get(1).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 3, (int) query.get(1).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(1).containsKey(\"COL2\"));\n        assertTrue(\"COL2 ok?\", query.get(1).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(1).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 3D, query.get(1).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(1).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 4L, (long) query.get(1).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(1).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"OLA\", query.get(1).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void batchInsertAutocommitTest() throws Exception {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.addBatch(\"TEST\", entry);\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"COL3\", 3D).set(\"COL4\", 4L).set(\"COL5\", \"OLA\")\n                .build();\n\n        engine.addBatch(\"TEST\", entry);\n\n        // autocommit set to true.\n        engine.flush();\n\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL1\").asc()));\n\n        // 1st\n        assertTrue(\"COL1 exists\", query.get(0).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 2, (int) query.get(0).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(0).containsKey(\"COL2\"));\n        assertFalse(\"COL2 ok?\", query.get(0).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(0).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 2D, query.get(0).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(0).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 3L, (long) query.get(0).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(0).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"ADEUS\", query.get(0).get(\"COL5\").toString());\n\n        // 2nd\n\n        assertTrue(\"COL1 exists\", query.get(1).containsKey(\"COL1\"));\n        assertEquals(\"COL1 ok?\", 3, (int) query.get(1).get(\"COL1\").toInt());\n\n        assertTrue(\"COL2 exists\", query.get(1).containsKey(\"COL2\"));\n        assertTrue(\"COL2 ok?\", query.get(1).get(\"COL2\").toBoolean());\n\n        assertTrue(\"COL3 exists\", query.get(1).containsKey(\"COL3\"));\n        assertEquals(\"COL3 ok?\", 3D, query.get(1).get(\"COL3\").toDouble(), 0);\n\n        assertTrue(\"COL4 exists\", query.get(1).containsKey(\"COL4\"));\n        assertEquals(\"COL4 ok?\", 4L, (long) query.get(1).get(\"COL4\").toLong());\n\n        assertTrue(\"COL5 exists\", query.get(1).containsKey(\"COL5\"));\n        assertEquals(\"COL5  ok?\", \"OLA\", query.get(1).get(\"COL5\").toString());\n    }\n\n    /**\n     * Tests that on a rollback situation, the prepared statement batches are cleared.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add batch to transaction and purposely fail to flush</li>\n     *     <li>Ensure the existence of the Exception and rollback transaction</li>\n     *     <li>Flush again successfully and ensure that the DB table doesn't have any rows</li>\n     * </ol>\n     *\n     * This is a regression test.\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     * @since 2.1.12\n     */\n    @Test\n    public void batchInsertRollback() throws DatabaseEngineException {\n        final CountDownLatch latch = new CountDownLatch(1);\n\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .build();\n\n        new MockUp<AbstractDatabaseEngine>() {\n            @Mock\n            public synchronized void flush(final Invocation invocation) throws DatabaseEngineException {\n                if (latch.getCount() == 1) {\n                    throw new DatabaseEngineException(\"\");\n                }\n                invocation.proceed();\n            }\n        };\n\n        DatabaseEngineException expectedException = null;\n\n        engine.addEntity(entity);\n        engine.beginTransaction();\n\n        try {\n            final EntityEntry entry = entry().set(\"COL1\", 1).build();\n\n            engine.addBatch(\"TEST\", entry);\n            engine.flush();\n            fail(\"Was expecting the flush operation to fail\");\n        } catch (final DatabaseEngineException e) {\n            expectedException = e;\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n\n        // Ensure we had an exception and therefore we didn't insert anything on the DB and that we cleared the batches.\n        assertNotNull(\"DB returned exception when flushing\", expectedException);\n\n        latch.countDown();\n        engine.beginTransaction();\n        engine.flush();\n        engine.commit();\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all())\n                                                                           .from(table(\"TEST\"))\n                                                                           .orderby(column(\"COL1\").asc()));\n\n        // Previously, we rolled back the transaction; now we are trying the flush an empty transaction.\n        // Therefore, we shouldn't have any rows on the table.\n        assertEquals(\"There are no rows on table TEST\", 0, query.size());\n    }\n\n    @Test\n    public void blobTest() throws DatabaseEngineException {\n        final double[] original = new double[]{5, 6, 7};\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n        EntityEntry entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", original)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")));\n\n        int i = 0;\n        for (double d : original) {\n            assertEquals(\"arrays are equal?\", d, query.get(0).get(\"COL2\").<double[]>toBlob()[i++], 0D);\n        }\n    }\n\n    @Test\n    public void limitNumberOfRowsTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(5));\n\n        assertEquals(\"number of rows ok?\", 5, query.size());\n    }\n\n    @Test\n    public void limitAndOffsetNumberOfRowsTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = offset, j = 0; i < offset + limit; i++, j++) {\n            assertEquals(\"Check correct row\", i, query.get(j).get(\"COL1\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void limitOffsetAndOrderNumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = offset, j = 0; i < offset + limit; i++, j++) {\n            assertEquals(\"Check correct row col1\", 19 - i, query.get(j).get(\"COL1\").toInt().intValue());\n            assertEquals(\"Check correct row col6\", i + 1, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void limitOffsetAndOrder2NumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .addColumn(\"COL3\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 0)\n                .set(\"COL2\", \"A\")\n                .set(\"COL3\", 6);\n        engine.persist(\"TEST\", entry.build());\n\n\n        entry.set(\"COL1\", 1);\n        entry.set(\"COL2\", \"B\");\n        entry.set(\"COL3\", 5);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 2);\n        entry.set(\"COL2\", \"C\");\n        entry.set(\"COL3\", 4);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 3);\n        entry.set(\"COL2\", \"D\");\n        entry.set(\"COL3\", 3);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 4);\n        entry.set(\"COL2\", \"E\");\n        entry.set(\"COL3\", 2);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 5);\n        entry.set(\"COL2\", \"F\");\n        entry.set(\"COL3\", 1);\n        engine.persist(\"TEST\", entry.build());\n\n        entry.set(\"COL1\", 6);\n        entry.set(\"COL2\", \"G\");\n        entry.set(\"COL3\", 0);\n        engine.persist(\"TEST\", entry.build());\n\n        int limit = 2;\n        int offset = 3;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n\n        assertEquals(\"Check correct row col2\", \"D\", query.get(0).get(\"COL2\").toString());\n        assertEquals(\"Check correct row col2\", \"E\", query.get(1).get(\"COL2\").toString());\n\n        query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL2\").desc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n\n        assertEquals(\"Check correct row col2\", \"D\", query.get(0).get(\"COL2\").toString());\n        assertEquals(\"Check correct row col2\", \"C\", query.get(1).get(\"COL2\").toString());\n    }\n\n    @Test\n    public void offsetLessThanZero() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry.build());\n        }\n\n        int limit = 5;\n        int offset = -1;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", limit, query.size());\n        for (int i = 0, j = 0; i < 5; i++, j++) {\n            assertEquals(\"Check correct row col1\", 19 - i, query.get(j).get(\"COL1\").toInt().intValue());\n            assertEquals(\"Check correct row col6\", i + 1, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void offsetBiggerThanSize() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 5;\n        int offset = 20;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 0, query.size());\n    }\n\n    @Test\n    public void limitZeroOrNegative() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 20);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int limit = 0;\n        int offset = 1;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 19, query.size());\n\n        limit = -1;\n        query = engine.query(select(all()).from(table(\"TEST\")).limit(limit).offset(offset));\n        assertEquals(\"number of rows ok?\", 19, query.size());\n    }\n\n    @Test\n    public void offsetOnlyNumberOfRowsTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .addColumn(\"COL6\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\")\n                .set(\"COL6\", 2);\n\n        for (int i = 0; i < 20; i++) {\n            entry.set(\"COL1\", i);\n            entry.set(\"COL6\", 20 - i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        int offset = 7;\n        List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).offset(offset));\n        assertEquals(\"number of rows ok?\", 20 - offset, query.size());\n        for (int i = offset, j = 0; i < 20; i++, j++) {\n            assertEquals(\"Check correct row 1\", i, query.get(j).get(\"COL1\").toInt().intValue());\n        }\n\n        query = engine.query(select(all()).from(table(\"TEST\")).offset(offset).orderby(column(\"COL6\").asc()));\n        assertEquals(\"number of rows ok?\", 20 - offset, query.size());\n        for (int i = offset, j = 0; i < 20; i++, j++) {\n            assertEquals(\"Check correct row 6\", offset + 1 + j, query.get(j).get(\"COL6\").toInt().intValue());\n        }\n    }\n\n    @Test\n    public void stddevTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(stddev(column(\"COL1\")).alias(\"STDDEV\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 3.0276503540974917D, query.get(0).get(\"STDDEV\").toDouble(), 0.0001D);\n    }\n\n    @Test\n    public void sumTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(sum(column(\"COL1\")).alias(\"SUM\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 45, (int) query.get(0).get(\"SUM\").toInt());\n    }\n\n    @Test\n    public void countTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(count(column(\"COL1\")).alias(\"COUNT\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 10, (int) query.get(0).get(\"COUNT\").toInt());\n    }\n\n    @Test\n    public void avgTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(avg(column(\"COL1\")).alias(\"AVG\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 4.5D, query.get(0).get(\"AVG\").toDouble(), 0);\n    }\n\n    @Test\n    public void maxTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(max(column(\"COL1\")).alias(\"MAX\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 9, (int) query.get(0).get(\"MAX\").toInt());\n    }\n\n    @Test\n    public void minTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n        List<Map<String, ResultColumn>> query = engine.query(select(min(column(\"COL1\")).alias(\"MIN\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 0, (int) query.get(0).get(\"MIN\").toInt());\n    }\n\n    @Test\n    public void floorTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2.5D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(floor(column(\"COL3\")).alias(\"FLOOR\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 2.0, query.get(0).get(\"FLOOR\").toDouble(), DELTA);\n    }\n\n    @Test\n    public void ceilingTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry.Builder entry = entry()\n                .set(\"COL1\", 2)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2.5D)\n                .set(\"COL4\", 3L)\n                .set(\"COL5\", \"ADEUS\");\n\n        for (int i = 0; i < 10; i++) {\n            entry.set(\"COL1\", i);\n            engine.persist(\"TEST\", entry\n                    .build());\n        }\n\n        List<Map<String, ResultColumn>> query = engine.query(select(ceiling(column(\"COL3\")).alias(\"CEILING\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 3.0, query.get(0).get(\"CEILING\").toDouble(), DELTA);\n    }\n\n    @Test\n    public void twoIntegerDivisionMustReturnADoubleTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry.Builder ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", 2);\n\n        engine.persist(\"TEST\", ee\n                .build());\n\n        List<Map<String, ResultColumn>> query = engine.query(select(div(column(\"COL1\"), column(\"COL2\")).alias(\"DIV\")).from(table(\"TEST\")));\n\n        assertEquals(\"\", 0.5D, query.get(0).get(\"DIV\").toDouble(), 0);\n    }\n\n    @Test\n    public void selectWithoutFromTest() throws DatabaseEngineException {\n        List<Map<String, ResultColumn>> query = engine.query(select(k(1).alias(\"constant\")));\n\n        assertEquals(\"constant ok?\", 1, (int) query.get(0).get(\"constant\").toInt());\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNullNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(null)\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You have to define the entity name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNoNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You have to define the entity name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithNameThatExceedsTheMaximumAllowedTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"0123456789012345678901234567891\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"Entity name '0123456789012345678901234567891' exceeds the maximum number of characters (30)\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithColumnThatDoesNotHaveNameTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"entname\")\n                .addColumn(\"\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"Column in entity 'entname' must have a name\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test(expected = DatabaseEngineException.class)\n    public void createEntityWithMoreThanOneAutoIncColumn() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"entname\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT, true)\n                .build();\n\n        try {\n            engine.addEntity(entity);\n        } catch (final DatabaseEngineException de) {\n            assertEquals(\"exception ok?\", \"You can only define one auto incremented column\", de.getMessage());\n            throw de;\n        }\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoIncTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        Long persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(1), persist);\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoInc2Test() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        Long persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(1), persist);\n\n        ee = entry()\n                .set(\"COL2\", 2)\n                .build();\n\n        persist = engine.persist(\"TEST\", ee);\n\n        assertEquals(\"ret ok?\", new Long(2), persist);\n    }\n\n    @Test\n    public void getGeneratedKeysFromAutoIncWithTransactionTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        engine.beginTransaction();\n\n        try {\n            EntityEntry ee = entry()\n                    .set(\"COL2\", 2)\n                    .build();\n\n            Long persist = engine.persist(\"TEST\", ee);\n\n            assertEquals(\"ret ok?\", new Long(1), persist);\n\n            ee = entry()\n                    .set(\"COL2\", 2)\n                    .build();\n\n            persist = engine.persist(\"TEST\", ee);\n\n            assertEquals(\"ret ok?\", new Long(2), persist);\n\n            engine.commit();\n        } finally {\n            if (engine.isTransactionActive()) {\n                engine.rollback();\n            }\n        }\n    }\n\n    /**\n     * Tests that when persisting an entity in table that does not contain any auto generated values, the\n     * {@link DatabaseEngine#persist(String, EntityEntry)} method returns {@code null}.\n     *\n     * @throws DatabaseEngineException If any error occurs.\n     */\n    @Test\n    public void getGeneratedKeysWithNoAutoIncTest() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n            .name(\"TEST\")\n            .addColumn(\"COL1\", STRING)\n            .addColumn(\"COL2\", STRING)\n            // Set the two columns as fields of primary key, so they belong to the generated keys.\n            .pkFields(ImmutableSet.of(\"COL1\", \"COL2\"))\n            .build();\n\n        this.engine.addEntity(entity);\n\n        final EntityEntry ee = entry()\n                .set(\"COL1\", \"VAL1\")\n                .set(\"COL2\", \"VAL2\")\n                .build();\n\n        assertThat(this.engine.persist(\"TEST\", ee))\n            .as(\"The auto generated value should be null!\")\n            .isNull();\n    }\n\n    /**\n     * Tests that when trying to add {@link DbEntity} with multiple columns with auto incremented values, the\n     * {@link DatabaseEngine#addEntity(DbEntity)} method throws a {@link DatabaseEngineException}.\n     */\n    @Test\n    public void addMultipleAutoIncColumnsTest() {\n        final DbEntity entity = dbEntity()\n            .name(\"TEST\")\n            .addColumn(\"COL1\", INT, true)\n            .addColumn(\"COL2\", INT, true)\n            .build();\n\n        assertThatCode(() -> this.engine.addEntity(entity))\n            .as(\"The DatabaseEngine should not allow to setup a DbEntity with multiple auto incremented columns\")\n            .isInstanceOf(DatabaseEngineException.class);\n\n    }\n\n    @Test\n    public void abortTransactionTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        engine.beginTransaction();\n        try {\n            EntityEntry ee = entry()\n                    .set(\"COL1\", 1)\n                    .set(\"COL2\", 2)\n                    .build();\n\n            engine.persist(\"TEST\", ee);\n\n            throw new Exception();\n        } catch (final Exception e) {\n            // ignore\n        } finally {\n            assertTrue(\"tx active?\", engine.isTransactionActive());\n\n            engine.rollback();\n\n            assertFalse(\"tx active?\", engine.isTransactionActive());\n\n            assertEquals(\"ret 0?\", 0, engine.query(select(all()).from(table(\"TEST\"))).size());\n        }\n    }\n\n    @Test\n    public void createEntityDropItAndCreateItAgainTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"USER\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n        DbEntity removeEntity = engine.removeEntity(\"USER\");\n\n        assertNotNull(removeEntity);\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void dropEntityThatDoesNotExistTest() {\n        DbEntity removeEntity = engine.removeEntity(\"TABLETHATDOESNOTEXIST\");\n\n        assertNull(removeEntity);\n    }\n\n    @Test\n    public void joinsTest() throws DatabaseEngineException {\n\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").innerJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\")\n                                        .innerJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                                        .innerJoin(table(\"ROLE\").alias(\"c\"), eq(column(\"b\", \"COL2\"), column(\"c\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").rightOuterJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\").leftOuterJoin(table(\"USER_ROLE\").alias(\"b\"), eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\")))\n                        )\n        );\n    }\n\n    @Test\n    public void joinATableWithQueryTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                table(\"USER\").alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinAQueryWithATableTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"b\")\n                                        .innerJoin(\n                                                table(\"USER\").alias(\"a\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinTwoQueriesTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    public void joinThreeQueriesTest() throws DatabaseEngineException {\n        userRolePermissionSchema();\n\n        engine.query(\n                select(all())\n                        .from(\n                                select(column(\"COL1\"))\n                                        .from(table(\"USER\")).alias(\"a\")\n                                        .innerJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"b\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"b\", \"COL1\"))\n                                        )\n                                        .rightOuterJoin(\n                                                select(column(\"COL1\"))\n                                                        .from(table(\"USER\")).alias(\"c\")\n                                                , eq(column(\"a\", \"COL1\"), column(\"c\", \"COL1\"))\n                                        )\n                        )\n        );\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    // unimplemented in CockroachDB: views do not currently support * expressions\n    // https://github.com/cockroachdb/cockroach/issues/10028\n    public void createAndDropViewTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.executeUpdate(\n                createView(\"VN\").as(select(all()).from(table(\"TEST\")))\n        );\n\n        engine.dropView(\"VN\");\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    // unimplemented in CockroachDB: views do not currently support * expressions\n    // https://github.com/cockroachdb/cockroach/issues/10028\n    public void createOrReplaceViewTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.executeUpdate(\n                createView(\"VN\").as(select(all()).from(table(\"TEST\"))).replace()\n        );\n\n        engine.dropView(\"VN\");\n    }\n\n    @Test\n    public void distinctTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all()).distinct()\n                        .from(table(\"TEST\"))\n        );\n    }\n\n    @Test\n    public void distinctAndLimitTogetherTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all()).distinct()\n                        .from(table(\"TEST\")).limit(2)\n        );\n    }\n\n    @Test\n    public void notEqualTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(neq(column(\"COL1\"), k(1)))\n        );\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with a value filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inTest() throws DatabaseEngineException {\n        runInClauseTest(in(column(\"COL1\"), L((k(1)))));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with SELECT filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inSelectTest() throws DatabaseEngineException {\n        runInClauseTest(in(\n                column(\"COL1\"),\n                select(column(\"COL1\")).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(1)))\n        ));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with values filters a row correctly,\n     * when many values are provided.\n     * <p>\n     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses\n     * 20000 values.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void inManyValuesTest() throws DatabaseEngineException {\n        final List<Expression> numExprs = IntStream.rangeClosed(-19998, 1)\n                .mapToObj(SqlBuilder::k)\n                .collect(Collectors.toList());\n\n        runInClauseTest(in(column(\"COL1\"), L(numExprs)));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) (Expression, Expression) negated IN} clause\n     * with a value filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInTest() throws DatabaseEngineException {\n        runInClauseTest(notIn(column(\"COL1\"), L((k(2)))));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with SELECT filters a row correctly.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInSelectTest() throws DatabaseEngineException {\n        runInClauseTest(notIn(\n                column(\"COL1\"),\n                select(column(\"COL1\")).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(2)))\n        ));\n    }\n\n    /**\n     * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with a value filters a row\n     * correctly, when many values are provided.\n     * <p>\n     * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses\n     * 20000 values.\n     *\n     * @throws DatabaseEngineException If a DB error occurs, thus failing the test.\n     */\n    @Test\n    public void notInManyValuesTest() throws DatabaseEngineException {\n        final List<Expression> numExprs = IntStream.rangeClosed(2, 20001)\n                .mapToObj(SqlBuilder::k)\n                .collect(Collectors.toList());\n\n        runInClauseTest(notIn(column(\"COL1\"), L(numExprs)));\n    }\n\n    /**\n     * Common code to run IN clause tests.\n     * <p>\n     * This creates 2 entries in the database:\n     * <table>\n     *     <tr><td>COL1</td><td>COL5</td></tr>\n     *     <tr><td>1</td><td>s1</td></tr>\n     *     <tr><td>2</td><td>s2</td></tr>\n     * </table>\n     * <p>\n     * The verifications expect the provided {@code whereInExpression} to filter the entries such that only the first\n     * one is returned.\n     *\n     * @param whereInExpression The {@link Expression} to use in the WHERE clause of the query.\n     * @throws DatabaseEngineException If a DB error occurs.\n     */\n    private void runInClauseTest(final Expression whereInExpression) throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"s1\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"s2\").build());\n\n        final List<Map<String, ResultColumn>> results = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(whereInExpression)\n        );\n\n        assertThat(results)\n                .as(\"query should return only 1 result\")\n                .hasSize(1)\n                .element(0)\n                .as(\"result should have have value '1'\")\n                .extracting(result -> result.get(\"COL1\").toInt())\n                .isEqualTo(1);\n    }\n\n    @Test\n    public void booleanTrueComparisonTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry1 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry1, false);\n\n        EntityEntry entry2 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry2, false);\n\n        List<Map<String, ResultColumn>> rows = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(column(\"COL2\"), k(true))\n                        )\n        );\n\n        assertEquals(1, rows.size());\n    }\n\n    @Test\n    public void booleanFalseComparisonTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry1 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry1, false);\n\n        EntityEntry entry2 = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 1)\n                .set(\"COL4\", 1)\n                .set(\"COL5\", \"val 1\")\n                .build();\n        engine.persist(\"TEST\", entry2, false);\n\n        List<Map<String, ResultColumn>> rows = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(column(\"COL2\"), k(false))\n                        )\n        );\n\n        assertEquals(1, rows.size());\n    }\n\n    @Test\n    public void coalesceTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(coalesce(column(\"COL2\"), k(false)), k(false))\n                        )\n        );\n    }\n\n    @Test\n    public void multipleCoalesceTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                eq(coalesce(column(\"COL2\"), k(false), k(true)), k(false))\n                        )\n        );\n    }\n\n    @Test\n    public void betweenTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(column(\"COL1\"), k(1), k(2))\n                        )\n        );\n    }\n\n\n\n    @Test\n    public void testCast() throws DatabaseEngineException {\n\n        final Query query = select(\n                cast(k(\"22\"), INT).alias(\"int\"),\n                cast(k(22), STRING).alias(\"string\"),\n                cast(k(\"1\"), BOOLEAN).alias(\"bool\"),\n                cast(k(\"22\"), DOUBLE).alias(\"double\"),\n                cast(k(22), LONG).alias(\"long\")\n        );\n\n        final Map<String, ResultColumn> result = engine.query(query).get(0);\n\n        assertEquals(\"Result must be 22\", new Integer(22), result.get(\"int\").toInt());\n        assertEquals(\"Result must be '22'\", \"22\", result.get(\"string\").toString());\n        assertEquals(\"Result must be true\", true, result.get(\"bool\").toBoolean());\n        assertEquals(\"Result must be 22.0\", new Double(22), result.get(\"double\").toDouble());\n        assertEquals(\"Result must be 22\", new Long(22), result.get(\"long\").toLong());\n    }\n\n    @Test\n    public void testCastColumns() throws DatabaseEngineException {\n\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL_INT\", INT)\n                .addColumn(\"COL_STRING\", STRING)\n                .addColumn(\"COL_CAST_INT\", INT)\n                .addColumn(\"COL_CAST_STRING\", STRING)\n                .pkFields(\"COL_INT\")\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry()\n                .set(\"COL_INT\", 123)\n                .set(\"COL_STRING\", \"321\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        // test CAST when writing values\n        final Update update = update(table(\"TEST\"))\n                .set(eq(column(\"COL_CAST_INT\"), cast(k(\"3211\"), INT)),\n                        eq(column(\"COL_CAST_STRING\"), cast(k(1233), STRING)))\n                .where(eq(column(\"COL_INT\"), k(123)));\n\n        engine.executeUpdate(update);\n\n        // test CAST when reading values\n        Query query =\n                select(\n                        cast(column(\"COL_INT\"), STRING).alias(\"COL_INT_string\"),\n                        cast(column(\"COL_STRING\"), INT).alias(\"COL_STRING_int\"),\n                        column(\"COL_CAST_INT\"),\n                        column(\"COL_CAST_STRING\")\n                ).from(table(\"TEST\"));\n\n        Map<String, ResultColumn> result = engine.query(query).get(0);\n\n        assertEquals(\"The value of COL_INT cast to string must be '123'\", \"123\", result.get(\"COL_INT_string\").toString());\n        assertEquals(\"The value of COL_STRING cast to int must be 321\", new Integer(321), result.get(\"COL_STRING_int\").toInt());\n        assertEquals(\"The value of COL_CAST_INT must be 3211\", Integer.valueOf(3211), result.get(\"COL_CAST_INT\").toInt());\n        assertEquals(\"The value of COL_CAST_STRING must be '1233'\", \"1233\", result.get(\"COL_CAST_STRING\").toString());\n\n        /*\n         Until now the test only really checks if the CAST doesn't cause any errors because\n          - when writing values into the DB it automatically casts into the column data type\n          - when reading values from the DB, the test reads the results from the ResultColumn as the desired type\n         Even if we used a function, it is likely the DB would try to cast the parameters to the expected type.\n         To effectively test if CAST works, we need to check if DB sorting considers the column a string or a number.\n         */\n        entry = entry()\n                .set(\"COL_INT\", 1000)\n                .set(\"COL_STRING\", \"321000\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        query = select(column(\"COL_INT\")).from(table(\"TEST\")).orderby(column(\"COL_INT\"));\n        String firstResult = engine.query(query).get(0).get(\"COL_INT\").toString();\n        assertEquals(\"sorting should have considered the sort column as a number (123 < 1000)\", \"123\", firstResult);\n\n        query = select(column(\"COL_INT\"), cast(column(\"COL_INT\"), STRING).alias(\"COL_INT_string\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL_INT_string\"));\n        firstResult = engine.query(query).get(0).get(\"COL_INT\").toString();\n        assertEquals(\"sorting should have considered the sort column as a string (1000 < 123)\", \"1000\", firstResult);\n    }\n\n    /**\n     * Check if exception is thrown when trying to cast for an unsupported type.\n     *\n     * @throws DatabaseEngineException If something goes wrong executing the query.\n     */\n    @Test(expected = OperationNotSupportedRuntimeException.class)\n    public void testCastUnsupported() throws DatabaseEngineException {\n        engine.query(select(cast(k(\"22\"), BLOB)));\n    }\n\n    @Test\n    public void testWith() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with = with(\"friends\", select(all())\n                                                .from(table(\"TEST\")))\n                .then(\n                        select(column(\"COL5\").alias(\"name\"))\n                        .from(table(\"friends\"))\n                        .where(eq(column(\"COL1\"), k(1))));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", result.get(0).get(\"name\").toString());\n    }\n\n    @Test\n    public void testWithAll() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with =\n                with(\"friends\",\n                        select(all())\n                        .from(table(\"TEST\")))\n                .then(\n                        select(column(\"COL5\").alias(\"name\"))\n                        .from(table(\"friends\"))\n                        .orderby(column(\"COL5\")));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        assertEquals(\"Name must be 'ana'\", \"ana\", result.get(0).get(\"name\").toString());\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", result.get(1).get(\"name\").toString());\n        assertEquals(\"Name must be 'rita'\", \"rita\", result.get(2).get(\"name\").toString());\n        assertEquals(\"Name must be 'rui'\", \"rui\", result.get(3).get(\"name\").toString());\n    }\n\n    @Test\n    public void testWithMultiple() throws DatabaseEngineException {\n        assumeFalse(\"MySQL doesn't support WITH\", engine.getDialect() == Dialect.MYSQL);\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"manuel\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"ana\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"rita\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"rui\")\n                .build());\n\n        final With with =\n                with(\"friendsA\",\n                        select(all())\n                        .from(table(\"TEST\"))\n                        .where(or(eq(column(\"COL1\"), k(1)), eq(column(\"COL1\"), k(2)))))\n\n                .andWith(\"friendsB\",\n                        select(all())\n                        .from(table(\"TEST\"))\n                        .where(or(eq(column(\"COL1\"), k(3)), eq(column(\"COL1\"), k(4)))))\n                .then(\n                        union(select(all()).from(table(\"friendsA\")),\n                              select(all()).from(table(\"friendsB\"))));\n\n        final List<Map<String, ResultColumn>> result = engine.query(with);\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"Name must be 'ana'\", \"ana\", resultSorted.get(0));\n        assertEquals(\"Name must be 'manuel'\", \"manuel\", resultSorted.get(1));\n        assertEquals(\"Name must be 'rita'\", \"rita\", resultSorted.get(2));\n        assertEquals(\"Name must be 'rui'\", \"rui\", resultSorted.get(3));\n    }\n\n    @Test\n    public void testCaseWhen() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\")).alias(\"case\"))\n                        .from(table(\"TEST\")));\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n    }\n\n    @Test\n    public void testCaseWhenElse() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\"))\n                               .otherwise(k(\"ROFL\")).alias(\"case\"))\n                        .from(table(\"TEST\"))\n        );\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(1).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(2).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n    }\n\n    @Test\n    public void testCaseMultipleWhenElse() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"pomme de terre\")\n                .build());\n\n        List<Map<String, ResultColumn>> result = engine.query(\n                select(caseWhen().when(eq(column(\"COL5\"), k(\"teste\")), k(\"LOL\"))\n                                .when(eq(column(\"COL5\"), k(\"pomme de terre\")), k(\"KEK\"))\n                                .otherwise(k(\"ROFL\")).alias(\"case\"))\n                        .from(table(\"TEST\"))\n        );\n\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(0).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(1).get(\"case\").toString());\n        assertEquals(\"COL5 must be ROFL\", \"ROFL\", result.get(2).get(\"case\").toString());\n        assertEquals(\"COL5 must be LOL\", \"LOL\", result.get(3).get(\"case\").toString());\n        assertEquals(\"COL5 must be KEK\", \"KEK\", result.get(4).get(\"case\").toString());\n    }\n\n    @Test\n    public void testConcat() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(k(\".\"));\n\n        assertEquals(\"teste.teste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xpto.xpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xpto.xpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"teste.teste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terre.pomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatEmpty() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(k(\"\"));\n\n        assertEquals(\"testeteste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xptoxpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xptoxpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"testeteste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terrepomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatNullExpressions() throws DatabaseEngineException {\n        final Query query = select(concat(k(\",\"), k(\"lol\"), k(null), k(\"rofl\")).alias(\"concat\"));\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n        assertEquals(\"lol,rofl\", result.get(0).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatNullDelimiter() throws DatabaseEngineException {\n        final Query query = select(concat(k(null), k(\"lol\"), k(\"nop\"), k(\"rofl\")).alias(\"concat\"));\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n        assertEquals(\"lolnoprofl\", result.get(0).get(\"concat\").toString());\n    }\n\n    @Test\n    public void testConcatColumn() throws DatabaseEngineException {\n        final List<Map<String, ResultColumn>> result = queryConcat(column(\"COL2\"));\n\n        assertEquals(\"testetesteteste\", result.get(0).get(\"concat\").toString());\n        assertEquals(\"xptoxptoxpto\", result.get(1).get(\"concat\").toString());\n        assertEquals(\"xptoxptoxpto\", result.get(2).get(\"concat\").toString());\n        assertEquals(\"testetesteteste\", result.get(3).get(\"concat\").toString());\n        assertEquals(\"pomme de terrepomme de terrepomme de terre\", result.get(4).get(\"concat\").toString());\n    }\n\n    /**\n     * Runs a concat query on the test dataset, given a delimiter.\n     *\n     * @param delimiter the delimiter used in concat.\n     * @return the result set.\n     * @throws DatabaseEngineException if an issue when querying arises.\n     */\n    private List<Map<String, ResultColumn>> queryConcat(final Expression delimiter) throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .addColumn(\"COL3\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", \"teste\").set(\"COL3\", \"teste\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL2\", \"xpto\").set(\"COL3\", \"xpto\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL2\", \"xpto\").set(\"COL3\", \"xpto\").build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL2\", \"teste\").set(\"COL3\", \"teste\").build());\n        engine.persist(\n                \"TEST\",\n                entry().set(\"COL1\", 5).set(\"COL2\", \"pomme de terre\").set(\"COL3\", \"pomme de terre\").build()\n        );\n        engine.persist(\n                \"TEST\",\n                entry().set(\"COL1\", 6).set(\"COL2\", \"lol\").set(\"COL3\", null).build()\n        );\n\n        final Query query =\n                select(\n                        concat(delimiter, column(\"COL2\"), column(\"COL3\")).alias(\"concat\"))\n                .from(table(\"TEST\"));\n\n        return engine.query(query);\n    }\n\n    /**\n     * Reproduces an issue when using CASE ... WHEN expressions in SqlServer and MySql.\n     * <p>\n     * Since we don't have the type information for a column that is generated from the result of a WHEN expression,\n     * we need to rely on the user calling one of the ResultColumn.toXXX methods to understand what the user is\n     * expecting. In the case of ResultColumn.toBoolean(), we're first checking if the result is of boolean type,\n     * as happens normally when the driver knows that the column is of type boolean, but then we also try to parse the\n     * underlying database boolean representation. This is necessary because in WHEN expressions, the driver doesn't\n     * know the expected return type.\n     * <p>\n     * I also tried to fix this using {@code cast(1 as BIT)}, which seemed more appropriate because we would be hinting\n     * the driver about the type, but it's not possible to follow this approach in MySql because we cannot cast to\n     * tinyint(1), which is the native type for booleans in MySql.\n     *\n     * @throws DatabaseEngineException propagate\n     */\n    @Test\n    public void testCaseToBoolean() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", false).build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL5\", \"xpto\").build());\n\n        final Query query = select(\n                column(\"COL2\"),\n                caseWhen()\n                        .when(column(\"COL5\").isNotNull(), k(true))\n                        .otherwise(k(false))\n                        .alias(\"COL5_NOT_NULL\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL1\").asc());\n\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertFalse(\"COL2 should be false\", result.get(0).get(\"COL2\").toBoolean());\n        assertFalse(\"COL5_NOT_NULL should be false\", result.get(0).get(\"COL5_NOT_NULL\").toBoolean());\n        assertTrue(\"COL2 should be true\", result.get(1).get(\"COL2\").toBoolean());\n        assertTrue(\"COL5_NOT_NULL should be true\", result.get(1).get(\"COL5_NOT_NULL\").toBoolean());\n    }\n\n    @Test\n    public void testUnion() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"a\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"b\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"c\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"d\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"d\")\n                .build());\n\n        final String[] letters = new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"};\n        final Collection<Expression> queries = Arrays.stream(letters)\n                .map(literal ->\n                        select(column(\"COL5\"))\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL5\"), k(literal))))\n                .collect(Collectors.toList());\n\n        final Expression query = union(queries);\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertEquals(\"Must return 4 results due to distinct property\", 4, result.size());\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"COL5 must be a\", \"a\", resultSorted.get(0));\n        assertEquals(\"COL5 must be b\", \"b\", resultSorted.get(1));\n        assertEquals(\"COL5 must be c\", \"c\", resultSorted.get(2));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(3));\n    }\n\n    @Test\n    public void testUnionAll() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"a\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"b\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"c\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"d\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"d\")\n                .build());\n\n        final int[] ids = new int[] {1, 2, 3, 4, 5};\n        final Collection<Expression> queries = Arrays.stream(ids)\n                .mapToObj(literal ->\n                        select(column(\"COL5\"))\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL1\"), k(literal))))\n                .collect(Collectors.toList());\n\n        final Expression query = union(queries).all();\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        assertEquals(\"Must return 5 results\", 5, result.size());\n\n        final List<String> resultSorted = result.stream()\n                .map(row -> row.get(\"COL5\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"COL5 must be a\", \"a\", resultSorted.get(0));\n        assertEquals(\"COL5 must be b\", \"b\", resultSorted.get(1));\n        assertEquals(\"COL5 must be c\", \"c\", resultSorted.get(2));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(3));\n        assertEquals(\"COL5 must be d\", \"d\", resultSorted.get(4));\n    }\n\n    @Test\n    public void testValues() throws DatabaseEngineException {\n        final Values values =\n                values(\"id\", \"name\")\n                    .row(k(1), k(\"ana\"))\n                    .row(k(2), k(\"fred\"))\n                    .row(k(3), k(\"manuel\"))\n                    .row(k(4), k(\"rita\"));\n\n        final List<Map<String, ResultColumn>> result = engine.query(values);\n\n        final List<Integer> ids = result.stream()\n                .map(row -> row.get(\"id\").toInt())\n                .sorted()\n                .collect(Collectors.toList());\n\n        final List<String> names = result.stream()\n                .map(row -> row.get(\"name\").toString())\n                .sorted()\n                .collect(Collectors.toList());\n\n        assertEquals(\"id must be 1\", new Integer(1), ids.get(0));\n        assertEquals(\"id must be 2\", new Integer(2), ids.get(1));\n        assertEquals(\"id must be 3\", new Integer(3), ids.get(2));\n        assertEquals(\"id must be 4\", new Integer(4), ids.get(3));\n\n        assertEquals(\"name must be 'ana'\", \"ana\", names.get(0));\n        assertEquals(\"name must be 'fred'\", \"fred\", names.get(1));\n        assertEquals(\"name must be 'manuel'\", \"manuel\", names.get(2));\n        assertEquals(\"name must be 'rita'\", \"rita\", names.get(3));\n    }\n\n    @Test(expected = DatabaseEngineRuntimeException.class)\n    public void testValuesNoAliases() throws DatabaseEngineException {\n        final Values values =\n                values()\n                    .row(k(1), k(\"ana\"))\n                    .row(k(2), k(\"fred\"))\n                    .row(k(3), k(\"manuel\"))\n                    .row(k(4), k(\"rita\"));\n        try {\n            engine.query(values);\n        } catch (DatabaseEngineRuntimeException e) {\n            assertEquals(\"Values requires aliases to avoid ambiguous columns names.\", e.getMessage());\n            throw e;\n        }\n    }\n\n    @Test\n    public void testLargeValues() throws DatabaseEngineException {\n        final Values values = values(\"long\", \"uuid\");\n\n        for (int i = 0 ; i < 256 ; i++) {\n            values.row(k(ThreadLocalRandom.current().nextLong()),\n                    k(UUID.randomUUID().toString()));\n        }\n\n        // If it crashes, the test will fail.\n        engine.query(values);\n    }\n\n    @Test\n    public void betweenWithSelectTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(select(column(\"COL1\")).from(table(\"TEST\")).enclose(), k(1), k(2))\n                        )\n        );\n    }\n\n    @Test\n    public void betweenEnclosedTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                between(column(\"COL1\"), k(1), k(2)).enclose()\n                        )\n        );\n    }\n\n    @Test\n    public void notBetweenTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                notBetween(column(\"COL1\"), k(1), k(2)).enclose()\n                        )\n        );\n    }\n\n    @Test\n    public void modTest() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", INT)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry()\n                .set(\"COL1\", 12)\n                .set(\"COL2\", false)\n                .set(\"COL3\", 2D)\n                .set(\"COL4\", 5)\n                .set(\"COL5\", \"ADEUS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> query = engine.query(select(mod(column(\"COL1\"), column(\"COL4\")).alias(\"MODULO\")).from(table(\"TEST\")));\n\n        assertEquals(\"result ok?\", 2, (int) query.get(0).get(\"MODULO\").toInt());\n\n    }\n\n    @Test\n    public void subSelectTest() throws DatabaseEngineException {\n        List<Map<String, ResultColumn>> query = engine.query(\n                select(\n                        k(1000).alias(\"timestamp\"),\n                        column(\"sq_1\", \"one\").alias(\"first\"),\n                        column(\"sq_1\", \"two\").alias(\"second\"),\n                        column(\"sq_1\", \"three\").alias(\"third\"))\n                        .from(\n                                select(\n                                        k(1).alias(\"one\"),\n                                        k(2L).alias(\"two\"),\n                                        k(3.0).alias(\"three\")).alias(\"sq_1\")\n                        )\n        );\n\n        assertEquals(\"result ok?\", 1000, (long) query.get(0).get(\"timestamp\").toLong());\n        assertEquals(\"result ok?\", 1, (int) query.get(0).get(\"first\").toInt());\n        assertEquals(\"result ok?\", 2L, (long) query.get(0).get(\"second\").toLong());\n        assertEquals(\"result ok?\", 3.0, query.get(0).get(\"third\").toDouble(), 0.0);\n    }\n\n    @Test\n    public void update1ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\"))\n                        .set(eq(column(\"COL1\"), k(1)))\n        );\n    }\n\n    @Test\n    public void update2ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n        );\n    }\n\n    @Test\n    public void updateWithAliasTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\").alias(\"T\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n        );\n    }\n\n    @Test\n    public void updateWithWhereTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                update(table(\"TEST\").alias(\"T\"))\n                        .set(\n                                eq(column(\"COL1\"), k(1)),\n                                eq(column(\"COL5\"), k(\"ola\")))\n                        .where(eq(column(\"COL1\"), k(5)))\n        );\n    }\n\n    @Test\n    public void updateFrom1ColTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        final DbEntity entity = dbEntity()\n                .name(\"TEST2\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"xpto\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"xpto\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"teste\")\n                                      .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"pomme de terre\")\n                                      .build());\n\n        engine.persist(\"TEST2\", entry().set(\"COL1\", 1).set(\"COL2\", \"update1\")\n                                      .build());\n        engine.persist(\"TEST2\", entry().set(\"COL1\", 5).set(\"COL2\", \"update2\")\n                                      .build());\n\n        final Update updateFrom =\n                update(table(\"TEST\"))\n                        .from(table(\"TEST2\"))\n                        .set(eq(column(\"COL5\"), column(\"TEST2\", \"COL2\")))\n                        .where(eq(column(\"TEST\", \"COL1\"), column(\"TEST2\", \"COL1\")));\n\n        engine.executeUpdate(updateFrom);\n\n        // check to see if TEST has changed\n        final Query query = select(column(\"COL5\"))\n                .from(table(\"TEST\"))\n                .orderby(column(\"COL1\"));\n\n        final List<Map<String, ResultColumn>> result = engine.query(query);\n\n        //check if only the 1st and the 5th were changed.\n        assertEquals(\"update1\", result.get(0).get(\"COL5\").toString());\n        assertEquals(\"xpto\", result.get(1).get(\"COL5\").toString());\n        assertEquals(\"xpto\", result.get(2).get(\"COL5\").toString());\n        assertEquals(\"teste\", result.get(3).get(\"COL5\").toString());\n        assertEquals(\"update2\", result.get(4).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void deleteTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                delete(table(\"TEST\"))\n        );\n    }\n\n    @Test\n    public void deleteWithWhereTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        engine.executeUpdate(\n                delete(table(\"TEST\"))\n                        .where(eq(column(\"COL1\"), k(5)))\n        );\n    }\n\n    @Test\n    public void deleteCheckReturnTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 6)\n                .build());\n\n        int rowsDeleted = engine.executeUpdate(\n                delete(table(\"TEST\"))\n        );\n\n        assertEquals(2, rowsDeleted);\n    }\n\n    @Test\n    public void executePreparedStatementTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {\n        create5ColumnsEntity();\n\n        EntityEntry ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .build();\n\n        engine.persist(\"TEST\", ee);\n\n        String ec = engine.escapeCharacter();\n        engine.createPreparedStatement(\"test\", \"SELECT * FROM \" + quotize(\"TEST\", ec) + \" WHERE \" + quotize(\"COL1\", ec) + \" = ?\");\n        engine.setParameters(\"test\", 1);\n        engine.executePS(\"test\");\n        List<Map<String, ResultColumn>> res = engine.getPSResultSet(\"test\");\n\n        assertEquals(\"col1 ok?\", 1, (int) res.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", res.get(0).get(\"COL2\").toBoolean());\n    }\n\n    @Test\n    public void executePreparedStatementUpdateTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {\n        create5ColumnsEntity();\n\n        EntityEntry ee = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .build();\n\n        engine.persist(\"TEST\", ee);\n\n        engine.createPreparedStatement(\"test\", update(table(\"TEST\")).set(eq(column(\"COL1\"), lit(\"?\"))));\n        engine.setParameters(\"test\", 2);\n        engine.executePSUpdate(\"test\");\n\n        List<Map<String, ResultColumn>> res = engine.query(\"SELECT * FROM \" + quotize(\"TEST\", engine.escapeCharacter()));\n\n        assertEquals(\"col1 ok?\", 2, (int) res.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", res.get(0).get(\"COL2\").toBoolean());\n    }\n\n    @Test\n    public void metadataTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .addColumn(\"COL6\", BLOB)\n                        .build();\n\n        engine.addEntity(entity);\n\n        final Map<String, DbColumnType> metaMap = new LinkedHashMap<>();\n        metaMap.put(\"COL1\", INT);\n        metaMap.put(\"COL2\", BOOLEAN);\n        metaMap.put(\"COL3\", DOUBLE);\n        metaMap.put(\"COL4\", LONG);\n        metaMap.put(\"COL5\", STRING);\n        metaMap.put(\"COL6\", BLOB);\n\n        assertEquals(\"meta ok?\", metaMap, engine.getMetadata(\"TEST\"));\n    }\n\n    @Test\n    public void getMetadataOnATableThatDoesNotExistTest() throws DatabaseEngineException {\n        assertTrue(\"get metadata on table that does not exist is empty\", engine.getMetadata(\"TableThatDoesNotExist\").isEmpty());\n    }\n\n    @Test\n    public void testSqlInjection1() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        EntityEntry entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS\")\n                .build();\n        engine.persist(\"TEST\", entry);\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", false).set(\"COL3\", 2D).set(\"COL4\", 3L).set(\"COL5\", \"ADEUS2\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")).where(eq(column(\"COL5\"), k(\"ADEUS' or 1 = 1 \" + engine.commentCharacter()))));\n\n        assertEquals(\"Testing sql injection\", 0, result.size());\n    }\n\n    @Test\n    public void testBlob() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", new BlobTest(1, \"name\"))\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(new BlobTest(1, \"name\"), result.get(0).get(\"COL2\").<BlobTest>toBlob());\n\n        BlobTest updBlob = new BlobTest(2, \"cenas\");\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(updBlob);\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"testBlob\", upd);\n\n        engine.setParameters(\"testBlob\", bos.toByteArray());\n\n        engine.executePSUpdate(\"testBlob\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updBlob, result.get(0).get(\"COL2\").<BlobTest>toBlob());\n    }\n\n    @Test\n    public void testBlobSettingWithIndexTest() throws Exception {\n        DbEntity entity = dbEntity().name(\"TEST\").addColumn(\"COL1\", STRING).addColumn(\"COL2\", BLOB)\n                .build();\n        engine.addEntity(entity);\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", new BlobTest(1, \"name\"))\n                .build();\n        engine.persist(\"TEST\", entry);\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(new BlobTest(1, \"name\"), result.get(0).get(\"COL2\").<BlobTest>toBlob());\n\n        BlobTest updBlob = new BlobTest(2, \"cenas\");\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(updBlob);\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n        engine.createPreparedStatement(\"testBlob\", upd);\n        engine.setParameter(\"testBlob\", 1, bos.toByteArray());\n        engine.executePSUpdate(\"testBlob\");\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updBlob, result.get(0).get(\"COL2\").<BlobTest>toBlob());\n    }\n\n    @Test\n    public void testBlobByteArray() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        // 10 mb\n        byte[] bb = new byte[1024 * 1024 * 10];\n        byte[] bb2 = new byte[1024 * 1024 * 10];\n        for (int i = 0; i < bb.length; i++) {\n            bb[i] = (byte) (Math.random() * 128);\n            bb2[i] = (byte) (Math.random() * 64);\n        }\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bb)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertArrayEquals(bb, result.get(0).get(\"COL2\").toBlob());\n\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        final ObjectOutputStream oos = new ObjectOutputStream(bos);\n        oos.writeObject(bb2);\n\n        engine.setParameters(\"upd\", bos.toByteArray());\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertArrayEquals(bb2, result.get(0).get(\"COL2\").toBlob());\n\n    }\n\n    @Test\n    public void testBlobString() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < 4000; i++) {\n            sb.append(\"a\");\n        }\n\n        String bigString = sb.toString();\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bigString)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(bigString, result.get(0).get(\"COL2\").<String>toBlob());\n    }\n\n    @Test\n    public void testBlobJSON() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", BLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        String bigString = \"[{\\\"type\\\":\\\"placeholder\\\",\\\"conf\\\":{},\\\"row\\\":0,\\\"height\\\":280,\\\"width\\\":12}]\";\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", bigString)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(bigString, result.get(0).get(\"COL2\").<String>toBlob());\n    }\n\n    @Test\n    public void addDropColumnWithDropCreateTest() throws DatabaseEngineException {\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"USER\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.addEntity(entity\n                .build());\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"USER\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        entity.removeColumn(\"USER\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity\n                .build());\n\n        // as the fields were removed the entity mapping ignores the fields.\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL3\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine.persist(\"TEST\", entry);\n\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE);\n        engine.updateEntity(entity\n                .build());\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\").set(\"COL6\", new BlobTest(1, \"\")).set(\"COL7\", 2d)\n                .build();\n        engine.persist(\"TEST\", entry);\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n\n    }\n\n    @Test\n    public void addDropColumnTest() throws Exception {\n        // First drop-create\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"USER\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.addEntity(entity.build());\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"USER\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        // Clone the connection with the create now.\n        final DatabaseEngine engine2 = this.engine.duplicate(new Properties() {\n            {\n                setProperty(SCHEMA_POLICY, \"create\");\n            }\n        }, true);\n\n        EntityEntry entry = entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n        entity.removeColumn(\"USER\");\n        entity.removeColumn(\"COL2\");\n        engine2.updateEntity(entity.build());\n\n        // as the fields were removed the entity mapping ignores the fields.\n        System.out.println(\"> \" + engine2.getMetadata(\"TEST\"));\n        entry = entry().set(\"COL1\", 2).set(\"COL2\", true).set(\"COL3\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\")\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n\n        test = engine2.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE);\n        engine2.updateEntity(entity.build());\n\n        entry = entry().set(\"COL1\", 3).set(\"COL2\", true).set(\"USER\", 2d).set(\"COL4\", 1L).set(\"COL5\", \"c\").set(\"COL6\", new BlobTest(1, \"\")).set(\"COL7\", 2d)\n                .build();\n        engine2.persist(\"TEST\", entry);\n\n        test = engine2.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n\n    }\n\n    /**\n     * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a \"none\" schema policy\n     * still creates the in-memory {@link MappedEntity} with the prepared statements for the entities.\n     */\n    @Test\n    public void updateEntityNoneSchemaPolicyCreatesInMemoryPreparedStmtsTest() throws DatabaseEngineException, DatabaseFactoryException {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        properties.setProperty(SCHEMA_POLICY, \"none\");\n        DatabaseEngine schemaNoneEngine = DatabaseFactory.getConnection(properties);\n\n        EntityEntry entry = entry()\n                .set(\"COL1\", 1)\n                .set(\"COL2\", true)\n                .set(\"COL3\", 1d)\n                .set(\"COL4\", 1L)\n                .set(\"COL5\", \"1\")\n                .build();\n\n        try {\n            schemaNoneEngine.persist(entity.getName(), entry);\n            fail(\"Should throw an exception if trying to persist an entity before calling addEntity/updateEntity a first time\");\n        } catch (final DatabaseEngineException e) {\n            assertTrue(\"Should fail because the entity is still unknown to this DatabaseEngine instance\",\n                e.getMessage().contains(\"Unknown entity\"));\n        }\n\n        schemaNoneEngine.updateEntity(entity);\n\n        assertTrue(\"DatabaseEngine should be aware of the entity even with a NONE schema policy.\", schemaNoneEngine.containsEntity(entity.getName()));\n\n        // Persist the entry and make sure it was successful\n        schemaNoneEngine.persist(entity.getName(), entry);\n        List<Map<String, ResultColumn>> result = schemaNoneEngine.query(select(all()).from(table(\"TEST\")));\n\n        assertEquals(\"There should be only one entry in the table.\", 1, result.size());\n\n        Map<String, ResultColumn> resultEntry = result.get(0);\n\n        assertEquals(\"COL1 was successfully inserted\", 1, resultEntry.get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL2 was successfully inserted\", true, resultEntry.get(\"COL2\").toBoolean());\n        assertEquals(\"COL3 was successfully inserted\", 1.0, resultEntry.get(\"COL3\").toDouble(), 0);\n        assertEquals(\"COL4 was successfully inserted\", 1L, resultEntry.get(\"COL4\").toLong().longValue());\n        assertEquals(\"COL5 was successfully inserted\", \"1\", resultEntry.get(\"COL5\").toString());\n    }\n\n    /**\n     * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a \"none\" schema policy\n     * doesn't execute DDL.\n     */\n    @Test\n    public void updateEntityNoneSchemaPolicyDoesntExecuteDDL() throws DatabaseFactoryException {\n        dropSilently(\"TEST\");\n\n        properties.setProperty(SCHEMA_POLICY, \"none\");\n        DatabaseEngine schemaNoneEngine = DatabaseFactory.getConnection(properties);\n\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\")\n                .build();\n\n        try {\n            schemaNoneEngine.updateEntity(entity);\n            schemaNoneEngine.query(select(all()).from(table(entity.getName())));\n            fail(\"Should have failed because updateEntity with schema policy NONE doesn't execute DDL\");\n        } catch (final DatabaseEngineException e) {\n            // Should fail because because updateEntity with schema policy NONE doesn't execute DDL\n        }\n    }\n\n    @Test\n    public void addDropColumnNonExistentDropCreateTest() throws DatabaseEngineException {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.updateEntity(entity.build());\n\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"COL3\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.removeColumn(\"COL3\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity\n                .build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE, DbColumnConstraint.NOT_NULL);\n        engine.updateEntity(entity\n                .build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n    }\n\n    @Test\n    public void addDropColumnNonExistentTest() throws Exception {\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        DatabaseEngine engine = this.engine.duplicate(new Properties() {\n            {\n                setProperty(SCHEMA_POLICY, \"create\");\n            }\n        }, true);\n\n        DbEntity.Builder entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .pkFields(\"COL1\");\n        engine.updateEntity(entity.build());\n\n        Map<String, DbColumnType> test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(BOOLEAN, test.get(\"COL2\"));\n        assertEquals(DOUBLE, test.get(\"COL3\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.removeColumn(\"COL3\");\n        entity.removeColumn(\"COL2\");\n        engine.updateEntity(entity.build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n\n        dropSilently(\"TEST\");\n        engine.removeEntity(\"TEST\");\n\n        entity.addColumn(\"COL6\", BLOB).addColumn(\"COL7\", DOUBLE, DbColumnConstraint.NOT_NULL);\n        engine.updateEntity(entity.build());\n\n        test = engine.getMetadata(\"TEST\");\n        assertEquals(INT, test.get(\"COL1\"));\n        assertEquals(LONG, test.get(\"COL4\"));\n        assertEquals(STRING, test.get(\"COL5\"));\n        assertEquals(BLOB, test.get(\"COL6\"));\n        assertEquals(DOUBLE, test.get(\"COL7\"));\n    }\n\n    @Test\n    public void testInsertNullCLOB() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n        engine.addEntity(entity);\n\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\")\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        System.out.println(result.get(0).get(\"COL2\"));\n        assertNull(result.get(0).get(\"COL2\").toString());\n    }\n\n\n    @Test\n    public void testCLOB() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        StringBuilder sb = new StringBuilder();\n        StringBuilder sb1 = new StringBuilder();\n        for (int x = 0; x < 500000; x++) {\n            sb.append(x);\n            sb1.append(x * 2);\n        }\n        String initialClob = sb.toString();\n        String updateClob = sb1.toString();\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", initialClob)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n\n\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(initialClob, result.get(0).get(\"COL2\").toString());\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        engine.setParameters(\"upd\", updateClob);\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updateClob, result.get(0).get(\"COL2\").toString());\n\n    }\n\n    @Test\n    public void testCLOBEncoding() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", STRING)\n                .addColumn(\"COL2\", CLOB)\n                .build();\n\n        engine.addEntity(entity);\n\n        String initialClob = \"\u00e1\u00e3\u00e7\";\n        String updateClob = \"\u00e1\u00e3\u00e7_\u00e1\u00e3\u00e7\";\n\n        EntityEntry entry = entry().set(\"COL1\", \"CENINHAS\").set(\"COL2\", initialClob)\n                .build();\n\n        engine.persist(\"TEST\", entry);\n\n        List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(initialClob, result.get(0).get(\"COL2\").toString());\n\n        Update upd = update(table(\"TEST\")).set(eq(column(\"COL2\"), lit(\"?\"))).where(eq(column(\"COL1\"), k(\"CENINHAS\")));\n\n        engine.createPreparedStatement(\"upd\", upd);\n\n        engine.setParameters(\"upd\", updateClob);\n\n        engine.executePSUpdate(\"upd\");\n\n        result = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"CENINHAS\", result.get(0).get(\"COL1\").toString());\n        assertEquals(updateClob, result.get(0).get(\"COL2\").toString());\n\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"MYTEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ent = entry().set(\"COL2\", \"CENAS1\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n        ent = entry().set(\"COL2\", \"CENAS2\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        ent = entry().set(\"COL2\", \"CENAS3\").set(\"COL1\", 3)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS5\").set(\"COL1\", 5)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n\n        ent = entry().set(\"COL2\", \"CENAS6\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        ent = entry().set(\"COL2\", \"CENAS7\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        final List<Map<String, ResultColumn>> query = engine.query(\"SELECT * FROM \" + quotize(\"MYTEST\", engine.escapeCharacter()));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            assertTrue(stringResultColumnMap.get(\"COL2\").toString().endsWith(stringResultColumnMap.get(\"COL1\").toString()));\n        }\n        engine.close();\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement2() throws Exception {\n        String APP_ID = \"APP_ID\";\n        DbColumn APP_ID_COLUMN = new DbColumn.Builder().name(APP_ID).type(INT).build();\n        String STM_TABLE = \"FDZ_APP_STREAM\";\n        String STM_ID = \"STM_ID\";\n        String STM_NAME = \"STM_NAME\";\n        DbEntity STREAM = dbEntity().name(STM_TABLE)\n                .addColumn(APP_ID_COLUMN)\n                .addColumn(STM_ID, INT, true)\n                .addColumn(STM_NAME, STRING, NOT_NULL)\n                .pkFields(STM_ID, APP_ID)\n                .build();\n\n        engine.addEntity(STREAM);\n\n        EntityEntry ent = entry().set(APP_ID, 1).set(STM_ID, 1).set(STM_NAME, \"NAME1\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 1).set(STM_NAME, \"NAME1\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 2).set(STM_NAME, \"NAME2\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 1).set(STM_ID, 10).set(STM_NAME, \"NAME10\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        ent = entry().set(APP_ID, 1).set(STM_ID, 2).set(STM_NAME, \"NAME11\")\n                .build();\n        engine.persist(STM_TABLE, ent);\n\n        ent = entry().set(APP_ID, 2).set(STM_ID, 11).set(STM_NAME, \"NAME11\")\n                .build();\n        engine.persist(STM_TABLE, ent, false);\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(STM_TABLE)));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            System.out.println(stringResultColumnMap);\n            assertTrue(\"Assert Stream Name with id\", stringResultColumnMap.get(STM_NAME).toString().endsWith(stringResultColumnMap.get(STM_ID).toString()));\n        }\n\n    }\n\n    @Test\n    public void testPersistOverrideAutoIncrement3() throws Exception {\n        DbEntity entity = dbEntity()\n                .name(\"MYTEST\")\n                .addColumn(\"COL1\", INT, true)\n                .addColumn(\"COL2\", STRING)\n                .build();\n\n\n        engine.addEntity(entity);\n\n        EntityEntry ent = entry().set(\"COL2\", \"CENAS1\").set(\"COL1\", 1)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS2\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n\n        ent = entry().set(\"COL2\", \"CENAS5\").set(\"COL1\", 5)\n                .build();\n        engine.persist(\"MYTEST\", ent, false);\n\n        ent = entry().set(\"COL2\", \"CENAS6\")\n                .build();\n        engine.persist(\"MYTEST\", ent);\n\n        final List<Map<String, ResultColumn>> query = engine.query(\"SELECT * FROM \" + quotize(\"MYTEST\", engine.escapeCharacter()));\n        for (Map<String, ResultColumn> stringResultColumnMap : query) {\n            System.out.println(stringResultColumnMap);\n            assertTrue(stringResultColumnMap.get(\"COL2\").toString().endsWith(stringResultColumnMap.get(\"COL1\").toString()));\n        }\n        engine.close();\n    }\n\n    @Test\n    public void testTruncateTable() throws Exception {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5)\n                .build());\n\n        Truncate truncate = new Truncate(table(\"TEST\"));\n\n        engine.executeUpdate(truncate);\n\n        final List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertTrue(\"Test truncate query empty?\", test.isEmpty());\n\n    }\n\n    @Test\n    public void testRenameTables() throws Exception {\n        String oldName = \"TBL_OLD\";\n        String newName = \"TBL_NEW\";\n\n        // Drop tables for sanity.\n        dropSilently(oldName, newName);\n\n        // Create the \"old\" table.\n        DbEntity entity = dbEntity()\n                .name(oldName)\n                .addColumn(\"timestamp\", INT)\n                .build();\n        engine.addEntity(entity);\n        engine.persist(oldName, entry().set(\"timestamp\", 20)\n                .build());\n\n        // Rename it\n        Rename rename = new Rename(table(oldName), table(newName));\n        engine.executeUpdate(rename);\n\n        // Check whether the schema matches\n        final Map<String, DbColumnType> metaMap = new LinkedHashMap<>();\n        metaMap.put(\"timestamp\", INT);\n        assertEquals(\"Metamap ok?\", metaMap, engine.getMetadata(newName));\n\n        // Check the data\n        List<Map<String, ResultColumn>> resultSet = engine.query(select(all()).from(table(newName)));\n        assertEquals(\"Count ok?\", 1, resultSet.size());\n\n        assertEquals(\"Content ok?\", 20, (int) resultSet.get(0).get(\"timestamp\").toInt());\n\n        dropSilently(newName);\n    }\n\n    /**\n     * Drops a list of tables silently (i.e. if it fails, it will just keep on).\n     *\n     * @param tables The tables that we want to drop.\n     */\n    private void dropSilently(String... tables) {\n        for (String table : tables) {\n            try {\n                engine.dropEntity(dbEntity().name(table).build());\n            } catch (final Throwable e) {\n                // ignore\n            }\n        }\n    }\n\n    @Test\n    public void testLikeWithTransformation() throws Exception {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 5).set(\"COL5\", \"tesTte\")\n                .build());\n\n        List<Map<String, ResultColumn>> query = engine.query(\n            select(all()).from(table(\"TEST\")).where(like(udf(\"lower\", column(\"COL5\")), k(\"%teste%\")))\n        );\n        assertEquals(3, query.size());\n        query = engine.query(select(all()).from(table(\"TEST\")).where(like(udf(\"lower\", column(\"COL5\")), k(\"%tt%\"))));\n        assertEquals(1, query.size());\n\n    }\n\n    @Test\n    public void createSequenceOnLongColumnTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG, true)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n        engine.addEntity(entity);\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"col1 ok?\", 1, (int) test.get(0).get(\"COL1\").toInt());\n        assertTrue(\"col2 ok?\", test.get(0).get(\"COL2\").toBoolean());\n        assertEquals(\"col4 ok?\", 1L, (long) test.get(0).get(\"COL4\").toLong());\n\n    }\n\n    @Test\n    public void insertWithNoAutoIncAndThatResumeTheAutoIncTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG, true)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n        engine.addEntity(entity);\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 1L, (long) test.get(0).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 2)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 2L, (long) test.get(1).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 3L, (long) test.get(2).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 4)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 4L, (long) test.get(3).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 5L, (long) test.get(4).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 6)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 6L, (long) test.get(5).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true).set(\"COL4\", 7)\n                .build(), false);\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 7L, (long) test.get(6).get(\"COL4\").toLong());\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL2\", true)\n                .build());\n        test = engine.query(select(all()).from(table(\"TEST\")).orderby(column(\"COL4\")));\n        assertEquals(\"col4 ok?\", 8L, (long) test.get(7).get(\"COL4\").toLong());\n    }\n\n    /**\n     * Creates a {@link DbEntity} with 5 columns to be used in the tests.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the entity.\n     */\n    private void create5ColumnsEntity() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity()\n                .name(\"TEST\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", BOOLEAN)\n                .addColumn(\"COL3\", DOUBLE)\n                .addColumn(\"COL4\", LONG)\n                .addColumn(\"COL5\", STRING)\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    /**\n     * Creates a {@link DbEntity} with 5 columns being the first the primary key to be used in the tests.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the entity.\n     */\n    private void create5ColumnsEntityWithPrimaryKey() throws DatabaseEngineException {\n        final DbEntity entity = dbEntity().name(\"TEST\")\n                                          .addColumn(\"COL1\", INT)\n                                          .addColumn(\"COL2\", BOOLEAN)\n                                          .addColumn(\"COL3\", DOUBLE)\n                                          .addColumn(\"COL4\", LONG)\n                                          .addColumn(\"COL5\", STRING)\n                                          .pkFields(\"COL1\")\n                                          .build();\n\n        engine.addEntity(entity);\n    }\n\n    protected void userRolePermissionSchema() throws DatabaseEngineException {\n        DbEntity entity = dbEntity()\n                .name(\"USER\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        entity = dbEntity()\n                .name(\"ROLE\")\n                .addColumn(\"COL1\", INT, true)\n                .pkFields(\"COL1\")\n                .build();\n\n        engine.addEntity(entity);\n\n        entity = dbEntity()\n                .name(\"USER_ROLE\")\n                .addColumn(\"COL1\", INT)\n                .addColumn(\"COL2\", INT)\n                .addFk(dbFk()\n                                .addColumn(\"COL1\")\n                                .referencedTable(\"USER\")\n                                .addReferencedColumn(\"COL1\")\n                                .build(),\n                        dbFk()\n                                .addColumn(\"COL2\")\n                                .referencedTable(\"ROLE\")\n                                .addReferencedColumn(\"COL1\")\n                                .build()\n                )\n                .pkFields(\"COL1\", \"COL2\")\n                .build();\n\n        engine.addEntity(entity);\n    }\n\n    @Test\n    public void testAndWhere() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(\"TEST\")).where(eq(column(\"COL1\"), k(1))).andWhere(eq(column(\"COL5\"), k(\"teste\"))));\n\n        assertEquals(\"Resultset must have only one result\", 1, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testAndWhereMultiple() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                or(\n                                        eq(column(\"COL1\"), k(1)),\n                                        eq(column(\"COL1\"), k(4))\n                                )\n                        )\n                        .andWhere(\n                                or(\n                                        eq(column(\"COL5\"), k(\"teste\")),\n                                        eq(column(\"COL5\"), k(\"TESTE\"))\n                                )\n                        )\n        );\n\n        assertEquals(\"Resultset must have only one result\", 1, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testAndWhereMultipleCheckAndEnclosed() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 3).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 4).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(\n                                or(\n                                        eq(column(\"COL1\"), k(1)),\n                                        eq(column(\"COL1\"), k(4))\n                                )\n                        )\n                        .andWhere(\n                                or(\n                                        eq(column(\"COL5\"), k(\"teste\")),\n                                        eq(column(\"COL5\"), k(\"tesTte\"))\n                                )\n                        )\n        );\n\n        assertEquals(\"Resultset must have only one result\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"COL5\").toString());\n        assertEquals(\"COL1 must be 1\", 4, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"tesTte\", query.get(1).get(\"COL5\").toString());\n    }\n\n    @Test\n    public void testStringAgg() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TESTE,teste\", \"TESTE,teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE,tesTte\", \"TeStE,tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggDelimiter() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).delimiter(';').alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TESTE;teste\", \"TESTE;teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE;tesTte\", \"TeStE;tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggDistinct() throws DatabaseEngineException {\n        assumeTrue(\"This test is only valid for engines that support StringAggDistinct\",\n                this.engine.isStringAggDistinctCapable());\n\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL5\")).distinct().alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be teste\", \"teste\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be TeStE,tesTte\", \"TeStE,tesTte\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    public void testStringAggNotStrings() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"TESTE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 1).set(\"COL5\", \"teste\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"TeStE\")\n                .build());\n        engine.persist(\"TEST\", entry().set(\"COL1\", 2).set(\"COL5\", \"tesTte\")\n                .build());\n\n        final List<Map<String, ResultColumn>> query = engine.query(\n                select(column(\"COL1\"), stringAgg(column(\"COL1\")).alias(\"agg\"))\n                        .from(table(\"TEST\"))\n                        .groupby(column(\"COL1\"))\n                        .orderby(column(\"COL1\").asc())\n        );\n\n        assertEquals(\"Resultset must have only 2 results\", 2, query.size());\n        assertEquals(\"COL1 must be 1\", 1, query.get(0).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be 1,1\", \"1,1\", query.get(0).get(\"agg\").toString());\n        assertEquals(\"COL1 must be 2\", 2, query.get(1).get(\"COL1\").toInt().intValue());\n        assertEquals(\"COL5 must be 2,2\", \"2,2\", query.get(1).get(\"agg\").toString());\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void dropPrimaryKeyWithOneColumnTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .pkFields(\"COL1\")\n                        .build();\n        engine.addEntity(entity);\n        engine.executeUpdate(dropPK(table(\"TEST\")));\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void dropPrimaryKeyWithTwoColumnsTest() throws Exception {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .pkFields(\"COL1\", \"COL4\")\n                        .build();\n        engine.addEntity(entity);\n        engine.executeUpdate(dropPK(table(\"TEST\")));\n    }\n\n    @Test\n    public void alterColumnWithConstraintTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n\n        engine.addEntity(entity);\n\n        engine.executeUpdate(new AlterColumn(table(\"TEST\"), new DbColumn.Builder().name(\"COL1\").type(DbColumnType.INT).addConstraint(DbColumnConstraint\n                .NOT_NULL)\n                .build()));\n    }\n\n    @Test\n    @Category(SkipTestCockroachDB.class)\n    public void alterColumnToDifferentTypeTest() throws DatabaseEngineException {\n        DbEntity entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT)\n                        .addColumn(\"COL2\", BOOLEAN)\n                        .addColumn(\"COL3\", DOUBLE)\n                        .addColumn(\"COL4\", LONG)\n                        .addColumn(\"COL5\", STRING)\n                        .build();\n\n        engine.addEntity(entity);\n\n        engine.executeUpdate(new AlterColumn(table(\"TEST\"), dbColumn().name(\"COL1\").type(DbColumnType.STRING)\n                .build()));\n    }\n\n    @Test\n    public void createTableWithDefaultsTest() throws DatabaseEngineException, DatabaseFactoryException {\n        DbEntity.Builder entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT, new K(1))\n                        .addColumn(\"COL2\", BOOLEAN, new K(false))\n                        .addColumn(\"COL3\", DOUBLE, new K(2.2d))\n                        .addColumn(\"COL4\", LONG, new K(3L))\n                        .pkFields(\"COL1\");\n\n        engine.addEntity(entity.build());\n\n        final String ec = engine.escapeCharacter();\n        engine.executeUpdate(\"INSERT INTO \" + quotize(\"TEST\", ec) + \" (\" + quotize(\"COL1\", ec) + \") VALUES (10)\");\n\n        List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"Check size of records\", 1, test.size());\n        Map<String, ResultColumn> record = test.get(0);\n        assertEquals(\"Check COL1\", 10, record.get(\"COL1\").toInt().intValue());\n        assertEquals(\"Check COL2\", false, record.get(\"COL2\").toBoolean());\n        assertEquals(\"Check COL3\", 2.2d, record.get(\"COL3\").toDouble(), 0);\n        assertEquals(\"Check COL4\", 3L, record.get(\"COL4\").toLong().longValue());\n\n\n        final DbEntity entity1 = entity\n                .addColumn(\"COL5\", STRING, new K(\"mantorras\"), NOT_NULL)\n                .addColumn(\"COL6\", BOOLEAN, new K(true), NOT_NULL)\n                .addColumn(\"COL7\", INT, new K(7), NOT_NULL)\n                .build();\n\n        final Properties propertiesCreate = new Properties();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            propertiesCreate.setProperty(prop.getKey().toString(), prop.getValue().toString());\n        }\n        propertiesCreate.setProperty(SCHEMA_POLICY, \"create\");\n\n        final DatabaseEngine connection2 = DatabaseFactory.getConnection(propertiesCreate);\n        connection2.updateEntity(entity1);\n\n        test = connection2.query(select(all()).from(table(\"TEST\")));\n        assertEquals(\"Check size of records\", 1, test.size());\n        record = test.get(0);\n        assertEquals(\"Check COL1\", 10, record.get(\"COL1\").toInt().intValue());\n        assertEquals(\"Check COL2\", false, record.get(\"COL2\").toBoolean());\n        assertEquals(\"Check COL3\", 2.2d, record.get(\"COL3\").toDouble(), 1e-9);\n        assertEquals(\"Check COL4\", 3L, record.get(\"COL4\").toLong().longValue());\n        assertEquals(\"Check COL5\", \"mantorras\", record.get(\"COL5\").toString());\n        assertEquals(\"Check COL6\", true, record.get(\"COL6\").toBoolean());\n        assertEquals(\"Check COL7\", 7, record.get(\"COL7\").toInt().intValue());\n        connection2.close();\n    }\n\n    @Test\n    public void defaultValueOnBooleanColumnsTest() throws DatabaseEngineException {\n        DbEntity.Builder entity =\n                dbEntity()\n                        .name(\"TEST\")\n                        .addColumn(\"COL1\", INT, new K(1))\n                        .addColumn(\"COL2\", BOOLEAN, new K(false), NOT_NULL)\n                        .addColumn(\"COL3\", DOUBLE, new K(2.2d))\n                        .addColumn(\"COL4\", LONG, new K(3L))\n                        .pkFields(\"COL1\");\n\n        engine.addEntity(entity.build());\n\n        engine.persist(\"TEST\", entry().build());\n        Map<String, ResultColumn> row = engine.query(select(all()).from(table(\"TEST\"))).get(0);\n\n        assertEquals(\"\", 1, row.get(\"COL1\").toInt().intValue());\n        assertFalse(\"\", row.get(\"COL2\").toBoolean());\n        assertEquals(\"\", 2.2d, row.get(\"COL3\").toDouble(), 0D);\n        assertEquals(\"\", 3L, row.get(\"COL4\").toLong().longValue());\n    }\n\n    @Test\n    public void upperTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"ola\").build());\n        assertEquals(\"text is uppercase\", \"OLA\", engine.query(select(upper(column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\").toString());\n    }\n\n    @Test\n    public void lowerTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"OLA\").build());\n        assertEquals(\"text is lowercase\", \"ola\", engine.query(select(lower(column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\").toString());\n    }\n\n    @Test\n    public void internalFunctionTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"OLA\").build());\n        assertEquals(\"text is uppercase\", \"ola\", engine.query(select(f(\"LOWER\", column(\"COL5\")).alias(\"RES\")).from(table(\"TEST\"))).get(0).get(\"RES\")\n                .toString());\n    }\n\n    @Test\n    public void entityEntryHashcodeTest() {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"id1\", \"val1\");\n        map.put(\"id2\", \"val2\");\n        map.put(\"id3\", \"val3\");\n        map.put(\"id4\", \"val4\");\n\n        EntityEntry entry = entry()\n                .set(map)\n                .build();\n\n        assertEquals(\"entry's hashCode() matches map's hashCode()\", map.hashCode(), entry.hashCode());\n    }\n\n    /**\n     * Tests that creating a {@link DatabaseEngine} using try-with-resources will close the engine\n     * (and thus the underlying connection to the database) once the block is exited from.\n     *\n     * @throws Exception if something goes wrong while checking if the connection of the engine is closed.\n     * @since 2.1.12\n     */\n    @Test\n    public void tryWithResourcesClosesEngine() throws Exception {\n        final AtomicReference<Connection> connReference = new AtomicReference<>();\n\n        try (final DatabaseEngine tryEngine = this.engine) {\n            connReference.set(tryEngine.getConnection());\n            assertFalse(\"close() method should not be called within the try-with-resources block, for an existing DatabaseEngine\",\n                    connReference.get().isClosed());\n        }\n\n        assertTrue(\"close() method should be called after exiting try-with-resources block, for an existing DatabaseEngine\",\n                connReference.get().isClosed());\n\n        try (final DatabaseEngine tryEngine = DatabaseFactory.getConnection(properties)) {\n            connReference.set(tryEngine.getConnection());\n            assertFalse(\"close() method should not be called within the try-with-resources block, for a DatabaseEngine created in the block\",\n                    connReference.get().isClosed());\n        }\n\n        assertTrue(\"close() method should be called after exiting try-with-resources block, for a DatabaseEngine created in the block\",\n                connReference.get().isClosed());\n\n    }\n\n    /**\n     * Test that closing a database engine a 'create-drop' policy with multiple entities closes all insert statements\n     * associated with each entity, regardless of the schema policy used.\n     *\n     * Each entity is associated with 3 prepared statements. This test ensures that 3 PSs per entity are closed.\n     *\n     * @throws DatabaseEngineException  If something goes wrong while adding an entity to the engine.\n     * @throws DatabaseFactoryException If the database engine class specified in the properties does not exist.\n     * @since 2.1.13\n     */\n    @Test\n    public void closingAnEngineUsingTheCreateDropPolicyShouldDropAllEntities()\n            throws DatabaseEngineException, DatabaseFactoryException {\n\n        // Force the schema policy to be 'create-drop'\n        properties.setProperty(SCHEMA_POLICY, \"create-drop\");\n        engine = DatabaseFactory.getConnection(properties);\n\n        engine.addEntity(buildEntity(\"ENTITY-1\"));\n        engine.addEntity(buildEntity(\"ENTITY-2\"));\n\n        // Force invocation counting to start here\n        new Expectations(engine) {};\n\n        engine.close();\n\n        new Verifications() {{\n            engine.dropEntity((DbEntity) any); times = 2;\n        }};\n\n    }\n\n    /**\n     * Assesses whether the current row count is incremented if the .next()/.nextResult()\n     * methods are called in the iterator.\n     *\n     * @throws DatabaseEngineException If a database access error happens.\n     */\n    @Test\n    public void doesRowCountIncrementTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        // Create 4 entries\n        for (int i = 0; i < 4; i++) {\n            engine.persist(\"TEST\", entry().set(\"COL1\", i).build());\n        }\n\n        final ResultIterator resultIterator = engine.iterator(select(all()).from(table(\"TEST\")));\n\n        assertEquals(\"The current row count should be 0 if the iteration hasn't started\", 0, resultIterator.getCurrentRowCount());\n\n        // If the .next() method is called once then the current row count should be updated to 1\n        resultIterator.next();\n\n        assertEquals(\"The current row count is equal to 1\", 1,resultIterator.getCurrentRowCount());\n\n        // If for the same iterator the .nextResult() method is called 3 additional\n        // times then the current row count should be updated to 4\n        for(int i = 0; i < 3; i++) {\n            resultIterator.nextResult();\n        }\n\n        assertEquals(\"The current row count is equal to 4\", 4, resultIterator.getCurrentRowCount());\n    }\n\n    /**\n     * Tests that a {@link com.feedzai.commons.sql.abstraction.dml.K constant expression} with an enum value behaves\n     * as if the enum is a string (obtained from {@link Enum#name()}, both when persisting an entry and when using\n     * the enum value for filtering in a WHERE clause.\n     *\n     * @throws DatabaseEngineException If something goes wrong creating the test entity or persisting entries.\n     */\n    @Test\n    public void kEnumTest() throws DatabaseEngineException {\n        create5ColumnsEntity();\n\n        // should fail here if enum is not supported, or it will just put garbage, which will be detected later\n        engine.persist(\"TEST\", entry().set(\"COL5\", TestEnum.TEST_ENUM_VAL).build());\n\n        engine.persist(\"TEST\", entry().set(\"COL5\", \"something else\").build());\n\n        final List<Map<String, ResultColumn>> results = engine.query(\n                select(all())\n                        .from(table(\"TEST\"))\n                        .where(eq(column(\"COL5\"), k(TestEnum.TEST_ENUM_VAL)))\n        );\n\n        assertThat(results)\n                .as(\"One (and only one) result expected.\")\n                .hasSize(1)\n                .element(0)\n                .extracting(element -> element.get(\"COL5\").toString())\n                .as(\"An enum value should be persisted as its string representation\")\n                .isEqualTo(TestEnum.TEST_ENUM_VAL.name());\n    }\n\n    /**\n     * Tests that when inserting duplicated entries in a table the right exception is returned.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add duplicated entries in a transaction and fail to persist</li>\n     *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>\n     * </ol>\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     */\n    @Test\n    public void insertDuplicateDBError() throws Exception {\n        create5ColumnsEntityWithPrimaryKey();\n\n        EntityEntry entry = entry().set(\"COL1\", 2)\n                                   .set(\"COL2\", false)\n                                   .set(\"COL3\", 2D)\n                                   .set(\"COL4\", 3L)\n                                   .set(\"COL5\", \"ADEUS\")\n                                   .build();\n\n        // Add the same entry twice (repeated value for COL1, id)\n        engine.persist(\"TEST\", entry);\n        assertThatCode(() -> engine.persist(\"TEST\", entry))\n                .as(\"Is unique constraint violation exception\")\n                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)\n                .as(\"Encapsulated exception is SQLException\")\n                .hasCauseInstanceOf(SQLException.class)\n                .hasMessage(\"Something went wrong persisting the entity [unique_constraint_violation]\");\n    }\n\n    /**\n     * Tests that on a duplicated batch entry situation the right exception is returned.\n     *\n     * The steps performed on this test are:\n     * <ol>\n     *     <li>Add duplicated batch entries to transaction and fail to flush</li>\n     *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>\n     * </ol>\n     *\n     * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.\n     */\n    @Test\n    public void batchInsertDuplicateDBError() throws DatabaseEngineException {\n        create5ColumnsEntityWithPrimaryKey();\n\n        EntityEntry entry = entry().set(\"COL1\", 2)\n                                   .set(\"COL2\", false)\n                                   .set(\"COL3\", 2D)\n                                   .set(\"COL4\", 3L)\n                                   .set(\"COL5\", \"ADEUS\")\n                                   .build();\n\n        // Add the same entry twice (repeated value for COL1, id)\n        engine.addBatch(\"TEST\", entry);\n        engine.addBatch(\"TEST\", entry);\n\n        // Flush the duplicated entries and check the exception\n        assertThatCode(() -> engine.flush())\n                .as(\"Is unique constraint violation exception\")\n                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)\n                .as(\"Encapsulated exception is SQLException\")\n                .hasCauseInstanceOf(SQLException.class)\n                .hasMessage(\"Something went wrong while flushing [unique_constraint_violation]\");\n    }\n\n    /**\n     * An enum for tests.\n     */\n    private enum TestEnum {\n        TEST_ENUM_VAL;\n\n        @Override\n        public String toString() {\n            return super.toString() + \" description\";\n        }\n    }\n}\n",
    "project": "pdb",
    "libraryName": "logback-classic",
    "libraryGroupID": "ch.qos.logback",
    "newVersion": "1.4.5",
    "previousVersion": "1.2.11",
    "breakingCommit": "43b3a858b77ec27fc8946aba292001c3de465012"
}