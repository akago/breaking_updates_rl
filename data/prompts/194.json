{
    "absolute_path_to_file_in_container": "/PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java",
    "errors": [
        {
            "line_number": 26,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol",
            "additional_info": "  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index",
            "file_name": "PGS_CirclePacking.java",
            "BCs": [
                {
                    "element": "org.tinspin.index.kdtree.KDTree.main",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.tinspin.index.PointDistanceFunction",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "eee837df-a0d1-55dd-a231-7f4964b2c3ec"
        },
        {
            "line_number": 27,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol",
            "additional_info": "  symbol:   class PointEntryDist\n  location: package org.tinspin.index",
            "file_name": "PGS_CirclePacking.java",
            "BCs": [
                {
                    "element": "org.tinspin.index.PointEntryDist",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "org.tinspin.index.kdtree.KDTree.main",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "9f78aeeb-e1bd-59ec-920b-1493da09f381"
        },
        {
            "line_number": 226,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol",
            "additional_info": "  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking",
            "file_name": "PGS_CirclePacking.java",
            "BCs": [
                {
                    "element": "org.tinspin.index.PointEntryDist",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "org.tinspin.index.kdtree.KDTree.main",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "9063e6eb-b973-51da-896b-3ab642fae82f"
        },
        {
            "line_number": 645,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol",
            "additional_info": "  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking",
            "file_name": "PGS_CirclePacking.java",
            "BCs": [
                {
                    "element": "org.tinspin.index.kdtree.KDTree.main",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.tinspin.index.PointDistanceFunction",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "78bf7ec6-ab95-55aa-800a-7f00ac8e7e56"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\npackage micycle.pgs;\n\nimport static micycle.pgs.PGS_Conversion.fromPShape;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;\nimport org.locationtech.jts.geom.Coordinate;\nimport org.locationtech.jts.geom.Envelope;\nimport org.locationtech.jts.geom.Geometry;\nimport org.locationtech.jts.geom.Location;\nimport org.locationtech.jts.geom.prep.PreparedGeometry;\nimport org.locationtech.jts.geom.prep.PreparedGeometryFactory;\nimport org.locationtech.jts.operation.distance.IndexedFacetDistance;\nimport org.locationtech.jts.util.GeometricShapeFactory;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinfour.common.SimpleTriangle;\nimport org.tinfour.common.Vertex;\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\nimport org.tinspin.index.covertree.CoverTree;\n\nimport micycle.pgs.commons.FrontChainPacker;\nimport micycle.pgs.commons.LargestEmptyCircles;\nimport micycle.pgs.commons.RepulsionCirclePack;\nimport micycle.pgs.commons.TangencyPack;\nimport processing.core.PShape;\nimport processing.core.PVector;\n\n/**\n * Circle packings of shapes, subject to varying constraints and patterns of\n * tangencies.\n * <p>\n * Each method produces a circle packing with different characteristics using a\n * different technique; for this reason input arguments vary across the methods.\n * <p>\n * The output of each method is a list of PVectors, each representing one\n * circle: (.x, .y) represent the center point and .z represents radius.\n * <p>\n * Where applicable, packings will include circles that overlap with the shape,\n * rather than only including those circles whose center point lies inside the\n * shape.\n * \n * @author Michael Carleton\n * @since 1.1.0\n *\n */\npublic final class PGS_CirclePacking {\n\n\t/*-\n\t * Roadmap (see/implement): 'A LINEARIZED CIRCLE PACKING ALGORITHM'? \n\t * 'A note on circle packing' Young Joon AHN.\n\t */\n\n\tprivate PGS_CirclePacking() {\n\t}\n\n\t/**\n\t * Packs circles of varying radii within a given shape, whilst respecting\n\t * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method\n\t * continues to generate circles until the sum of the areas of the circles\n\t * exceeds a specified proportion of the area of the given shape.\n\t * \n\t * @param shape          The shape within which circles will be packed. The\n\t *                       shape should be in the form of PShape.\n\t * @param pointObstacles A collection of PVector points representing obstacles,\n\t *                       around which circles are packed. Only points contained\n\t *                       within the shape are relevant.\n\t * @param areaCoverRatio The target ratio of the total area of the circles to\n\t *                       the area of the shape. This parameter should be a\n\t *                       double between 0 and 1. Circle generation will stop\n\t *                       when this ratio is reached.\n\t * @return A list of PVectors, where each PVector represents a circle. The x and\n\t *         y components of the PVector represent the center of the circle, and\n\t *         the z component represents the radius of the circle.\n\t * @since 1.4.0\n\t */\n\tpublic static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {\n\t\tfinal Geometry geometry = fromPShape(shape);\n\n\t\tLargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,\n\t\t\t\tareaCoverRatio > 0.95 ? 0.5 : 1);\n\n\t\tfinal double shapeArea = geometry.getArea();\n\t\tdouble circlesArea = 0;\n\t\tList<PVector> circles = new ArrayList<>();\n\n\t\twhile (circlesArea / shapeArea < areaCoverRatio) {\n\t\t\tdouble[] currentLEC = lec.findNextLEC();\n\t\t\tcircles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));\n\t\t\tcirclesArea += Math.PI * currentLEC[2] * currentLEC[2];\n\t\t\tif (currentLEC[2] < 0.5) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn circles;\n\t}\n\n\t/**\n\t * Generates a circle packing of the input shape, using the inscribed circles\n\t * (or incircles) of triangles from a triangulation of the shape.\n\t * <p>\n\t * Circles in this packing do not overlap and are contained entirely within the\n\t * shape. However, not every circle is necessarily tangent to others.\n\t * \n\t * @param shape       the shape from which to generate a circle packing\n\t * @param points      the number of random points to insert into the\n\t *                    triangulation as steiner points. Larger values lead to\n\t *                    more circles that are generally smaller.\n\t * @param refinements number of times to refine the underlying triangulation.\n\t *                    Larger values lead to more circles that are more regularly\n\t *                    spaced and sized. 0...3 is a suitable range for this\n\t *                    parameter\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {\n\t\tfinal List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);\n\t\tfinal IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);\n\t\treturn StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t))\n\t\t\t\t.collect(Collectors.toList());\n\t}\n\n\t/**\n\t * Generates a random circle packing of the input shape by generating random\n\t * points one-by-one and calculating the maximum radius a circle at each point\n\t * can have (such that it's tangent to its nearest circle or a shape vertex).\n\t * <p>\n\t * Notably, the {@code points} argument defines the number of random point\n\t * attempts (or circle attempts), and not the number of circles in the final\n\t * packing output, since a point is rejected if it lies in an existing circle or\n\t * whose nearest circle is less than minRadius distance away. In other words,\n\t * {@code points} defines the maximum number of circles the packing can have; in\n\t * practice, the packing will contain somewhat fewer circles.\n\t * <p>\n\t * Circles in this packing do not overlap and are contained entirely within the\n\t * shape. However, not every circle is necessarily tangent to other circles (in\n\t * which case, such a circle will be tangent to a shape vertex).\n\t * \n\t * @param shape             the shape from which to generate a circle packing\n\t * @param points            number of random points to generate (this is not the\n\t *                          number of circles in the packing).\n\t * @param minRadius         filter (however not simply applied at the end, so\n\t *                          affects how the packing operates during packing)\n\t * @param triangulatePoints when true, triangulates an initial random point set\n\t *                          and uses triangle centroids as the random point set\n\t *                          instead; this results in a packing that covers the\n\t *                          shape more evenly (particularly when points is\n\t *                          small), which is sometimes desirable\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {\n\t\treturn stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());\n\t}\n\n\t/**\n\t * \n\t * Generates a seeded random circle packing within the input shape. Circles are\n\t * created one-by-one by generating random points and calculating the maximum\n\t * possible radius for a circle at each point, ensuring it is tangent to its\n\t * nearest circle or shape vertex.\n\t * <p>\n\t * The {@code points} parameter defines the number of random point attempts (or\n\t * circle attempts), but not the exact number of circles in the final packing\n\t * output. An attempted point is rejected if it lies within an existing circle\n\t * or if its nearest circle is less than {@code minRadius} distance away.\n\t * <p>\n\t * Thus, {@code points} defines the maximum number of circles the packing can\n\t * have; in practice, the packing will contain somewhat fewer circles.\n\t * <p>\n\t * The generated circles in the packing do not overlap and are contained\n\t * entirely within the shape. However, not every circle is necessarily tangent\n\t * to other circles; such circles will be tangent to a shape vertex.\n\t * \n\t * @param shape             the shape within which to generate the circle\n\t *                          packing\n\t * @param points            number of random points to generate (not necessarily\n\t *                          equal to the number of circles in the packing)\n\t * @param minRadius         minimum allowed radius for circles in the packing\n\t *                          (affects packing generation, not applied as a filter\n\t *                          at the end)\n\t * @param triangulatePoints when true, triangulates the initial random point set\n\t *                          and uses triangle centroids as the random point set\n\t *                          instead; results in a more evenly distributed\n\t *                          packing (particularly when the number of points is\n\t *                          small), which may be desirable\n\t * @param seed              random seed used to initialize the underlying random\n\t *                          number generator\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point, and .z represents the radius.\n\t */\n\tpublic static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints,\n\t\t\tlong seed) {\n\n\t\tfinal CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tList<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);\n\t\tif (triangulatePoints) {\n\t\t\tfinal IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);\n\t\t\tsteinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)\n\t\t\t\t\t.map(PGS_CirclePacking::centroid).collect(Collectors.toList());\n\t\t}\n\n\t\t// Model shape vertices as circles of radius 0, to constrain packed circles\n\t\t// within shape edge\n\t\tfinal List<PVector> vertices = PGS_Conversion.toPVector(shape);\n\t\tCollections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion\n\t\tvertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));\n\n\t\t/*\n\t\t * \"To find the circle nearest to a center (x, y), do a proximity search at (x,\n\t\t * y, R), where R is greater than or equal to the maximum radius of a circle.\"\n\t\t */\n\t\tfloat largestR = 0; // the radius of the largest circle in the tree\n\n\t\tfor (PVector p : steinerPoints) {\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\n\t\t\t/*\n\t\t\t * nn.dist() does not return the radius (since it's a distance metric used to\n\t\t\t * find nearest circle), so calculate maximum radius for candidate circle using\n\t\t\t * 2d euclidean distance between center points minus radius of nearest circle.\n\t\t\t */\n\t\t\tfinal float dx = p.x - nn.value().x;\n\t\t\tfinal float dy = p.y - nn.value().y;\n\t\t\tfinal float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);\n\t\t\tif (radius > minRadius) {\n\t\t\t\tlargestR = (radius >= largestR) ? radius : largestR;\n\t\t\t\tp.z = radius;\n\t\t\t\ttree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree\n\t\t\t\tout.add(p);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a random circle packing of tangential circles with varying radii\n\t * that overlap the given shape. The method name references the packing\n\t * algorithm used (Front Chain Packing), rather than any particular\n\t * characteristic of the circle packing.\n\t * <p>\n\t * You can set <code>radiusMin</code> equal to <code>radiusMax</code> for a\n\t * packing of equal-sized circles using this approach.\n\t *\n\t * @param shape     the shape within which to generate the circle packing\n\t * @param radiusMin minimum radius of circles in the packing\n\t * @param radiusMax maximum radius of circles in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {\n\t\tradiusMin = Math.max(1f, Math.min(radiusMin, radiusMax)); // choose min and constrain\n\t\tradiusMax = Math.max(1f, Math.max(radiusMin, radiusMax)); // choose max and constrain\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\tIndexedPointInAreaLocator pointLocator;\n\n\t\tfinal FrontChainPacker packer = new FrontChainPacker((float) e.getWidth(), (float) e.getHeight(), (float) radiusMin,\n\t\t\t\t(float) radiusMax, (float) e.getMinX(), (float) e.getMinY());\n\n\t\tif (radiusMin == radiusMax) {\n\t\t\t// if every circle same radius, use faster contains check\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n\t\t\tpacker.getCircles().removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n\t\t} else {\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g);\n\t\t\tfinal PreparedGeometry cache = PreparedGeometryFactory.prepare(g);\n\t\t\tfinal GeometricShapeFactory circleFactory = new GeometricShapeFactory();\n\t\t\tcircleFactory.setNumPoints(8); // approximate circles using octagon for intersects check\n\t\t\tpacker.getCircles().removeIf(p -> {\n\t\t\t\t// first test whether shape contains circle center point (somewhat faster)\n\t\t\t\tif (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// if center point not in circle, check whether circle overlaps with shape using\n\t\t\t\t// intersects() (somewhat slower)\n\t\t\t\tcircleFactory.setCentre(PGS.coordFromPVector(p));\n\t\t\t\tcircleFactory.setSize(p.z * 2); // set diameter\n\t\t\t\treturn !cache.intersects(circleFactory.createCircle());\n\t\t\t});\n\t\t}\n\n\t\treturn packer.getCircles();\n\t}\n\n\t/**\n\t * Packs a specified number of maximum inscribed circles within the given shape\n\t * using the Largest Empty Circle (LEC) algorithm.\n\t * <p>\n\t * This method finds and returns the maximum inscribed circles up to the\n\t * specified number (n), starting with the largest circle. It uses a tolerance\n\t * value to control the accuracy of the LEC algorithm.\n\t *\n\t * @param shape     The input shape to pack maximum inscribed circles within.\n\t * @param n         The number of maximum inscribed circles to find and pack.\n\t * @param tolerance The tolerance value to control the LEC algorithm's accuracy.\n\t *                  Higher values yield faster results but lower accuracy. A\n\t *                  value of a 1 is good staring point.\n\t * @return A list of PVector objects representing the centers (.x, .y) and radii\n\t *         (.z) of the maximum inscribed circles.\n\t */\n\tpublic static List<PVector> maximumInscribedPack(PShape shape, int n, double tolerance) {\n\t\ttolerance = Math.max(0.01, tolerance);\n\t\tLargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble[] c = mics.findNextLEC();\n\t\t\tout.add(new PVector((float) c[0], (float) c[1], (float) c[2]));\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Packs maximum inscribed circles within the given shape using the Largest\n\t * Empty Circle (LEC) algorithm.\n\t * <p>\n\t * This method finds and returns the maximum inscribed circles with a radius\n\t * equal to or larger than the specified minimum radius. It uses a tolerance\n\t * value to control the accuracy of the LEC algorithm.\n\t *\n\t * @param shape     The input shape to pack maximum inscribed circles within.\n\t * @param minRadius The minimum allowed radius for the inscribed circles.\n\t * @param tolerance The tolerance value to control the LEC algorithm's accuracy.\n\t *                  Higher values yield faster results but lower accuracy. A\n\t *                  value of a 1 is good staring point.\n\t * @return A list of PVector objects representing the centers (.x, .y) and radii\n\t *         (.z) of the maximum inscribed circles.\n\t */\n\tpublic static List<PVector> maximumInscribedPack(PShape shape, double minRadius, double tolerance) {\n\t\ttolerance = Math.max(0.01, tolerance);\n\t\tminRadius = Math.max(0.01, minRadius);\n\t\tLargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\t\tdouble[] currentLEC;\n\t\tdo {\n\t\t\tcurrentLEC = mics.findNextLEC();\n\t\t\tif (currentLEC[2] >= minRadius) {\n\t\t\t\tout.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));\n\t\t\t}\n\t\t} while (currentLEC[2] >= minRadius);\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a circle packing having a pattern of tangencies specified by a\n\t * triangulation.\n\t * \n\t * <p>\n\t * This is an implementation of 'A circle packing algorithm' by Charles R.\n\t * Collins & Kenneth Stephenson.\n\t * \n\t * @param triangulation represents the pattern of tangencies; vertices connected\n\t *                      by an edge inthe triangulation represent tangent circles\n\t *                      in thepacking\n\t * @param boundaryRadii radius of every circle associated with the\n\t *                      boundary/perimeter vertices of the triangulation\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {\n\t\tTangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n\t\treturn pack.pack();\n\t}\n\n\t/**\n\t * Generates a circle packing having a pattern of tangencies specified by a\n\t * triangulation.\n\t * <p>\n\t * This is an implementation of 'A circle packing algorithm' by Charles R.\n\t * Collins & Kenneth Stephenson.\n\t * \n\t * @param triangulation represents the pattern of tangencies; vertices connected\n\t *                      by an edge inthe triangulation represent tangent circles\n\t *                      in the packing\n\t * @param boundaryRadii list of radii of circles associated with the\n\t *                      boundary/perimeter vertices of the triangulation. The\n\t *                      list may have fewer radii than the number of boundary\n\t *                      vertices; in this case, boundary radii will wrap around\n\t *                      the list\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius. The packing is centered on\n\t *         (0, 0) by default.\n\t * @since 1.3.0\n\t */\n\tpublic static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {\n\t\tTangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n\t\treturn pack.pack();\n\t}\n\n\t/**\n\t * Generates a random circle packing of circles with varying radii that overlap\n\t * the given shape.\n\t * <p>\n\t * Repulsion-packing involves iterative pair-repulsion, in which overlapping\n\t * circles move away from each other until there is no overlap. A packing is\n\t * first computed for the envelope of the shape, and then any circles which do\n\t * not overlap with the shape are discarded.\n\t * \n\t * @param shape     the shape from which to generate a circle packing\n\t * @param radiusMin minimum radius of circles in the packing. the radii\n\t *                  parameters can be the same.\n\t * @param radiusMax maximum radius of circles in the packing. the radii\n\t *                  parameters can be the same.\n\t * @param seed      for initial circle positions and radii\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @since 1.3.0\n\t * @see #repulsionPack(PShape, List)\n\t */\n\tpublic static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {\n\t\tfinal double rMinA = Math.max(1f, Math.min(radiusMin, radiusMax)); // actual min\n\t\tfinal double rMaxA = Math.max(1f, Math.max(radiusMin, radiusMax)); // actual max\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\n\t\t/*\n\t\t * We want spawn N circles, such that there are enough to (theoretically) cover\n\t\t * the envelope exactly without any overlap, assuming a packing efficiency of\n\t\t * ~85% (close to optimum).\n\t\t */\n\t\tdouble totalArea = e.getArea() * 0.85;\n\t\t/*\n\t\t * Average area is not a simple mean since circle area is quadratic with regards\n\t\t * to radius. The actual average area of circles with radii a...b is an integral\n\t\t * of: pi*r^2 dr from r=a to b.\n\t\t */\n\t\tdouble avgCircleArea = ((rMaxA * rMaxA * rMaxA) - (rMinA * rMinA * rMinA));\n\t\tavgCircleArea *= (Math.PI / (3 * (rMaxA - rMinA)));\n\t\tint n = (int) (totalArea / avgCircleArea);\n\n\t\tList<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n,\n\t\t\t\tseed);\n\t\tSplittableRandom r = new SplittableRandom(seed);\n\t\tpoints.forEach(p -> p.z = rMaxA == rMinA ? (float) rMaxA : (float) r.nextDouble(rMinA, rMaxA));\n\n\t\treturn repulsionPack(shape, points);\n\t}\n\n\t/**\n\t * Generates a circle packing of a shape using a given collection of\n\t * (overlapping) circles.\n\t * <p>\n\t * Circles in the input should be already bounded by the shape (since repulsion\n\t * does not push lonely circles towards the shape, but only repulses overlapping\n\t * circles); the intended input is one having circles with lots of overlap\n\t * (perhaps seeded within a small rectangle), where they may be repulsed from\n\t * each other to fill the shape.\n\t * <p>\n\t * Repulsion-packing involves iterative pair-repulsion, in which overlapping\n\t * circles move away from each other until there is no overlap. A packing is\n\t * first computed for the envelope of the shape, and then any circles which do\n\t * not overlap with the shape are discarded.\n\t * \n\t * @param shape   the shape from which to generate a circle packing\n\t * @param circles the collection of circles to pack the shape with, specified as\n\t *                PVectors, where .z is the radius (>=1) for each circle\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @since 1.3.0\n\t * @see #repulsionPack(PShape, double, double, long)\n\t */\n\tpublic static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\n\t\tfloat radiusMin = Float.MAX_VALUE;\n\t\tfloat radiusMax = Float.MIN_VALUE;\n\t\tfor (PVector circle : circles) {\n\t\t\tradiusMax = Math.max(1f, Math.max(radiusMax, circle.z));\n\t\t\tradiusMin = Math.max(1f, Math.min(radiusMin, circle.z));\n\t\t}\n\n\t\tfinal RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin,\n\t\t\t\te.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);\n\n\t\tfinal List<PVector> packing = packer.getPacking(); // packing result\n\n\t\tIndexedPointInAreaLocator pointLocator;\n\t\tif (radiusMin == radiusMax) {\n\t\t\t// if every circle same radius, use faster contains check\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n\t\t\tpacking.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n\t\t} else {\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g);\n\t\t\tIndexedFacetDistance distIndex = new IndexedFacetDistance(g);\n\t\t\tpacking.removeIf(p -> {\n\t\t\t\t// first test whether shape contains circle center point (somewhat faster)\n\t\t\t\tif (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn distIndex.distance(PGS.pointFromPVector(p)) > p.z * 0.5;\n\t\t\t});\n\t\t}\n\n\t\treturn packing;\n\t}\n\n\t/**\n\t * Generates a tiled circle packing consisting of equal-sized circles arranged\n\t * in a square lattice (or grid) bounded by the input shape.\n\t * <p>\n\t * Circles are included in the packing if they overlap with the given shape.\n\t * \n\t * @param shape    the shape from which to generate a circle packing\n\t * @param diameter diameter of every circle in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @see #hexLatticePack(PShape, double)\n\t */\n\tpublic static List<PVector> squareLatticePack(PShape shape, double diameter) {\n\t\tdiameter = Math.max(diameter, 0.1);\n\t\tfinal double radius = diameter / 2;\n\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\t// buffer the geometry to use InAreaLocator to test circles for overlap (this\n\t\t// works because all circles have the same diameter)\n\t\tfinal IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n\t\tfinal double w = e.getWidth() + diameter + e.getMinX();\n\t\tfinal double h = e.getHeight() + diameter + e.getMinY();\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tfor (double x = e.getMinX(); x < w; x += diameter) {\n\t\t\tfor (double y = e.getMinY(); y < h; y += diameter) {\n\t\t\t\tif (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n\t\t\t\t\tout.add(new PVector((float) x, (float) y, (float) radius));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a tiled circle packing consisting of equal-sized circles arranged\n\t * in a hexagonal lattice bounded by the input shape.\n\t * <p>\n\t * Circles are included in the packing if they overlap with the given shape.\n\t * \n\t * @param shape    the shape from which to generate a circle packing\n\t * @param diameter diameter of every circle in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @see #squareLatticePack(PShape, double)\n\t */\n\tpublic static List<PVector> hexLatticePack(PShape shape, double diameter) {\n\t\tdiameter = Math.max(diameter, 0.1);\n\t\tfinal double radius = diameter / 2d;\n\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\t/*\n\t\t * Buffer the geometry to use InAreaLocator to test circles for overlap (this\n\t\t * works because all circles have the same diameter).\n\t\t */\n\t\tfinal IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n\t\tfinal double w = e.getWidth() + diameter + e.getMinX();\n\t\tfinal double h = e.getHeight() + diameter + e.getMinY();\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tfinal double z = radius * Math.sqrt(3); // hex distance between successive columns\n\t\tdouble offset = 0;\n\t\tfor (double x = e.getMinX(); x < w; x += z) {\n\t\t\toffset = (offset == radius) ? 0 : radius;\n\t\t\tfor (double y = e.getMinY() - offset; y < h; y += diameter) {\n\t\t\t\tif (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n\t\t\t\t\tout.add(new PVector((float) x, (float) y, (float) radius));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Computes the incircle of a triangle; the largest circle contained in a given\n\t * triangle.\n\t * \n\t * @param t triangle\n\t * @return PVector, where x & y represent incenter coordinates, and z represents\n\t *         incircle radius.\n\t */\n\tprivate static PVector inCircle(SimpleTriangle t) {\n\t\tfinal double a = t.getEdgeA().getLength();\n\t\tfinal double b = t.getEdgeB().getLength();\n\t\tfinal double c = t.getEdgeC().getLength();\n\n\t\tdouble inCenterX = t.getVertexA().x * a + t.getVertexB().x * b + t.getVertexC().x * c;\n\t\tinCenterX /= (a + b + c);\n\t\tdouble inCenterY = t.getVertexA().y * a + t.getVertexB().y * b + t.getVertexC().y * c;\n\t\tinCenterY /= (a + b + c);\n\n\t\tfinal double s = (a + b + c) / 2; // semiPerimeter\n\n\t\tfinal double r = Math.sqrt(((s - a) * (s - b) * (s - c)) / s);\n\n\t\treturn new PVector((float) inCenterX, (float) inCenterY, (float) r);\n\t}\n\n\tprivate static PVector centroid(SimpleTriangle t) {\n\t\tfinal Vertex a = t.getVertexA();\n\t\tfinal Vertex b = t.getVertexB();\n\t\tfinal Vertex c = t.getVertexC();\n\t\tdouble x = a.x + b.x + c.x;\n\t\tx /= 3;\n\t\tdouble y = a.y + b.y + c.y;\n\t\ty /= 3;\n\t\treturn new PVector((float) x, (float) y);\n\t}\n\n\t/**\n\t * Calculate the distance between two points in 3D space, where each point\n\t * represents a circle with (x, y, r) coordinates. This custom metric considers\n\t * both the Euclidean distance between the centers of the circles and the\n\t * absolute difference of their radii.\n\t * <p>\n\t * The metric is defined as follows: Given two points A and B, representing\n\t * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,\n\t * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.\n\t * <p>\n\t * This metric can be used to find the nearest circle to a given center (x, y)\n\t * in a proximity search. To perform the search, use a point (x, y, R) where R\n\t * is greater than or equal to the maximum radius of a circle in the proximity\n\t * structure.\n\t *\n\t * @param p1 3D point representing the first circle (x1, y1, r1)\n\t * @param p2 3D point representing the second circle (x2, y2, r2)\n\t * @return the distance between the two points based on the custom metric\n\t */\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\n\t\t// from https://stackoverflow.com/a/21975136/\n\t\tfinal double dx = p1[0] - p2[0];\n\t\tfinal double dy = p1[1] - p2[1];\n\t\tfinal double dz = p1[2] - p2[2];\n\n\t\tdouble euclideanDistance = Math.sqrt(dx * dx + dy * dy);\n\t\tdouble absZDifference = Math.abs(dz);\n\t\treturn euclideanDistance + absZDifference; // negative if inside\n\t};\n\n\t/**\n\t * A streams filter to remove triangulation triangles that share at least one\n\t * edge with the shape edge.\n\t */\n\tprivate static final Predicate<SimpleTriangle> filterBorderTriangles = t -> t.getContainingRegion() != null\n\t\t\t&& !t.getEdgeA().isConstrainedRegionBorder() && !t.getEdgeB().isConstrainedRegionBorder()\n\t\t\t&& !t.getEdgeC().isConstrainedRegionBorder();\n\n}\n\n'''\nThe error is caused by a change in the API of the dependency: tinspin-indexes 1.7.1->2.0.0. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- org.tinspin.index.kdtree.KDTree.main\n-- org.tinspin.index.PointDistanceFunction\n-- org.tinspin.index.PointEntryDist\n-- org.tinspin.index.PointIndex\n-- org.tinspin.index.PointIndex.query1NN\n-- org.tinspin.index.covertree.CoverTree.query1NN\n-- org.tinspin.index.rtree.RTree.query1NN\n~~ SUPERTYPE_REMOVED <- org.tinspin.index.kdtree.KDTree\n~~ METHOD_RETURN_TYPE_CHANGED <- org.tinspin.index.covertree.CoverTree.query\n-- org.tinspin.index.kdtree.KDTree.query1NN\n-- org.tinspin.index.RectangleIndex.query1NN\n\nThe error is triggered in the following specific lines in the previous code:\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\nwith the following error message:\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol  symbol:   class PointEntryDist\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {",
    "error_message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol  symbol:   class PointEntryDist\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking",
    "api_diff": "-- org.tinspin.index.kdtree.KDTree.main\n-- org.tinspin.index.PointDistanceFunction\n-- org.tinspin.index.PointEntryDist\n-- org.tinspin.index.PointIndex\n-- org.tinspin.index.PointIndex.query1NN\n-- org.tinspin.index.covertree.CoverTree.query1NN\n-- org.tinspin.index.rtree.RTree.query1NN\n~~ SUPERTYPE_REMOVED <- org.tinspin.index.kdtree.KDTree\n~~ METHOD_RETURN_TYPE_CHANGED <- org.tinspin.index.covertree.CoverTree.query\n-- org.tinspin.index.kdtree.KDTree.query1NN\n-- org.tinspin.index.RectangleIndex.query1NN",
    "original_code": "package micycle.pgs;\n\nimport static micycle.pgs.PGS_Conversion.fromPShape;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\n\nimport org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;\nimport org.locationtech.jts.geom.Coordinate;\nimport org.locationtech.jts.geom.Envelope;\nimport org.locationtech.jts.geom.Geometry;\nimport org.locationtech.jts.geom.Location;\nimport org.locationtech.jts.geom.prep.PreparedGeometry;\nimport org.locationtech.jts.geom.prep.PreparedGeometryFactory;\nimport org.locationtech.jts.operation.distance.IndexedFacetDistance;\nimport org.locationtech.jts.util.GeometricShapeFactory;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinfour.common.SimpleTriangle;\nimport org.tinfour.common.Vertex;\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\nimport org.tinspin.index.covertree.CoverTree;\n\nimport micycle.pgs.commons.FrontChainPacker;\nimport micycle.pgs.commons.LargestEmptyCircles;\nimport micycle.pgs.commons.RepulsionCirclePack;\nimport micycle.pgs.commons.TangencyPack;\nimport processing.core.PShape;\nimport processing.core.PVector;\n\n/**\n * Circle packings of shapes, subject to varying constraints and patterns of\n * tangencies.\n * <p>\n * Each method produces a circle packing with different characteristics using a\n * different technique; for this reason input arguments vary across the methods.\n * <p>\n * The output of each method is a list of PVectors, each representing one\n * circle: (.x, .y) represent the center point and .z represents radius.\n * <p>\n * Where applicable, packings will include circles that overlap with the shape,\n * rather than only including those circles whose center point lies inside the\n * shape.\n * \n * @author Michael Carleton\n * @since 1.1.0\n *\n */\npublic final class PGS_CirclePacking {\n\n\t/*-\n\t * Roadmap (see/implement): 'A LINEARIZED CIRCLE PACKING ALGORITHM'? \n\t * 'A note on circle packing' Young Joon AHN.\n\t */\n\n\tprivate PGS_CirclePacking() {\n\t}\n\n\t/**\n\t * Packs circles of varying radii within a given shape, whilst respecting\n\t * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method\n\t * continues to generate circles until the sum of the areas of the circles\n\t * exceeds a specified proportion of the area of the given shape.\n\t * \n\t * @param shape          The shape within which circles will be packed. The\n\t *                       shape should be in the form of PShape.\n\t * @param pointObstacles A collection of PVector points representing obstacles,\n\t *                       around which circles are packed. Only points contained\n\t *                       within the shape are relevant.\n\t * @param areaCoverRatio The target ratio of the total area of the circles to\n\t *                       the area of the shape. This parameter should be a\n\t *                       double between 0 and 1. Circle generation will stop\n\t *                       when this ratio is reached.\n\t * @return A list of PVectors, where each PVector represents a circle. The x and\n\t *         y components of the PVector represent the center of the circle, and\n\t *         the z component represents the radius of the circle.\n\t * @since 1.4.0\n\t */\n\tpublic static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {\n\t\tfinal Geometry geometry = fromPShape(shape);\n\n\t\tLargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,\n\t\t\t\tareaCoverRatio > 0.95 ? 0.5 : 1);\n\n\t\tfinal double shapeArea = geometry.getArea();\n\t\tdouble circlesArea = 0;\n\t\tList<PVector> circles = new ArrayList<>();\n\n\t\twhile (circlesArea / shapeArea < areaCoverRatio) {\n\t\t\tdouble[] currentLEC = lec.findNextLEC();\n\t\t\tcircles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));\n\t\t\tcirclesArea += Math.PI * currentLEC[2] * currentLEC[2];\n\t\t\tif (currentLEC[2] < 0.5) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn circles;\n\t}\n\n\t/**\n\t * Generates a circle packing of the input shape, using the inscribed circles\n\t * (or incircles) of triangles from a triangulation of the shape.\n\t * <p>\n\t * Circles in this packing do not overlap and are contained entirely within the\n\t * shape. However, not every circle is necessarily tangent to others.\n\t * \n\t * @param shape       the shape from which to generate a circle packing\n\t * @param points      the number of random points to insert into the\n\t *                    triangulation as steiner points. Larger values lead to\n\t *                    more circles that are generally smaller.\n\t * @param refinements number of times to refine the underlying triangulation.\n\t *                    Larger values lead to more circles that are more regularly\n\t *                    spaced and sized. 0...3 is a suitable range for this\n\t *                    parameter\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {\n\t\tfinal List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);\n\t\tfinal IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);\n\t\treturn StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t))\n\t\t\t\t.collect(Collectors.toList());\n\t}\n\n\t/**\n\t * Generates a random circle packing of the input shape by generating random\n\t * points one-by-one and calculating the maximum radius a circle at each point\n\t * can have (such that it's tangent to its nearest circle or a shape vertex).\n\t * <p>\n\t * Notably, the {@code points} argument defines the number of random point\n\t * attempts (or circle attempts), and not the number of circles in the final\n\t * packing output, since a point is rejected if it lies in an existing circle or\n\t * whose nearest circle is less than minRadius distance away. In other words,\n\t * {@code points} defines the maximum number of circles the packing can have; in\n\t * practice, the packing will contain somewhat fewer circles.\n\t * <p>\n\t * Circles in this packing do not overlap and are contained entirely within the\n\t * shape. However, not every circle is necessarily tangent to other circles (in\n\t * which case, such a circle will be tangent to a shape vertex).\n\t * \n\t * @param shape             the shape from which to generate a circle packing\n\t * @param points            number of random points to generate (this is not the\n\t *                          number of circles in the packing).\n\t * @param minRadius         filter (however not simply applied at the end, so\n\t *                          affects how the packing operates during packing)\n\t * @param triangulatePoints when true, triangulates an initial random point set\n\t *                          and uses triangle centroids as the random point set\n\t *                          instead; this results in a packing that covers the\n\t *                          shape more evenly (particularly when points is\n\t *                          small), which is sometimes desirable\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {\n\t\treturn stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());\n\t}\n\n\t/**\n\t * \n\t * Generates a seeded random circle packing within the input shape. Circles are\n\t * created one-by-one by generating random points and calculating the maximum\n\t * possible radius for a circle at each point, ensuring it is tangent to its\n\t * nearest circle or shape vertex.\n\t * <p>\n\t * The {@code points} parameter defines the number of random point attempts (or\n\t * circle attempts), but not the exact number of circles in the final packing\n\t * output. An attempted point is rejected if it lies within an existing circle\n\t * or if its nearest circle is less than {@code minRadius} distance away.\n\t * <p>\n\t * Thus, {@code points} defines the maximum number of circles the packing can\n\t * have; in practice, the packing will contain somewhat fewer circles.\n\t * <p>\n\t * The generated circles in the packing do not overlap and are contained\n\t * entirely within the shape. However, not every circle is necessarily tangent\n\t * to other circles; such circles will be tangent to a shape vertex.\n\t * \n\t * @param shape             the shape within which to generate the circle\n\t *                          packing\n\t * @param points            number of random points to generate (not necessarily\n\t *                          equal to the number of circles in the packing)\n\t * @param minRadius         minimum allowed radius for circles in the packing\n\t *                          (affects packing generation, not applied as a filter\n\t *                          at the end)\n\t * @param triangulatePoints when true, triangulates the initial random point set\n\t *                          and uses triangle centroids as the random point set\n\t *                          instead; results in a more evenly distributed\n\t *                          packing (particularly when the number of points is\n\t *                          small), which may be desirable\n\t * @param seed              random seed used to initialize the underlying random\n\t *                          number generator\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point, and .z represents the radius.\n\t */\n\tpublic static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints,\n\t\t\tlong seed) {\n\n\t\tfinal CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tList<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);\n\t\tif (triangulatePoints) {\n\t\t\tfinal IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);\n\t\t\tsteinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)\n\t\t\t\t\t.map(PGS_CirclePacking::centroid).collect(Collectors.toList());\n\t\t}\n\n\t\t// Model shape vertices as circles of radius 0, to constrain packed circles\n\t\t// within shape edge\n\t\tfinal List<PVector> vertices = PGS_Conversion.toPVector(shape);\n\t\tCollections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion\n\t\tvertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));\n\n\t\t/*\n\t\t * \"To find the circle nearest to a center (x, y), do a proximity search at (x,\n\t\t * y, R), where R is greater than or equal to the maximum radius of a circle.\"\n\t\t */\n\t\tfloat largestR = 0; // the radius of the largest circle in the tree\n\n\t\tfor (PVector p : steinerPoints) {\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\n\t\t\t/*\n\t\t\t * nn.dist() does not return the radius (since it's a distance metric used to\n\t\t\t * find nearest circle), so calculate maximum radius for candidate circle using\n\t\t\t * 2d euclidean distance between center points minus radius of nearest circle.\n\t\t\t */\n\t\t\tfinal float dx = p.x - nn.value().x;\n\t\t\tfinal float dy = p.y - nn.value().y;\n\t\t\tfinal float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);\n\t\t\tif (radius > minRadius) {\n\t\t\t\tlargestR = (radius >= largestR) ? radius : largestR;\n\t\t\t\tp.z = radius;\n\t\t\t\ttree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree\n\t\t\t\tout.add(p);\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a random circle packing of tangential circles with varying radii\n\t * that overlap the given shape. The method name references the packing\n\t * algorithm used (Front Chain Packing), rather than any particular\n\t * characteristic of the circle packing.\n\t * <p>\n\t * You can set <code>radiusMin</code> equal to <code>radiusMax</code> for a\n\t * packing of equal-sized circles using this approach.\n\t *\n\t * @param shape     the shape within which to generate the circle packing\n\t * @param radiusMin minimum radius of circles in the packing\n\t * @param radiusMax maximum radius of circles in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {\n\t\tradiusMin = Math.max(1f, Math.min(radiusMin, radiusMax)); // choose min and constrain\n\t\tradiusMax = Math.max(1f, Math.max(radiusMin, radiusMax)); // choose max and constrain\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\tIndexedPointInAreaLocator pointLocator;\n\n\t\tfinal FrontChainPacker packer = new FrontChainPacker((float) e.getWidth(), (float) e.getHeight(), (float) radiusMin,\n\t\t\t\t(float) radiusMax, (float) e.getMinX(), (float) e.getMinY());\n\n\t\tif (radiusMin == radiusMax) {\n\t\t\t// if every circle same radius, use faster contains check\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n\t\t\tpacker.getCircles().removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n\t\t} else {\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g);\n\t\t\tfinal PreparedGeometry cache = PreparedGeometryFactory.prepare(g);\n\t\t\tfinal GeometricShapeFactory circleFactory = new GeometricShapeFactory();\n\t\t\tcircleFactory.setNumPoints(8); // approximate circles using octagon for intersects check\n\t\t\tpacker.getCircles().removeIf(p -> {\n\t\t\t\t// first test whether shape contains circle center point (somewhat faster)\n\t\t\t\tif (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// if center point not in circle, check whether circle overlaps with shape using\n\t\t\t\t// intersects() (somewhat slower)\n\t\t\t\tcircleFactory.setCentre(PGS.coordFromPVector(p));\n\t\t\t\tcircleFactory.setSize(p.z * 2); // set diameter\n\t\t\t\treturn !cache.intersects(circleFactory.createCircle());\n\t\t\t});\n\t\t}\n\n\t\treturn packer.getCircles();\n\t}\n\n\t/**\n\t * Packs a specified number of maximum inscribed circles within the given shape\n\t * using the Largest Empty Circle (LEC) algorithm.\n\t * <p>\n\t * This method finds and returns the maximum inscribed circles up to the\n\t * specified number (n), starting with the largest circle. It uses a tolerance\n\t * value to control the accuracy of the LEC algorithm.\n\t *\n\t * @param shape     The input shape to pack maximum inscribed circles within.\n\t * @param n         The number of maximum inscribed circles to find and pack.\n\t * @param tolerance The tolerance value to control the LEC algorithm's accuracy.\n\t *                  Higher values yield faster results but lower accuracy. A\n\t *                  value of a 1 is good staring point.\n\t * @return A list of PVector objects representing the centers (.x, .y) and radii\n\t *         (.z) of the maximum inscribed circles.\n\t */\n\tpublic static List<PVector> maximumInscribedPack(PShape shape, int n, double tolerance) {\n\t\ttolerance = Math.max(0.01, tolerance);\n\t\tLargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble[] c = mics.findNextLEC();\n\t\t\tout.add(new PVector((float) c[0], (float) c[1], (float) c[2]));\n\t\t}\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Packs maximum inscribed circles within the given shape using the Largest\n\t * Empty Circle (LEC) algorithm.\n\t * <p>\n\t * This method finds and returns the maximum inscribed circles with a radius\n\t * equal to or larger than the specified minimum radius. It uses a tolerance\n\t * value to control the accuracy of the LEC algorithm.\n\t *\n\t * @param shape     The input shape to pack maximum inscribed circles within.\n\t * @param minRadius The minimum allowed radius for the inscribed circles.\n\t * @param tolerance The tolerance value to control the LEC algorithm's accuracy.\n\t *                  Higher values yield faster results but lower accuracy. A\n\t *                  value of a 1 is good staring point.\n\t * @return A list of PVector objects representing the centers (.x, .y) and radii\n\t *         (.z) of the maximum inscribed circles.\n\t */\n\tpublic static List<PVector> maximumInscribedPack(PShape shape, double minRadius, double tolerance) {\n\t\ttolerance = Math.max(0.01, tolerance);\n\t\tminRadius = Math.max(0.01, minRadius);\n\t\tLargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\t\tdouble[] currentLEC;\n\t\tdo {\n\t\t\tcurrentLEC = mics.findNextLEC();\n\t\t\tif (currentLEC[2] >= minRadius) {\n\t\t\t\tout.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));\n\t\t\t}\n\t\t} while (currentLEC[2] >= minRadius);\n\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a circle packing having a pattern of tangencies specified by a\n\t * triangulation.\n\t * \n\t * <p>\n\t * This is an implementation of 'A circle packing algorithm' by Charles R.\n\t * Collins & Kenneth Stephenson.\n\t * \n\t * @param triangulation represents the pattern of tangencies; vertices connected\n\t *                      by an edge inthe triangulation represent tangent circles\n\t *                      in thepacking\n\t * @param boundaryRadii radius of every circle associated with the\n\t *                      boundary/perimeter vertices of the triangulation\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t */\n\tpublic static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {\n\t\tTangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n\t\treturn pack.pack();\n\t}\n\n\t/**\n\t * Generates a circle packing having a pattern of tangencies specified by a\n\t * triangulation.\n\t * <p>\n\t * This is an implementation of 'A circle packing algorithm' by Charles R.\n\t * Collins & Kenneth Stephenson.\n\t * \n\t * @param triangulation represents the pattern of tangencies; vertices connected\n\t *                      by an edge inthe triangulation represent tangent circles\n\t *                      in the packing\n\t * @param boundaryRadii list of radii of circles associated with the\n\t *                      boundary/perimeter vertices of the triangulation. The\n\t *                      list may have fewer radii than the number of boundary\n\t *                      vertices; in this case, boundary radii will wrap around\n\t *                      the list\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius. The packing is centered on\n\t *         (0, 0) by default.\n\t * @since 1.3.0\n\t */\n\tpublic static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {\n\t\tTangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n\t\treturn pack.pack();\n\t}\n\n\t/**\n\t * Generates a random circle packing of circles with varying radii that overlap\n\t * the given shape.\n\t * <p>\n\t * Repulsion-packing involves iterative pair-repulsion, in which overlapping\n\t * circles move away from each other until there is no overlap. A packing is\n\t * first computed for the envelope of the shape, and then any circles which do\n\t * not overlap with the shape are discarded.\n\t * \n\t * @param shape     the shape from which to generate a circle packing\n\t * @param radiusMin minimum radius of circles in the packing. the radii\n\t *                  parameters can be the same.\n\t * @param radiusMax maximum radius of circles in the packing. the radii\n\t *                  parameters can be the same.\n\t * @param seed      for initial circle positions and radii\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @since 1.3.0\n\t * @see #repulsionPack(PShape, List)\n\t */\n\tpublic static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {\n\t\tfinal double rMinA = Math.max(1f, Math.min(radiusMin, radiusMax)); // actual min\n\t\tfinal double rMaxA = Math.max(1f, Math.max(radiusMin, radiusMax)); // actual max\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\n\t\t/*\n\t\t * We want spawn N circles, such that there are enough to (theoretically) cover\n\t\t * the envelope exactly without any overlap, assuming a packing efficiency of\n\t\t * ~85% (close to optimum).\n\t\t */\n\t\tdouble totalArea = e.getArea() * 0.85;\n\t\t/*\n\t\t * Average area is not a simple mean since circle area is quadratic with regards\n\t\t * to radius. The actual average area of circles with radii a...b is an integral\n\t\t * of: pi*r^2 dr from r=a to b.\n\t\t */\n\t\tdouble avgCircleArea = ((rMaxA * rMaxA * rMaxA) - (rMinA * rMinA * rMinA));\n\t\tavgCircleArea *= (Math.PI / (3 * (rMaxA - rMinA)));\n\t\tint n = (int) (totalArea / avgCircleArea);\n\n\t\tList<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n,\n\t\t\t\tseed);\n\t\tSplittableRandom r = new SplittableRandom(seed);\n\t\tpoints.forEach(p -> p.z = rMaxA == rMinA ? (float) rMaxA : (float) r.nextDouble(rMinA, rMaxA));\n\n\t\treturn repulsionPack(shape, points);\n\t}\n\n\t/**\n\t * Generates a circle packing of a shape using a given collection of\n\t * (overlapping) circles.\n\t * <p>\n\t * Circles in the input should be already bounded by the shape (since repulsion\n\t * does not push lonely circles towards the shape, but only repulses overlapping\n\t * circles); the intended input is one having circles with lots of overlap\n\t * (perhaps seeded within a small rectangle), where they may be repulsed from\n\t * each other to fill the shape.\n\t * <p>\n\t * Repulsion-packing involves iterative pair-repulsion, in which overlapping\n\t * circles move away from each other until there is no overlap. A packing is\n\t * first computed for the envelope of the shape, and then any circles which do\n\t * not overlap with the shape are discarded.\n\t * \n\t * @param shape   the shape from which to generate a circle packing\n\t * @param circles the collection of circles to pack the shape with, specified as\n\t *                PVectors, where .z is the radius (>=1) for each circle\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @since 1.3.0\n\t * @see #repulsionPack(PShape, double, double, long)\n\t */\n\tpublic static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\n\t\tfloat radiusMin = Float.MAX_VALUE;\n\t\tfloat radiusMax = Float.MIN_VALUE;\n\t\tfor (PVector circle : circles) {\n\t\t\tradiusMax = Math.max(1f, Math.max(radiusMax, circle.z));\n\t\t\tradiusMin = Math.max(1f, Math.min(radiusMin, circle.z));\n\t\t}\n\n\t\tfinal RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin,\n\t\t\t\te.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);\n\n\t\tfinal List<PVector> packing = packer.getPacking(); // packing result\n\n\t\tIndexedPointInAreaLocator pointLocator;\n\t\tif (radiusMin == radiusMax) {\n\t\t\t// if every circle same radius, use faster contains check\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n\t\t\tpacking.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n\t\t} else {\n\t\t\tpointLocator = new IndexedPointInAreaLocator(g);\n\t\t\tIndexedFacetDistance distIndex = new IndexedFacetDistance(g);\n\t\t\tpacking.removeIf(p -> {\n\t\t\t\t// first test whether shape contains circle center point (somewhat faster)\n\t\t\t\tif (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\treturn distIndex.distance(PGS.pointFromPVector(p)) > p.z * 0.5;\n\t\t\t});\n\t\t}\n\n\t\treturn packing;\n\t}\n\n\t/**\n\t * Generates a tiled circle packing consisting of equal-sized circles arranged\n\t * in a square lattice (or grid) bounded by the input shape.\n\t * <p>\n\t * Circles are included in the packing if they overlap with the given shape.\n\t * \n\t * @param shape    the shape from which to generate a circle packing\n\t * @param diameter diameter of every circle in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @see #hexLatticePack(PShape, double)\n\t */\n\tpublic static List<PVector> squareLatticePack(PShape shape, double diameter) {\n\t\tdiameter = Math.max(diameter, 0.1);\n\t\tfinal double radius = diameter / 2;\n\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\t// buffer the geometry to use InAreaLocator to test circles for overlap (this\n\t\t// works because all circles have the same diameter)\n\t\tfinal IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n\t\tfinal double w = e.getWidth() + diameter + e.getMinX();\n\t\tfinal double h = e.getHeight() + diameter + e.getMinY();\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tfor (double x = e.getMinX(); x < w; x += diameter) {\n\t\t\tfor (double y = e.getMinY(); y < h; y += diameter) {\n\t\t\t\tif (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n\t\t\t\t\tout.add(new PVector((float) x, (float) y, (float) radius));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Generates a tiled circle packing consisting of equal-sized circles arranged\n\t * in a hexagonal lattice bounded by the input shape.\n\t * <p>\n\t * Circles are included in the packing if they overlap with the given shape.\n\t * \n\t * @param shape    the shape from which to generate a circle packing\n\t * @param diameter diameter of every circle in the packing\n\t * @return A list of PVectors, each representing one circle: (.x, .y) represent\n\t *         the center point and .z represents radius.\n\t * @see #squareLatticePack(PShape, double)\n\t */\n\tpublic static List<PVector> hexLatticePack(PShape shape, double diameter) {\n\t\tdiameter = Math.max(diameter, 0.1);\n\t\tfinal double radius = diameter / 2d;\n\n\t\tfinal Geometry g = fromPShape(shape);\n\t\tfinal Envelope e = g.getEnvelopeInternal();\n\t\t/*\n\t\t * Buffer the geometry to use InAreaLocator to test circles for overlap (this\n\t\t * works because all circles have the same diameter).\n\t\t */\n\t\tfinal IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n\t\tfinal double w = e.getWidth() + diameter + e.getMinX();\n\t\tfinal double h = e.getHeight() + diameter + e.getMinY();\n\n\t\tfinal List<PVector> out = new ArrayList<>();\n\n\t\tfinal double z = radius * Math.sqrt(3); // hex distance between successive columns\n\t\tdouble offset = 0;\n\t\tfor (double x = e.getMinX(); x < w; x += z) {\n\t\t\toffset = (offset == radius) ? 0 : radius;\n\t\t\tfor (double y = e.getMinY() - offset; y < h; y += diameter) {\n\t\t\t\tif (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n\t\t\t\t\tout.add(new PVector((float) x, (float) y, (float) radius));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * Computes the incircle of a triangle; the largest circle contained in a given\n\t * triangle.\n\t * \n\t * @param t triangle\n\t * @return PVector, where x & y represent incenter coordinates, and z represents\n\t *         incircle radius.\n\t */\n\tprivate static PVector inCircle(SimpleTriangle t) {\n\t\tfinal double a = t.getEdgeA().getLength();\n\t\tfinal double b = t.getEdgeB().getLength();\n\t\tfinal double c = t.getEdgeC().getLength();\n\n\t\tdouble inCenterX = t.getVertexA().x * a + t.getVertexB().x * b + t.getVertexC().x * c;\n\t\tinCenterX /= (a + b + c);\n\t\tdouble inCenterY = t.getVertexA().y * a + t.getVertexB().y * b + t.getVertexC().y * c;\n\t\tinCenterY /= (a + b + c);\n\n\t\tfinal double s = (a + b + c) / 2; // semiPerimeter\n\n\t\tfinal double r = Math.sqrt(((s - a) * (s - b) * (s - c)) / s);\n\n\t\treturn new PVector((float) inCenterX, (float) inCenterY, (float) r);\n\t}\n\n\tprivate static PVector centroid(SimpleTriangle t) {\n\t\tfinal Vertex a = t.getVertexA();\n\t\tfinal Vertex b = t.getVertexB();\n\t\tfinal Vertex c = t.getVertexC();\n\t\tdouble x = a.x + b.x + c.x;\n\t\tx /= 3;\n\t\tdouble y = a.y + b.y + c.y;\n\t\ty /= 3;\n\t\treturn new PVector((float) x, (float) y);\n\t}\n\n\t/**\n\t * Calculate the distance between two points in 3D space, where each point\n\t * represents a circle with (x, y, r) coordinates. This custom metric considers\n\t * both the Euclidean distance between the centers of the circles and the\n\t * absolute difference of their radii.\n\t * <p>\n\t * The metric is defined as follows: Given two points A and B, representing\n\t * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,\n\t * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.\n\t * <p>\n\t * This metric can be used to find the nearest circle to a given center (x, y)\n\t * in a proximity search. To perform the search, use a point (x, y, R) where R\n\t * is greater than or equal to the maximum radius of a circle in the proximity\n\t * structure.\n\t *\n\t * @param p1 3D point representing the first circle (x1, y1, r1)\n\t * @param p2 3D point representing the second circle (x2, y2, r2)\n\t * @return the distance between the two points based on the custom metric\n\t */\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\n\t\t// from https://stackoverflow.com/a/21975136/\n\t\tfinal double dx = p1[0] - p2[0];\n\t\tfinal double dy = p1[1] - p2[1];\n\t\tfinal double dz = p1[2] - p2[2];\n\n\t\tdouble euclideanDistance = Math.sqrt(dx * dx + dy * dy);\n\t\tdouble absZDifference = Math.abs(dz);\n\t\treturn euclideanDistance + absZDifference; // negative if inside\n\t};\n\n\t/**\n\t * A streams filter to remove triangulation triangles that share at least one\n\t * edge with the shape edge.\n\t */\n\tprivate static final Predicate<SimpleTriangle> filterBorderTriangles = t -> t.getContainingRegion() != null\n\t\t\t&& !t.getEdgeA().isConstrainedRegionBorder() && !t.getEdgeB().isConstrainedRegionBorder()\n\t\t\t&& !t.getEdgeC().isConstrainedRegionBorder();\n\n}\n",
    "project": "PGS",
    "libraryName": "tinspin-indexes",
    "libraryGroupID": "org.tinspin",
    "newVersion": "2.0.0",
    "previousVersion": "1.7.1",
    "breakingCommit": "ef3f7be3e2755d4a0f9c23bdcbfe3b97198fb31b"
}