{
    "absolute_path_to_file_in_container": "/bval/bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java",
    "errors": [
        {
            "line_number": 318,
            "message": "[ERROR] /bval/bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java:[318,49] cannot find symbol",
            "additional_info": "  symbol:   method getArgumentAt(int,java.lang.Class<java.lang.Class>)\n  location: variable invocation of type org.mockito.invocation.InvocationOnMock",
            "file_name": "DefaultMessageInterpolatorTest.java",
            "BCs": [
                {
                    "element": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find",
                    "nature": "MUTATION",
                    "kind": "METHOD_NOW_FINAL"
                },
                {
                    "element": "org.mockito.internal.invocation.finder.AllInvocationsFinder.find",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.mockito.invocation.Invocation",
                    "nature": "ADDITION",
                    "kind": "METHOD_ADDED_TO_INTERFACE"
                },
                {
                    "element": "org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find",
                    "nature": "MUTATION",
                    "kind": "METHOD_NOW_STATIC"
                },
                {
                    "element": "org.mockito.invocation.InvocationOnMock",
                    "nature": "ADDITION",
                    "kind": "METHOD_ADDED_TO_INTERFACE"
                },
                {
                    "element": "org.mockito.Mockito.mock",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.mockito.invocation.InvocationOnMock.getArgumentAt",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.mockito.Answers.get",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.mockito.invocation.Invocation",
                    "nature": "MUTATION",
                    "kind": "SUPERTYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.stubbing.Answer,java.lang.Object[])",
                "++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.MockSettings,java.lang.Object[])",
                "++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.String,java.lang.Object[])",
                "++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.Object[])"
            ],
            "uid": "5a8b4e7f-fc59-5402-86a8-e490ce6ae74c"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: mockito-core 1.10.19->5.1.1. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n~~ METHOD_NOW_FINAL <- org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find\n-- org.mockito.internal.invocation.finder.AllInvocationsFinder.find\n++ METHOD_ADDED_TO_INTERFACE <- org.mockito.invocation.Invocation\n~~ METHOD_NOW_STATIC <- org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find\n++ METHOD_ADDED_TO_INTERFACE <- org.mockito.invocation.InvocationOnMock\n-- org.mockito.Mockito.mock\n-- org.mockito.invocation.InvocationOnMock.getArgumentAt\n-- org.mockito.Answers.get\n~~ SUPERTYPE_REMOVED <- org.mockito.invocation.Invocation\n++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.String,java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.MockSettings,java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.stubbing.Answer,java.lang.Object[])\n\nThe error is triggered in the following specific lines in the previous code:\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\nwith the following error message:\n[ERROR] /bval/bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java:[318,49] cannot find symbol  symbol:   method getArgumentAt(int,java.lang.Class<java.lang.Class>)\n  location: variable invocation of type org.mockito.invocation.InvocationOnMock\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));",
    "error_message": "[ERROR] /bval/bval-jsr/src/test/java/org/apache/bval/jsr/DefaultMessageInterpolatorTest.java:[318,49] cannot find symbol  symbol:   method getArgumentAt(int,java.lang.Class<java.lang.Class>)\n  location: variable invocation of type org.mockito.invocation.InvocationOnMock",
    "api_diff": "~~ METHOD_NOW_FINAL <- org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find\n-- org.mockito.internal.invocation.finder.AllInvocationsFinder.find\n++ METHOD_ADDED_TO_INTERFACE <- org.mockito.invocation.Invocation\n~~ METHOD_NOW_STATIC <- org.mockito.internal.invocation.finder.VerifiableInvocationsFinder.find\n++ METHOD_ADDED_TO_INTERFACE <- org.mockito.invocation.InvocationOnMock\n-- org.mockito.Mockito.mock\n-- org.mockito.invocation.InvocationOnMock.getArgumentAt\n-- org.mockito.Answers.get\n~~ SUPERTYPE_REMOVED <- org.mockito.invocation.Invocation\n++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.String,java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.MockSettings,java.lang.Object[])\n++ public static transient java.lang.Object org.mockito.Mockito.mock(org.mockito.stubbing.Answer,java.lang.Object[])",
    "original_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.bval.jsr;\n\nimport static org.hamcrest.CoreMatchers.anyOf;\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeThat;\nimport static org.junit.Assume.assumeTrue;\nimport static org.mockito.Mockito.any;\nimport static org.mockito.Mockito.when;\n\nimport java.lang.annotation.Annotation;\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.*;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\nimport jakarta.el.ExpressionFactory;\nimport jakarta.validation.MessageInterpolator;\nimport jakarta.validation.Validator;\nimport jakarta.validation.constraints.Digits;\nimport jakarta.validation.constraints.Pattern;\nimport jakarta.validation.metadata.ConstraintDescriptor;\n\nimport org.apache.bval.constraints.NotEmpty;\nimport org.apache.bval.jsr.example.Author;\nimport org.apache.bval.jsr.example.PreferredGuest;\nimport org.junit.After;\nimport org.junit.AfterClass;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\nimport org.mockito.Mockito;\n\n/**\n * MessageResolverImpl Tester.\n */\n@RunWith(Parameterized.class)\npublic class DefaultMessageInterpolatorTest {\n    @Parameters(name=\"{0}\")\n    public static List<Object[]> generateParameters(){\n        return Arrays.asList(new Object[] { \"default\", null },\n            new Object[] { \"ri\", \"org.glassfish.expressly.ExpressionFactoryImpl\" },\n            new Object[] { \"tomcat\", \"org.apache.el.ExpressionFactoryImpl\" },\n            new Object[] { \"invalid\", \"java.lang.String\" });\n    }\n\n    @AfterClass\n    public static void cleanup() {\n        System.clearProperty(ExpressionFactory.class.getName());\n    }\n\n    private static Predicate<ConstraintDescriptor<?>> forConstraintType(Class<? extends Annotation> type) {\n        return d -> Objects.equals(type, d.getAnnotation().annotationType());\n    }\n\n    private String elImpl;\n    private String elFactory;\n    private DefaultMessageInterpolator interpolator;\n    private Validator validator;\n    private boolean elAvailable;\n    private ClassLoader originalClassLoader;\n\n    public DefaultMessageInterpolatorTest(String elImpl, String elFactory) {\n        this.elImpl = elImpl;\n        this.elFactory = elFactory;\n    }\n\n    @Before\n    public void setUp() throws Exception {\n        // store and replace CCL to sidestep EL factory caching\n        originalClassLoader = Thread.currentThread().getContextClassLoader();\n        Thread.currentThread().setContextClassLoader(new URLClassLoader(new URL[] {}, originalClassLoader));\n\n        try {\n            if (elFactory == null) {\n                System.clearProperty(ExpressionFactory.class.getName());\n            } else {\n                Class<?> elFactoryClass = Class.forName(elFactory);\n                System.setProperty(ExpressionFactory.class.getName(), elFactory);\n\n                Class<? extends ExpressionFactory> usedImpl =\n                        ((DelegateExpressionFactory) ExpressionFactory.newInstance()).getWrapped().getClass();\n                assertTrue(elFactoryClass == usedImpl);\n            }\n            elAvailable = true;\n        } catch (Exception e) {\n            elAvailable = false;\n        }\n        interpolator = new DefaultMessageInterpolator();\n        interpolator.setLocale(Locale.ENGLISH);\n        validator = ApacheValidatorFactory.getDefault().getValidator();\n    }\n\n    @After\n    public void tearDownEL() {\n        assumeTrue(originalClassLoader != null);\n        Thread.currentThread().setContextClassLoader(originalClassLoader);\n    }\n\n    @Test\n    public void testInterpolateFromValidationResources() {\n        String msg = interpolator.interpolate(\"{validator.creditcard}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(PreferredGuest.class)\n                    .getConstraintsForProperty(\"guestCreditCardNumber\").getConstraintDescriptors().stream()\n                    .filter(forConstraintType(Digits.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"credit card is not valid\", msg);\n    }\n\n    @Test\n    public void testInterpolateFromDefaultResources() {\n        String msg = interpolator.interpolate(\"{org.apache.bval.constraints.NotEmpty.message}\",\n            context(\"\",\n                () -> validator.getConstraintsForClass(Author.class).getConstraintsForProperty(\"lastName\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(NotEmpty.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"may not be empty\", msg);\n    }\n\n    /**\n     * Checks that strings containing special characters are correctly\n     * substituted when interpolating.\n     */\n    @Test\n    public void testReplacementWithSpecialChars() {\n        // Try to interpolate an annotation attribute containing $\n        String idNumberResult = this.interpolator.interpolate(\"Id number should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when $ is in an attribute\", \"Id number should match ....$\",\n            idNumberResult);\n\n        // Try to interpolate an annotation attribute containing \\\n        String otherIdResult = this.interpolator.interpolate(\"Other id should match {regexp}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"otherId\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"Incorrect message interpolation when \\\\ is in an attribute value\", \"Other id should match .\\\\n\",\n            otherIdResult);\n    }\n\n    @Test\n    public void testRecursiveInterpolation() {\n        String msg = this.interpolator.interpolate(\"{recursive.interpolation.1}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\"))));\n\n        assertEquals(\"must match \\\"....$\\\"\", msg);\n    }\n\n    @Test\n    public void testNoELAvailable() {\n        assumeThat(elImpl, equalTo(\"invalid\"));\n        assertFalse(elAvailable);\n        \n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testDisallowCustomTemplateExpressionEvaluationByDefault() {\n        assumeTrue(elAvailable);\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"${regexp.charAt(4)}\",\n            context(\"12345678\",\n                () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @Test\n    public void testExpressionLanguageEvaluation() {\n        assumeTrue(elAvailable);\n        \n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"anotherValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Another value should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testMixedEvaluation() {\n        assumeTrue(elAvailable);\n\n        final MessageInterpolator.Context context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"mixedMessageValue\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n        \n        assertEquals(\"Mixed message value of length 8 should match ....$\",\n            interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));\n    }\n\n    @Test\n    public void testELEscapingTomcatJuel() {\n        assumeTrue(elAvailable);\n        assumeThat(elImpl, anyOf(equalTo(\"tomcat\")));\n\n        // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading\n        // backslashes and treats the whole expression as literal. We could skip any literal text before the first\n        // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more\n        // than one component EL expression\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n            .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n            .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n                .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n            context));\n\n        assertEquals(\"${regexp.charAt(4)}\", interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n            context));\n    }\n\n    @Test\n    public void testELEscapingRI() {\n        assumeTrue(elAvailable);\n            assumeThat(elImpl, equalTo(\"ri\"));\n\n        ApacheMessageContext context = context(\"12345678\",\n            () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                .orElseThrow(() -> new AssertionError(\"expected constraint missing\")));\n\n        when(context\n            .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))\n        .thenAnswer(invocation -> Boolean.toString(true));\n\n        assertEquals(\"returns literal\", \"${regexp.charAt(4)}\",\n            interpolator.interpolate(\"\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by $, later interpreted as an escape sequence\", \"$\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(4)}\",\n                context));\n\n        assertEquals(\"returns literal \\\\ followed by .\", \"\\\\.\",\n            interpolator.interpolate(\"\\\\\\\\${regexp.charAt(3)}\",\n                context));\n    }\n\n    @Test\n    public void testEscapedELPattern() {\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                        .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                        .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n\n        assertEquals(\"\\\\$must match \\\"....$\\\"\",\n            interpolator.interpolate(\"\\\\\\\\\\\\${jakarta.validation.constraints.Pattern.message}\",\n                context(\"12345678\",\n                    () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty(\"idNumber\")\n                    .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()\n                    .orElseThrow(() -> new AssertionError(\"expected constraint missing\")))));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private ApacheMessageContext context(Object validatedValue, Supplier<ConstraintDescriptor<?>> descriptor) {\n        final ApacheMessageContext result = Mockito.mock(ApacheMessageContext.class);\n        when(result.unwrap(any(Class.class)))\n            .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));\n        when(result.getValidatedValue()).thenReturn(validatedValue);\n        when(result.getConstraintDescriptor()).thenAnswer(invocation -> descriptor.get());\n        return result;\n    }\n\n    public static class Person {\n\n        @Pattern(message = \"Id number should match {regexp}\", regexp = \"....$\")\n        public String idNumber;\n\n        @Pattern(message = \"Other id should match {regexp}\", regexp = \".\\\\n\")\n        public String otherId;\n\n        @Pattern(message = \"Another value should match ${regexp.intern()}\", regexp = \"....$\")\n        public String anotherValue;\n        \n        @Pattern(message = \"Mixed message value of length ${validatedValue.length()} should match {regexp}\", regexp = \"....$\")\n        public String mixedMessageValue;\n    }\n}\n",
    "project": "bval",
    "libraryName": "mockito-core",
    "libraryGroupID": "org.mockito",
    "newVersion": "5.1.1",
    "previousVersion": "1.10.19",
    "breakingCommit": "2dfaa41bfb97674d11f09a5885011f19808548a3"
}