{
    "relative_path": "plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java",
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nthe following client code fails: \n'''java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ClosedInputStream();\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n\nwith the following error message:\n[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[29,35] cannot find symbol  symbol:   class ClosedInputStream\n  location: package org.apache.commons.io.input\n[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[401,24] cannot find symbol  symbol:   class ClosedInputStream\n  location: class org.codehaus.plexus.archiver.zip.ByteArrayOutputStream\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.apache.commons.io.output.ByteArrayOutputStream | DELETION | TYPE_REMOVED\norg.apache.commons.io.input.CountingInputStream.resetCount | DELETION | METHOD_REMOVED\norg.apache.commons.io.output.DemuxOutputStream.close | MUTATION | METHOD_NOW_FINAL\norg.apache.commons.io.output.ThresholdingOutputStream | DELETION | TYPE_REMOVED\norg.apache.commons.io.output.DemuxOutputStream.write | MUTATION | METHOD_NOW_FINAL\njava.io.InputStream.transferTo | DELETION | METHOD_REMOVED\norg.apache.commons.io.input.CountingInputStream.afterRead | DELETION | METHOD_REMOVED\norg.apache.commons.io.input.CountingInputStream.resetByteCount | DELETION | METHOD_REMOVED\norg.apache.commons.io.filefilter.PrefixFileFilter.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.commons.io.output.NullPrintStream | DELETION | TYPE_REMOVED\norg.apache.commons.io.output.LockableFileWriter.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.commons.io.output.CountingOutputStream.getByteCount | DELETION | METHOD_REMOVED\njava.io.InputStream.readAllBytes | DELETION | METHOD_REMOVED\norg.apache.commons.io.input.ClosedInputStream | DELETION | TYPE_REMOVED\njava.io.InputStream.readNBytes | DELETION | METHOD_REMOVED\norg.apache.commons.io.FileUtils.isDirectory | DELETION | METHOD_REMOVED\norg.apache.commons.io.HexDump.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.commons.io.input.BoundedInputStream | DELETION | TYPE_REMOVED\norg.apache.commons.io.input.CountingInputStream.getByteCount | DELETION | METHOD_REMOVED\norg.apache.commons.io.FileUtils.<init> | DELETION | CONSTRUCTOR_REMOVED\njava.io.InputStream.skipNBytes | DELETION | METHOD_REMOVED\norg.apache.commons.io.input.CountingInputStream | MUTATION | SUPERTYPE_REMOVED\njava.io.InputStream.nullInputStream | DELETION | METHOD_REMOVED\norg.apache.commons.io.input.DemuxInputStream.close | MUTATION | METHOD_NOW_FINAL\norg.apache.commons.io.FileUtils.write | DELETION | METHOD_REMOVED\nBefore proposing a fix, please analyze the situation and plan your approach within\n<repair strategy> tags:\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "project": "plexus-archiver",
    "libraryName": "commons-io",
    "libraryGroupID": "commons-io",
    "newVersion": "20030203.000550",
    "previousVersion": "2.11.0"
}