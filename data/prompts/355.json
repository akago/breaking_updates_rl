{
    "absolute_path_to_file_in_container": "/sherlock/src/main/java/com/yahoo/sherlock/store/core/Client.java",
    "errors": [
        {
            "line_number": 99,
            "message": "[ERROR] /sherlock/src/main/java/com/yahoo/sherlock/store/core/Client.java:[99,17] method withTimeout in class io.lettuce.core.RedisURI.Builder cannot be applied to given types;",
            "additional_info": "  required: java.time.Duration\n  found: int,java.util.concurrent.TimeUnit\n  reason: actual and formal argument lists differ in length",
            "file_name": "Client.java",
            "BCs": [
                {
                    "element": "io.lettuce.core.RedisURI$Builder.withTimeout",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "2a8f927c-49f2-5bda-803d-c082f5eb5cdc"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Copyright 2017, Yahoo Holdings Inc.\n * Copyrights licensed under the GPL License.\n * See the accompanying LICENSE file for terms.\n */\n\npackage com.yahoo.sherlock.store.core;\n\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport com.yahoo.sherlock.exception.StoreException;\nimport com.yahoo.sherlock.settings.DatabaseConstants;\nimport com.yahoo.sherlock.store.StoreParams;\n\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This single class manages a {@code RedisClient} and {@code RedisClusterClient}\n * instance, which are used to connect either to a standalone Redis instance or a cluster.\n */\npublic class Client {\n\n    private static Client client = null;\n\n    /**\n     * @return the singleton instance of this class\n     */\n    public static Client get() {\n        if (client == null) {\n            client = new Client();\n        }\n        return client;\n    }\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n\n    /**\n     * @param hostname Redis hostname to validate\n     */\n    protected static void validateHostname(String hostname) {\n        if (hostname == null || hostname.length() == 0) {\n            throw new StoreException(\"Invalid Redis hostname: \" + hostname);\n        }\n    }\n\n    /**\n     * @param portStr port number as a String value\n     * @return Redis port number\n     */\n    protected static int getPortNumber(String portStr) {\n        Scanner s = new Scanner(portStr);\n        int port;\n        if (!s.hasNextInt() || (port = s.nextInt()) < 0 || s.hasNext()) {\n            throw new StoreException(\"Invalid Redis port: \" + portStr);\n        }\n        return port;\n    }\n\n    /**\n     * @param timeoutStr timeout as a String value\n     * @return Redis timeout in milliseconds\n     */\n    protected static int getTimeout(String timeoutStr) {\n        return getPortNumber(timeoutStr); // same logic for both\n    }\n\n    /**\n     * @param sslStr SSL boolean value as a String\n     * @return whether connection should use SSL\n     */\n    protected static boolean getSSL(String sslStr) {\n        return null != sslStr && !\"false\".equals(sslStr.toLowerCase());\n    }\n\n    /**\n     * @param hostname Redis hostname\n     * @param port     Redis port\n     * @param ssl      whether to use SSL\n     * @param password Redis password\n     * @param timeout  Redis timeout\n     * @return a Redis URI used to create clients\n     */\n    protected static RedisURI produceURI(\n            String hostname,\n            String port,\n            String ssl,\n            String password,\n            String timeout\n    ) {\n        validateHostname(hostname);\n        RedisURI.Builder builder = RedisURI.Builder\n                .redis(hostname, getPortNumber(port))\n                .withSsl(getSSL(ssl))\n                .withTimeout(getTimeout(timeout), TimeUnit.MILLISECONDS);\n        if (null != password && !password.isEmpty()) {\n            builder.withPassword(password);\n        }\n        return builder.build();\n    }\n\n    /**\n     * @param params Store params from which to create a Redis URI\n     * @return a Redis URI used to create clients\n     */\n    protected static RedisURI produceURI(StoreParams params) {\n        return produceURI(\n                params.get(DatabaseConstants.REDIS_HOSTNAME),\n                params.get(DatabaseConstants.REDIS_PORT),\n                params.get(DatabaseConstants.REDIS_SSL),\n                params.get(DatabaseConstants.REDIS_PASSWORD),\n                params.get(DatabaseConstants.REDIS_TIMEOUT)\n        );\n    }\n\n    /**\n     * Initialize the {@code RedisClient} if it has not already been.\n     *\n     * @param params Store params used to create a Redis URI\n     */\n    public void initializeRedisClient(StoreParams params) {\n        if (redisClient != null) {\n            return;\n        }\n        redisClient = RedisClient.create(produceURI(params));\n    }\n\n    /**\n     * Initialize the {@code RedisClusterClient} if it has not already been.\n     *\n     * @param params Store params used to create a Redis URI\n     */\n    public void initializeRedisClusterClient(StoreParams params) {\n        if (redisClusterClient != null) {\n            return;\n        }\n        redisClusterClient = RedisClusterClient.create(produceURI(params));\n        // Adaptive cluster topology refresh for redis cluster client\n        ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()\n            .enablePeriodicRefresh(true)\n            .enableAllAdaptiveRefreshTriggers()\n            .dynamicRefreshSources(true)\n            .closeStaleConnections(true)\n            .build();\n\n        redisClusterClient.setOptions(ClusterClientOptions.builder()\n                                          .validateClusterNodeMembership(true)\n                                          .maxRedirects(5)\n                                          .topologyRefreshOptions(topologyRefreshOptions)\n                                          .build());\n    }\n\n    /**\n     * @return the RedisClient instance\n     */\n    public RedisClient getRedisClient() {\n        return redisClient;\n    }\n\n    /**\n     * @return the RedisClusterClient instance\n     */\n    public RedisClusterClient getRedisClusterClient() {\n        return redisClusterClient;\n    }\n\n    /**\n     * Shutdown the clients.\n     */\n    public void destroy() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n            redisClient = null;\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n            redisClusterClient = null;\n        }\n    }\n\n}\n\n'''\nThe error is caused by a change in the API of the dependency: lettuce-core 5.1.6.RELEASE->6.5.1.RELEASE. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- io.lettuce.core.RedisURI$Builder.withTimeout\n\nThe error is triggered in the following specific lines in the previous code:\n                .withTimeout(getTimeout(timeout), TimeUnit.MILLISECONDS);\nwith the following error message:\n[ERROR] /sherlock/src/main/java/com/yahoo/sherlock/store/core/Client.java:[99,17] method withTimeout in class io.lettuce.core.RedisURI.Builder cannot be applied to given types;  required: java.time.Duration\n  found: int,java.util.concurrent.TimeUnit\n  reason: actual and formal argument lists differ in length\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "                .withTimeout(getTimeout(timeout), TimeUnit.MILLISECONDS);",
    "error_message": "[ERROR] /sherlock/src/main/java/com/yahoo/sherlock/store/core/Client.java:[99,17] method withTimeout in class io.lettuce.core.RedisURI.Builder cannot be applied to given types;  required: java.time.Duration\n  found: int,java.util.concurrent.TimeUnit\n  reason: actual and formal argument lists differ in length",
    "api_diff": "-- io.lettuce.core.RedisURI$Builder.withTimeout",
    "original_code": "/*\n * Copyright 2017, Yahoo Holdings Inc.\n * Copyrights licensed under the GPL License.\n * See the accompanying LICENSE file for terms.\n */\n\npackage com.yahoo.sherlock.store.core;\n\nimport io.lettuce.core.RedisClient;\nimport io.lettuce.core.RedisURI;\nimport io.lettuce.core.cluster.ClusterClientOptions;\nimport io.lettuce.core.cluster.ClusterTopologyRefreshOptions;\nimport io.lettuce.core.cluster.RedisClusterClient;\nimport com.yahoo.sherlock.exception.StoreException;\nimport com.yahoo.sherlock.settings.DatabaseConstants;\nimport com.yahoo.sherlock.store.StoreParams;\n\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * This single class manages a {@code RedisClient} and {@code RedisClusterClient}\n * instance, which are used to connect either to a standalone Redis instance or a cluster.\n */\npublic class Client {\n\n    private static Client client = null;\n\n    /**\n     * @return the singleton instance of this class\n     */\n    public static Client get() {\n        if (client == null) {\n            client = new Client();\n        }\n        return client;\n    }\n\n    private RedisClient redisClient;\n    private RedisClusterClient redisClusterClient;\n\n    /**\n     * @param hostname Redis hostname to validate\n     */\n    protected static void validateHostname(String hostname) {\n        if (hostname == null || hostname.length() == 0) {\n            throw new StoreException(\"Invalid Redis hostname: \" + hostname);\n        }\n    }\n\n    /**\n     * @param portStr port number as a String value\n     * @return Redis port number\n     */\n    protected static int getPortNumber(String portStr) {\n        Scanner s = new Scanner(portStr);\n        int port;\n        if (!s.hasNextInt() || (port = s.nextInt()) < 0 || s.hasNext()) {\n            throw new StoreException(\"Invalid Redis port: \" + portStr);\n        }\n        return port;\n    }\n\n    /**\n     * @param timeoutStr timeout as a String value\n     * @return Redis timeout in milliseconds\n     */\n    protected static int getTimeout(String timeoutStr) {\n        return getPortNumber(timeoutStr); // same logic for both\n    }\n\n    /**\n     * @param sslStr SSL boolean value as a String\n     * @return whether connection should use SSL\n     */\n    protected static boolean getSSL(String sslStr) {\n        return null != sslStr && !\"false\".equals(sslStr.toLowerCase());\n    }\n\n    /**\n     * @param hostname Redis hostname\n     * @param port     Redis port\n     * @param ssl      whether to use SSL\n     * @param password Redis password\n     * @param timeout  Redis timeout\n     * @return a Redis URI used to create clients\n     */\n    protected static RedisURI produceURI(\n            String hostname,\n            String port,\n            String ssl,\n            String password,\n            String timeout\n    ) {\n        validateHostname(hostname);\n        RedisURI.Builder builder = RedisURI.Builder\n                .redis(hostname, getPortNumber(port))\n                .withSsl(getSSL(ssl))\n                .withTimeout(getTimeout(timeout), TimeUnit.MILLISECONDS);\n        if (null != password && !password.isEmpty()) {\n            builder.withPassword(password);\n        }\n        return builder.build();\n    }\n\n    /**\n     * @param params Store params from which to create a Redis URI\n     * @return a Redis URI used to create clients\n     */\n    protected static RedisURI produceURI(StoreParams params) {\n        return produceURI(\n                params.get(DatabaseConstants.REDIS_HOSTNAME),\n                params.get(DatabaseConstants.REDIS_PORT),\n                params.get(DatabaseConstants.REDIS_SSL),\n                params.get(DatabaseConstants.REDIS_PASSWORD),\n                params.get(DatabaseConstants.REDIS_TIMEOUT)\n        );\n    }\n\n    /**\n     * Initialize the {@code RedisClient} if it has not already been.\n     *\n     * @param params Store params used to create a Redis URI\n     */\n    public void initializeRedisClient(StoreParams params) {\n        if (redisClient != null) {\n            return;\n        }\n        redisClient = RedisClient.create(produceURI(params));\n    }\n\n    /**\n     * Initialize the {@code RedisClusterClient} if it has not already been.\n     *\n     * @param params Store params used to create a Redis URI\n     */\n    public void initializeRedisClusterClient(StoreParams params) {\n        if (redisClusterClient != null) {\n            return;\n        }\n        redisClusterClient = RedisClusterClient.create(produceURI(params));\n        // Adaptive cluster topology refresh for redis cluster client\n        ClusterTopologyRefreshOptions topologyRefreshOptions = ClusterTopologyRefreshOptions.builder()\n            .enablePeriodicRefresh(true)\n            .enableAllAdaptiveRefreshTriggers()\n            .dynamicRefreshSources(true)\n            .closeStaleConnections(true)\n            .build();\n\n        redisClusterClient.setOptions(ClusterClientOptions.builder()\n                                          .validateClusterNodeMembership(true)\n                                          .maxRedirects(5)\n                                          .topologyRefreshOptions(topologyRefreshOptions)\n                                          .build());\n    }\n\n    /**\n     * @return the RedisClient instance\n     */\n    public RedisClient getRedisClient() {\n        return redisClient;\n    }\n\n    /**\n     * @return the RedisClusterClient instance\n     */\n    public RedisClusterClient getRedisClusterClient() {\n        return redisClusterClient;\n    }\n\n    /**\n     * Shutdown the clients.\n     */\n    public void destroy() {\n        if (redisClient != null) {\n            redisClient.shutdown();\n            redisClient = null;\n        }\n        if (redisClusterClient != null) {\n            redisClusterClient.shutdown();\n            redisClusterClient = null;\n        }\n    }\n\n}\n",
    "project": "sherlock",
    "libraryName": "lettuce-core",
    "libraryGroupID": "io.lettuce",
    "newVersion": "6.5.1.RELEASE",
    "previousVersion": "5.1.6.RELEASE",
    "breakingCommit": "7e1c7826b63cae9a472d707f4fb65b6add69b48e"
}