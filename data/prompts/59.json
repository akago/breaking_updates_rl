{
    "absolute_path_to_file_in_container": "/PGS/src/main/java/micycle/pgs/PGS_PointSet.java",
    "errors": [
        {
            "line_number": 70,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_PointSet.java:[70,53] cannot find symbol",
            "additional_info": "  symbol:   method query1NN(double[])\n  location: variable tree of type org.tinspin.index.kdtree.KDTree<processing.core.PVector>",
            "file_name": "PGS_PointSet.java",
            "uid": "7381badd-fc3f-54f1-a75d-438cc7b49928"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: tinspin-indexes 1.7.1->2.0.1\n\nthe following client code fails: \n'''java\npackage micycle.pgs;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Point4d;\n\nimport org.apache.commons.math3.ml.clustering.Clusterable;\nimport org.apache.commons.math3.ml.clustering.Clusterer;\nimport org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer;\nimport org.apache.commons.math3.ml.distance.EuclideanDistance;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Pair;\n\nimport org.jgrapht.alg.interfaces.SpanningTreeAlgorithm;\nimport org.jgrapht.alg.spanning.PrimMinimumSpanningTree;\nimport org.jgrapht.graph.SimpleGraph;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinspin.index.kdtree.KDTree;\n\nimport it.unimi.dsi.util.XoRoShiRo128PlusRandom;\nimport it.unimi.dsi.util.XoRoShiRo128PlusRandomGenerator;\nimport micycle.pgs.commons.GeometricMedian;\nimport micycle.pgs.commons.PEdge;\nimport micycle.pgs.commons.PoissonDistributionJRUS;\nimport processing.core.PShape;\nimport processing.core.PVector;\n\n/**\n * Generation of random sets of 2D points having a variety of different\n * distributions and constraints (and associated functions).\n * \n * @author Michael Carleton\n * @since 1.2.0\n *\n */\npublic final class PGS_PointSet {\n\n\tprivate static final float SQRT_3 = (float) Math.sqrt(3);\n\t/** Golden angle (in radians) */\n\tprivate static final float GOLDEN_ANGLE = (float) (Math.PI * (3 - Math.sqrt(5)));\n\n\tprivate PGS_PointSet() {\n\t}\n\n\t/**\n\t * Returns a filtered copy of the input, containing no points that are within\n\t * the <code>distanceTolerance</code> of each other.\n\t * <p>\n\t * This method can be used to convert a random point set into a blue-noise-like\n\t * (poisson) point set.\n\t * \n\t * @param points            list of points to filter\n\t * @param distanceTolerance a point that is within this distance of a previously\n\t *                          included point is not included in the output\n\t * @return\n\t */\n\tpublic static List<PVector> prunePointsWithinDistance(List<PVector> points, double distanceTolerance) {\n\t\tfinal KDTree<PVector> tree = KDTree.create(2);\n\t\tfinal List<PVector> newPoints = new ArrayList<>();\n\t\tfor (PVector p : points) {\n\t\t\tfinal double[] coords = new double[] { p.x, p.y };\n\t\t\tif (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {\n\t\t\t\ttree.insert(coords, p);\n\t\t\t\tnewPoints.add(p);\n\t\t\t}\n\t\t}\n\t\treturn newPoints;\n\t}\n\n\t/**\n\t * Sorts a list of points according to the Hilbert space-filling curve to ensure\n\t * a high-degree of spatial locality in the sequence of points.\n\t * \n\t * @param points list of points to sort. a list requires at least 24 points to\n\t *               be sorted.\n\t * @return a sorted <b>copy</b> of the input list, having a different order\n\t *         according to points' Hilbert ranking of their (x, y) coordinate\n\t * @since 1.3.0\n\t */\n\tpublic static List<PVector> hilbertSort(List<PVector> points) {\n\t\tdouble xMin, xMax, yMin, yMax;\n\t\tif (points.isEmpty()) {\n\t\t\treturn points;\n\t\t}\n\n\t\t// find bounds\n\t\tPVector v = points.get(0);\n\t\txMin = v.x;\n\t\txMax = v.x;\n\t\tyMin = v.y;\n\t\tyMax = v.y;\n\n\t\tfor (PVector PVector : points) {\n\t\t\tif (PVector.x < xMin) {\n\t\t\t\txMin = PVector.x;\n\t\t\t} else if (PVector.x > xMax) {\n\t\t\t\txMax = PVector.x;\n\t\t\t}\n\t\t\tif (PVector.y < yMin) {\n\t\t\t\tyMin = PVector.y;\n\t\t\t} else if (PVector.y > yMax) {\n\t\t\t\tyMax = PVector.y;\n\t\t\t}\n\t\t}\n\n\t\tdouble xDelta = xMax - xMin;\n\t\tdouble yDelta = yMax - yMin;\n\t\tif (xDelta == 0 || yDelta == 0) {\n\t\t\treturn points;\n\t\t}\n\t\tif (points.size() < 24) {\n\t\t\treturn points;\n\t\t}\n\n\t\tdouble hn = Math.log(points.size()) / 0.693147180559945 / 2.0;\n\t\tint nHilbert = (int) Math.floor(hn + 0.5);\n\t\tif (nHilbert < 4) {\n\t\t\tnHilbert = 4;\n\t\t}\n\n\t\t// could also use SortedMap<index -> point>\n\t\tList<Pair<Integer, PVector>> ranks = new ArrayList<>(points.size());\n\t\tdouble hScale = (1 << nHilbert) - 1.0;\n\t\t// scale coordinates to 2^n - 1\n\t\tfor (PVector vh : points) {\n\t\t\tint ix = (int) (hScale * (vh.x - xMin) / xDelta);\n\t\t\tint iy = (int) (hScale * (vh.y - yMin) / yDelta);\n\t\t\tranks.add(new Pair<>(xy2Hilbert(ix, iy, nHilbert), vh));\n\t\t}\n\n\t\tranks.sort((a, b) -> Integer.compare(a.getFirst(), b.getFirst()));\n\n\t\treturn ranks.stream().map(Pair::getSecond).collect(Collectors.toList());\n\t}\n\n\t/**\n\t * Clusters points into N groups, using k-means clustering.\n\t * <p>\n\t * K-means finds the N cluster centers and assigns points to the nearest cluster\n\t * center, such that the squared (euclidean) distances from the cluster are\n\t * minimised.\n\t * \n\t * @param points list of points to cluster\n\t * @param groups desired number of clustered groups\n\t * @since 1.4.0\n\t * @see #cluster(Collection, int, long)\n\t * @return list of groups, where each group is a list of PVectors\n\t */\n\tpublic static List<List<PVector>> cluster(Collection<PVector> points, int groups) {\n\t\treturn cluster(points, groups, System.nanoTime());\n\t}\n\n\t/**\n\t * Clusters points into N groups, using k-means clustering.\n\t * <p>\n\t * K-means finds the N cluster centers and assigns points to the nearest cluster\n\t * center, such that the squared (euclidean) distances from the cluster are\n\t * minimised.\n\t * \n\t * @param points list of points to cluster\n\t * @param groups desired number of clustered groups\n\t * @param seed   random seed\n\t * @since 1.4.0\n\t * @return list of groups, where each group is a list of PVectors\n\t * @see #cluster(Collection, int)\n\t */\n\tpublic static List<List<PVector>> cluster(Collection<PVector> points, int groups, long seed) {\n\t\tRandomGenerator r = new XoRoShiRo128PlusRandomGenerator(seed);\n\t\tClusterer<CPVector> kmeans = new KMeansPlusPlusClusterer<>(groups, 25, new EuclideanDistance(), r);\n\t\tList<CPVector> pointz = points.stream().map(p -> new CPVector(p)).collect(Collectors.toList());\n\n\t\tList<List<PVector>> clusters = new ArrayList<>(groups);\n\t\tkmeans.cluster(pointz).forEach(cluster -> {\n\t\t\tclusters.add(cluster.getPoints().stream().map(p -> p.p).collect(Collectors.toList()));\n\t\t});\n\n\t\treturn clusters;\n\t}\n\n\t/**\n\t * Finds the geometric median point of a set of weighted sample points.\n\t * <p>\n\t * The median point is the point that minimises the sum of (weighted) distances\n\t * to the sample points.\n\t * <p>\n\t * Points are expressed as PVectors; the z coordinate is used as the weight for\n\t * each point. Weights must be positive. If every point has a weight of 0 (z=0),\n\t * the function returns the median as if each point had an equal non-zero weight\n\t * (set to 1).\n\t * \n\t * @param points list of points, where the z coordinate is point weight\n\t * @since 1.4.0\n\t * @return 2D median point\n\t */\n\tpublic static PVector weightedMedian(Collection<PVector> points) {\n\t\tboolean allZero = points.stream().allMatch(p -> p.z == 0);\n\t\tPoint4d[] wp = points.stream().map(p -> new Point4d(p.x, p.y, 0, allZero ? 1 : p.z)).toArray(Point4d[]::new);\n\t\tPoint3d median = GeometricMedian.median(wp, 1e-3, 50);\n\t\treturn new PVector((float) median.x, (float) median.y);\n\t}\n\n\t/**\n\t * Generates a set of random (uniform) points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #random(double, double, double, double, int, long) seeded random()\n\t */\n\tpublic static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn random(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random (uniform) points that lie within a bounding\n\t * rectangle, using the specified seed.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #random(double, double, double, double, int) non-seeded random()\n\t */\n\tpublic static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (xMin + (xMax - xMin) * random.nextDouble());\n\t\t\tfinal float y = (float) (yMin + (yMax - yMin) * random.nextDouble());\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random points having a gaussian/normal distribution. The\n\t * point set is centered around the given center, given by mean coordinates.\n\t * \n\t * @param centerX x coordinate of the center/mean of the point set\n\t * @param centerY x coordinate of the center/mean of the point set\n\t * @param sd      standard deviation, which specifies how much the values can\n\t *                vary from the mean. 68% of point samples have a value within\n\t *                one standard deviation of the mean; three standard deviations\n\t *                account for 99.7% of the sample population\n\t * @param n       number of points to generate\n\t * @return\n\t * @see #gaussian(double, double, double, int, long) seeded gaussian()\n\t */\n\tpublic static List<PVector> gaussian(double centerX, double centerY, double sd, int n) {\n\t\treturn gaussian(centerX, centerY, sd, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random points having a gaussian/normal distribution, using\n\t * the specified seed. The point set is centered around the given center, given\n\t * by mean coordinates.\n\t * \n\t * @param centerX x coordinate of the center/mean of the point set\n\t * @param centerY x coordinate of the center/mean of the point set\n\t * @param sd      standard deviation, which specifies how much the values can\n\t *                vary from the mean. 68% of point samples have a value within\n\t *                one standard deviation of the mean; three standard deviations\n\t *                account for 99.7% of the sample population\n\t * @param n       number of points to generate\n\t * @param seed    number used to initialize the underlying pseudorandom number\n\t *                generator\n\t * @return\n\t * @see #gaussian(double, double, double, int) non-seeded gaussian()\n\t */\n\tpublic static List<PVector> gaussian(double centerX, double centerY, double sd, int n, long seed) {\n\t\tfinal RandomGenerator random = new XoRoShiRo128PlusRandomGenerator(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (sd * random.nextGaussian() + centerX);\n\t\t\tfinal float y = (float) (sd * random.nextGaussian() + centerY);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a square grid/lattice of points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @return\n\t */\n\tpublic static List<PVector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,\n\t\t\tfinal double pointDistance) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\tfor (double x = 0; x < width; x += pointDistance) {\n\t\t\tfor (double y = 0; y < height; y += pointDistance) {\n\t\t\t\tpoints.add(new PVector((float) (x + xMin), (float) (y + yMin)));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagon grid/lattice of points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #hexGrid(double, double, double, double, double) hexGrid() where\n\t *      inter-point distance is specified\n\t */\n\tpublic static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal float h = (float) Math.sqrt((width * height * (Math.sqrt(5) / 2)) / n);\n\t\tfinal float v = (float) (h * (2 / Math.sqrt(5)));\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\n\t\tfor (int i = 0; i < width / h; i++) {\n\t\t\tfor (int j = 0; j < height / v; j++) {\n\t\t\t\tpoints.add(new PVector((i - (j % 2) / 2f) * h + (float) xMin, j * v + (float) yMin));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagon grid of points that lie within a bounding rectangle.\n\t * \n\t * @param xMin          x-coordinate of boundary minimum\n\t * @param yMin          y-coordinate of boundary minimum\n\t * @param xMax          x-coordinate of boundary maximum\n\t * @param yMax          y-coordinate of boundary maximum\n\t * @param pointDistance inter-point distance\n\t * @return\n\t * @see #hexGrid(double, double, double, double, int) hexGrid() where number of\n\t *      points is specified\n\t */\n\tpublic static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,\n\t\t\tfinal double pointDistance) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\tfor (int i = 0; i < width / pointDistance; i++) {\n\t\t\tfor (int j = 0; j < height / pointDistance; j++) {\n\t\t\t\tpoints.add(new PVector((float) ((i - (j % 2) / 2f) * pointDistance + xMin), (float) (j * pointDistance + yMin)));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagonal grid of points <b>arranged in a hexagon pattern</b>.\n\t * \n\t * @param centerX x coordinate of the hexagon center point\n\t * @param centerY y coordinate of the hexagon center point\n\t * @param length  layers/no. of points on each hexagon side\n\t * @distance inter-point distance\n\t * @return\n\t */\n\tpublic static List<PVector> hexagon(double centerX, double centerY, int length, double distance) {\n\t\tfinal float xOffset = (float) centerX;\n\t\tfinal float yOffset = (float) centerY;\n\t\tfinal float d = (float) distance;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\t/*\n\t\t * PVector .z is set to length so hexagon layer can be easily identified.\n\t\t */\n\t\tfor (int i = 0; i <= (length - 1); i++) {\n\t\t\tfloat y = (SQRT_3 * i * d) / 2.0f;\n\t\t\tfor (int j = 0; j < (2 * length - 1 - i); j++) {\n\t\t\t\tfloat x = (-(2 * length - i - 2) * d) / 2.0f + j * d;\n\t\t\t\tpoints.add(new PVector(x + xOffset, y + yOffset, length));\n\t\t\t\tif (y != 0) {\n\t\t\t\t\tpoints.add(new PVector(x + xOffset, -y + yOffset, length));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of n points that are randomly distributed on a ring\n\t * (annulus).\n\t * \n\t * @param centerX     x coordinate of the center/mean of the ring\n\t * @param centerY     x coordinate of the center/mean of the ring\n\t * @param innerRadius radius of the ring's hole\n\t * @param outerRadius outer radius of the ring\n\t * @param maxAngle    angle of the ring (in radians). Can be negative\n\t * @param n           the number of random points to generate\n\t * @return a list of PVector objects representing the (x, y) coordinates of the\n\t *         random points\n\t * @see #ring(double, double, double, double, double, int, long) seeded ring()\n\t */\n\tpublic static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {\n\t\treturn ring(centerX, centerY, innerRadius, outerRadius, maxAngle, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of points that are randomly distributed on a ring (annulus).\n\t * \n\t * @param centerX     x coordinate of the center/mean of the ring\n\t * @param centerY     x coordinate of the center/mean of the ring\n\t * @param innerRadius radius of the ring's hole\n\t * @param outerRadius outer radius of the ring\n\t * @param maxAngle    angle of the ring (in radians). Can be negative\n\t * @param n           the number of random points to generate\n\t * @param seed        number used to initialize the underlying pseudorandom\n\t *                    number generator\n\t * @return a list of PVector objects representing the (x, y) coordinates of the\n\t *         random points\n\t * @see #ring(double, double, double, double, double, int) non-seeded ring()\n\t */\n\tpublic static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,\n\t\t\tlong seed) {\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tif (maxAngle == 0) {\n\t\t\tmaxAngle = Double.MIN_VALUE;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble randomAngle = (maxAngle < 0 ? -1 : 1) * random.nextDouble(Math.abs(maxAngle));\n\t\t\tdouble randomRadius = random.nextDouble(innerRadius, outerRadius);\n\t\t\tdouble x = -Math.sin(randomAngle) * randomRadius;\n\t\t\tdouble y = Math.cos(randomAngle) * randomRadius;\n\n\t\t\tpoints.add(new PVector((float) (x + centerX), (float) (y + centerY)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random points (constrained within a rectangular region)\n\t * via Poisson Disk Sampling.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin    x-coordinate of boundary minimum\n\t * @param yMin    y-coordinate of boundary minimum\n\t * @param xMax    x-coordinate of boundary maximum\n\t * @param yMax    y-coordinate of boundary maximum\n\t * @param minDist minimum euclidean distance between any two points\n\t * @return\n\t * @see #poisson(double, double, double, double, double, long) seeded poisson()\n\t */\n\tpublic static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {\n\t\treturn poisson(xMin, yMin, xMax, yMax, minDist, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random points (constrained within a rectangular region)\n\t * via Poisson Disk Sampling, using the specified seed.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin    x-coordinate of boundary minimum\n\t * @param yMin    y-coordinate of boundary minimum\n\t * @param xMax    x-coordinate of boundary maximum\n\t * @param yMax    y-coordinate of boundary maximum\n\t * @param minDist minimum euclidean distance between any two points\n\t * @param seed    number used to initialize the underlying pseudorandom number\n\t *                generator\n\t * @return\n\t * @see #poisson(double, double, double, double, double) non-seeded poisson()\n\t */\n\tpublic static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist, long seed) {\n\t\tfinal PoissonDistributionJRUS pd = new PoissonDistributionJRUS(seed);\n\t\treturn pd.generate(xMin, yMin, xMax, yMax, minDist);\n\t}\n\n\t/**\n\t * Generates a poisson point set having N points constrained within a\n\t * rectangular region.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    target size of poisson point set\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t */\n\tpublic static List<PVector> poissonN(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal PoissonDistributionJRUS pd = new PoissonDistributionJRUS(seed);\n\t\treturn pd.generate(xMin, yMin, xMax, yMax, n);\n\t}\n\n\t/**\n\t * Generates a set of points arranged in a phyllotaxis pattern (an arrangement\n\t * similar to the florets in the head of a sunflower), using the golden ratio\n\t * (the most irrational number) to position points with the least possible\n\t * aliasing (which is arguably the \"best\" arrangement).\n\t * \n\t * @param centerX x coordinate of the center of the point set\n\t * @param centerY y coordinate of the center of the point set\n\t * @param n       number of points to generate\n\t * @param radius  radius of circular phyllotaxis extent (max distance of a point\n\t *                from the center position)\n\t * @return\n\t */\n\tpublic static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius) {\n\t\treturn phyllotaxis(centerX, centerY, n, radius, 2 * Math.PI - GOLDEN_ANGLE);\n\t}\n\n\t/**\n\t * Generates a set of points arranged in a phyllotaxis pattern (an arrangement\n\t * similar to the florets in the head of a sunflower), using a user-defined\n\t * theta.\n\t * \n\t * @param centerX x coordinate of the center of the point set\n\t * @param centerY y coordinate of the center of the point set\n\t * @param n       number of points to generate\n\t * @param radius  radius of circular phyllotaxis extent (max distance of a point\n\t *                from the center position)\n\t * @param theta   angle (in radians) to turn after each point placement\n\t * @return\n\t */\n\tpublic static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {\n\t\tfinal double fillArea = radius * radius * Math.PI; // calculate area to be filled\n\t\tfinal double circleSpace = (fillArea / n); // area per circle\n\t\tfinal double fudge = 0.7; // Fudge factor: breathing space between circles\n\t\tfinal float circleRadius = (float) (Math.sqrt(circleSpace / Math.PI) * fudge);\n\n\t\tfloat cumArea = 0; // cumulative circle area\n\n\t\tfinal List<PVector> outList = new ArrayList<>();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfinal double angle = i * theta; // rotation per circle\n\t\t\tcumArea += circleSpace; // add sm_area to cum_area every loop\n\n\t\t\tfinal double spiralR = Math.sqrt(cumArea / Math.PI); // expansion of spiral (distance of circle) per loop\n\n\t\t\tfloat pX = (float) (centerX + Math.cos(angle) * spiralR); // spiral rotation of golden angle per loop on X\n\t\t\tfloat pY = (float) (centerY + Math.sin(angle) * spiralR); // spiral rotation of golden angle per loop on Y\n\n\t\t\toutList.add(new PVector(pX, pY, circleRadius));\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number (the\n\t * plastic constant).\n\t * <p>\n\t * The <i>plastic LDS</i> has been <a href=\n\t * \"http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\">shown</a>\n\t * to have superior low discrepancy properties amongst the quasirandom\n\t * sequences, and is therefore recommended.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/irrational_numbers/irrational_numbers.cpp\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfinal double p = 1.32471795724474602596; // plastic constant\n\t\tfinal double a1 = 1.0 / p; // inverse of plastic number\n\t\tfinal double a2 = 1.0 / (p * p);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (((0.5 + a1 * i) % 1) * w + xMin);\n\t\t\tfinal float y = (float) (((0.5 + a2 * i) % 1) * h + yMin);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number. In this\n\t * method, a random jitter is added to points to give the point set\n\t * blue-noise-like properties.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #plasticJitteredLDS(double, double, double, double, int, long) seeded\n\t *      irrationalJitteredLDS()\n\t */\n\tpublic static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn plasticJitteredLDS(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number. In this\n\t * method, a random jitter is added to points to give the point set\n\t * blue-noise-like properties.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #plasticJitteredLDS(double, double, double, double, int) non-seeded\n\t *      irrationalJitteredLDS()\n\t */\n\tpublic static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/irrational_numbers/irrational_numbers.cpp\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal double p = 1.32471795724474602596; // plastic constant\n\t\tfinal double a1 = 1.0 / p;\n\t\tfinal double a2 = 1.0 / (p * p);\n\t\tfinal double c_magicNumber = 0.732;\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (((random.nextDouble() * c_magicNumber / Math.sqrt(i + 1d) + a1 * i) % 1) * w + xMin);\n\t\t\tfinal float y = (float) (((random.nextDouble() * c_magicNumber / Math.sqrt(i + 1d) + a2 * i) % 1) * h + yMin);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on a Halton sequence.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> haltonLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfloat[][] values = new float[n][2];\n\t\tvanDerCorput(values, 2, 0, true, 0);\n\t\tvanDerCorput(values, 3, 1, true, 0);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (float[] point : values) {\n\t\t\tpoints.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on a Hammersley sequence.\n\t * <p>\n\t * The Hammersley sequence in 2D is just the 1d Van Der Corput sequence on one\n\t * axis, and regular sampling on the other axis.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfloat[][] values = new float[n][2];\n\t\tvanDerCorput(values, 2, 0, false, 0);\n\n\t\tfinal float offset = 1.0f / (n * 2);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvalues[i][1] = offset + (i / (float) n);\n\t\t}\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (float[] point : values) {\n\t\t\tpoints.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random stratified points (bounded by a rectangle) based on\n\t * the \"N-Rooks\" sampling pattern.\n\t * <p>\n\t * N-Rooks is a sampling pattern where you treat the boundary as if it were a\n\t * chess board. Every sampling position is a rook that could move horizontally\n\t * or vertically, and should be placed such that none of these rooks could\n\t * capture/\"see\" any of the other rooks. In other words, every column has a\n\t * single sample point in it, and every row has a single sample point in it.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #nRooksLDS(double, double, double, double, int, long)\n\t */\n\tpublic static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn nRooksLDS(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random stratified points (bounded by a rectangle) based on\n\t * the \"N-Rooks\" sampling pattern.\n\t * <p>\n\t * N-Rooks is a sampling pattern where you treat the boundary as if it were a\n\t * chess board. Every sampling position is a rook that could move horizontally\n\t * or vertically, and should be placed such that none of these rooks could\n\t * capture/\"see\" any of the other rooks. In other words, every column has a\n\t * single sample point in it, and every row has a single sample point in it.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #nRooksLDS(double, double, double, double, int)\n\t */\n\tpublic static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfinal List<Integer> rookPositions = IntStream.range(0, n).boxed().collect(Collectors.toList());\n\t\tCollections.shuffle(rookPositions, new XoRoShiRo128PlusRandom(seed));\n\n\t\tfinal float offset = 1.0f / (n * 2);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfloat x = offset + (rookPositions.get(i) / (float) n);\n\t\t\tx *= w;\n\t\t\tx += xMin;\n\t\t\tfloat y = offset + i / (float) n;\n\t\t\ty *= h;\n\t\t\ty += yMin;\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a 2D set of deterministic stratified points (bounded by a\n\t * rectangle) from the Sobol low discrepancy sequence (LDS).\n\t * <p>\n\t * A Sobol sequence is a low-discrepancy sequence with the property that for all\n\t * values of N,its subsequence (x1, ... xN) has a low discrepancy. It can be\n\t * used to generate pseudo-randompoints in a space S, which are\n\t * equi-distributed.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @since 1.4.0\n\t * @return\n\t */\n\tpublic static List<PVector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfinal int dimension = 2;\n\t\tfinal int BITS = 52;\n\t\tfinal double SCALE = FastMath.pow(2, BITS);\n\t\tfinal long[][] direction = new long[dimension][BITS + 1];\n\t\tfinal long[] x = new long[dimension];\n\t\tfinal int[] m = new int[] { 0, 1 };\n\t\tfinal int a = 0;\n\t\tfinal int s = m.length - 1;\n\n\t\tfor (int i = 1; i <= BITS; i++) {\n\t\t\tdirection[0][i] = 1l << (BITS - i);\n\t\t}\n\n\t\t// init direction vector\n\t\tfinal int d = 1;\n\t\tfor (int i = 1; i <= s; i++) {\n\t\t\tdirection[d][i] = ((long) m[i]) << (BITS - i);\n\t\t}\n\t\tfor (int i = s + 1; i <= BITS; i++) {\n\t\t\tdirection[d][i] = direction[d][i - s] ^ (direction[d][i - s] >> s);\n\t\t\tfor (int k = 1; k <= s - 1; k++) {\n\t\t\t\tdirection[d][i] ^= ((a >> (s - 1 - k)) & 1) * direction[d][i - k];\n\t\t\t}\n\t\t}\n\n\t\tList<PVector> output = new ArrayList<>(n);\n\t\tfor (int i = 1; i < n; i++) {\n\n\t\t\t// find the index c of the rightmost 0\n\t\t\tint c = 1;\n\t\t\tint value = i - 1;\n\t\t\twhile ((value & 1) == 1) {\n\t\t\t\tvalue >>= 1;\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tx[0] ^= direction[0][c];\n\t\t\tx[1] ^= direction[1][c];\n\t\t\tdouble vX = x[0] / SCALE;\n\t\t\tvX *= w;\n\t\t\tvX += xMin;\n\t\t\tdouble vY = x[1] / SCALE;\n\t\t\tvY *= h;\n\t\t\tvY += yMin;\n\t\t\toutput.add(new PVector((float) vX, (float) vY));\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Computes the <i>Euclidean minimum spanning tree</i> (EMST) of a set of\n\t * points.\n\t * <p>\n\t * The EMST is a system of line segments, having only the given points as their\n\t * endpoints, whose union includes all of the points in a connected set, and\n\t * which has the minimum possible total length of any such system.\n\t * \n\t * @param points the set of points over which to compute the EMST\n\t * @return a LINES PShape\n\t * @since 1.3.0\n\t */\n\tpublic static PShape minimumSpanningTree(List<PVector> points) {\n\t\t/*\n\t\t * The Euclidean minimum spanning tree in a plane is a subgraph of the Delaunay\n\t\t * triangulation.\n\t\t */\n\t\tIIncrementalTin triangulation = PGS_Triangulation.delaunayTriangulationMesh(points);\n\t\tSimpleGraph<PVector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);\n\t\tSpanningTreeAlgorithm<PEdge> st = new PrimMinimumSpanningTree<>(graph); // faster than kruskal algorithm\n\t\treturn PGS_SegmentSet.toPShape(st.getSpanningTree().getEdges());\n\t}\n\n\t/**\n\t * Computes the hilbert index of a coordinate on a hilbert curve of order n.\n\t */\n\tprivate static int xy2Hilbert(final int px, final int py, final int n) {\n\t\tint i, xi, yi;\n\t\tint s, temp;\n\n\t\tint x = px;\n\t\tint y = py;\n\t\ts = 0; // Initialize.\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\txi = (x >> i) & 1; // Get bit i of x.\n\t\t\tyi = (y >> i) & 1; // Get bit i of y.\n\n\t\t\tif (yi == 0) {\n\t\t\t\ttemp = x; // Swap x and y and,\n\t\t\t\tx = y ^ (-xi); // if xi = 1,\n\t\t\t\ty = temp ^ (-xi); // complement them.\n\t\t\t}\n\t\t\ts = 4 * s + 2 * xi + (xi ^ yi); // Append two bits to s.\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * @param values\n\t * @param base\n\t * @param axis         0 = x axis; 1 = y axis\n\t * @param skipZero\n\t * @param truncateBits\n\t */\n\tprivate static void vanDerCorput(float[][] values, int base, int axis, boolean skipZero, int truncateBits) {\n\t\t// https://blog.demofox.org/2017/05/29/when-random-numbers-are-too-random-low-discrepancy-sequences/\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/lds/LDS.cpp\n\t\t// figure out how many bits we are working in.\n\t\tint n = values.length;\n\t\tint value = 1;\n\t\tint numBits = 0;\n\t\twhile (value < n) {\n\t\t\tvalue *= 2;\n\t\t\t++numBits;\n\t\t}\n\t\tint numBitsPreserved = numBits - truncateBits;\n\t\tint bitsPreservedMask = numBitsPreserved > 0 ? (1 << numBitsPreserved) - 1 : 0;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvalues[i][axis] = 0.0f;\n\t\t\tfloat denominator = base;\n\t\t\tint q = i + (skipZero ? 1 : 0);\n\t\t\tq &= bitsPreservedMask;\n\t\t\twhile (q > 0) {\n\t\t\t\tint multiplier = q % base;\n\t\t\t\tvalues[i][axis] += multiplier / denominator;\n\t\t\t\tq = q / base;\n\t\t\t\tdenominator *= base;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class CPVector implements Clusterable {\n\t\tfinal PVector p;\n\t\tfinal double[] point;\n\n\t\tCPVector(PVector p) {\n\t\t\tthis.p = p;\n\t\t\tpoint = new double[] { p.x, p.y };\n\t\t}\n\n\t\t@Override\n\t\tpublic double[] getPoint() {\n\t\t\treturn point;\n\t\t}\n\t}\n\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n\t\t\tif (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {\nwith the following error message:\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_PointSet.java:[70,53] cannot find symbol  symbol:   method query1NN(double[])\n  location: variable tree of type org.tinspin.index.kdtree.KDTree<processing.core.PVector>\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.tinspin.index.PointEntryDist | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.PointIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.main | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.kdtree.KDTree.nnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.PointIndexWrapper | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.knnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.next | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointIndex | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.query | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree.create | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointDistanceFunction | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.RectangleIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.reset | DELETION | METHOD_REMOVED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "\t\t\tif (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {",
    "error_message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_PointSet.java:[70,53] cannot find symbol  symbol:   method query1NN(double[])\n  location: variable tree of type org.tinspin.index.kdtree.KDTree<processing.core.PVector>",
    "api_diff": "Format: element | nature | kind\norg.tinspin.index.PointEntryDist | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.PointIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.main | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.kdtree.KDTree.nnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.PointIndexWrapper | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.knnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.next | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointIndex | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.query | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree.create | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointDistanceFunction | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.RectangleIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.reset | DELETION | METHOD_REMOVED",
    "original_code": "package micycle.pgs;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport javax.vecmath.Point3d;\nimport javax.vecmath.Point4d;\n\nimport org.apache.commons.math3.ml.clustering.Clusterable;\nimport org.apache.commons.math3.ml.clustering.Clusterer;\nimport org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer;\nimport org.apache.commons.math3.ml.distance.EuclideanDistance;\nimport org.apache.commons.math3.random.RandomGenerator;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Pair;\n\nimport org.jgrapht.alg.interfaces.SpanningTreeAlgorithm;\nimport org.jgrapht.alg.spanning.PrimMinimumSpanningTree;\nimport org.jgrapht.graph.SimpleGraph;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinspin.index.kdtree.KDTree;\n\nimport it.unimi.dsi.util.XoRoShiRo128PlusRandom;\nimport it.unimi.dsi.util.XoRoShiRo128PlusRandomGenerator;\nimport micycle.pgs.commons.GeometricMedian;\nimport micycle.pgs.commons.PEdge;\nimport micycle.pgs.commons.PoissonDistributionJRUS;\nimport processing.core.PShape;\nimport processing.core.PVector;\n\n/**\n * Generation of random sets of 2D points having a variety of different\n * distributions and constraints (and associated functions).\n * \n * @author Michael Carleton\n * @since 1.2.0\n *\n */\npublic final class PGS_PointSet {\n\n\tprivate static final float SQRT_3 = (float) Math.sqrt(3);\n\t/** Golden angle (in radians) */\n\tprivate static final float GOLDEN_ANGLE = (float) (Math.PI * (3 - Math.sqrt(5)));\n\n\tprivate PGS_PointSet() {\n\t}\n\n\t/**\n\t * Returns a filtered copy of the input, containing no points that are within\n\t * the <code>distanceTolerance</code> of each other.\n\t * <p>\n\t * This method can be used to convert a random point set into a blue-noise-like\n\t * (poisson) point set.\n\t * \n\t * @param points            list of points to filter\n\t * @param distanceTolerance a point that is within this distance of a previously\n\t *                          included point is not included in the output\n\t * @return\n\t */\n\tpublic static List<PVector> prunePointsWithinDistance(List<PVector> points, double distanceTolerance) {\n\t\tfinal KDTree<PVector> tree = KDTree.create(2);\n\t\tfinal List<PVector> newPoints = new ArrayList<>();\n\t\tfor (PVector p : points) {\n\t\t\tfinal double[] coords = new double[] { p.x, p.y };\n\t\t\tif (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {\n\t\t\t\ttree.insert(coords, p);\n\t\t\t\tnewPoints.add(p);\n\t\t\t}\n\t\t}\n\t\treturn newPoints;\n\t}\n\n\t/**\n\t * Sorts a list of points according to the Hilbert space-filling curve to ensure\n\t * a high-degree of spatial locality in the sequence of points.\n\t * \n\t * @param points list of points to sort. a list requires at least 24 points to\n\t *               be sorted.\n\t * @return a sorted <b>copy</b> of the input list, having a different order\n\t *         according to points' Hilbert ranking of their (x, y) coordinate\n\t * @since 1.3.0\n\t */\n\tpublic static List<PVector> hilbertSort(List<PVector> points) {\n\t\tdouble xMin, xMax, yMin, yMax;\n\t\tif (points.isEmpty()) {\n\t\t\treturn points;\n\t\t}\n\n\t\t// find bounds\n\t\tPVector v = points.get(0);\n\t\txMin = v.x;\n\t\txMax = v.x;\n\t\tyMin = v.y;\n\t\tyMax = v.y;\n\n\t\tfor (PVector PVector : points) {\n\t\t\tif (PVector.x < xMin) {\n\t\t\t\txMin = PVector.x;\n\t\t\t} else if (PVector.x > xMax) {\n\t\t\t\txMax = PVector.x;\n\t\t\t}\n\t\t\tif (PVector.y < yMin) {\n\t\t\t\tyMin = PVector.y;\n\t\t\t} else if (PVector.y > yMax) {\n\t\t\t\tyMax = PVector.y;\n\t\t\t}\n\t\t}\n\n\t\tdouble xDelta = xMax - xMin;\n\t\tdouble yDelta = yMax - yMin;\n\t\tif (xDelta == 0 || yDelta == 0) {\n\t\t\treturn points;\n\t\t}\n\t\tif (points.size() < 24) {\n\t\t\treturn points;\n\t\t}\n\n\t\tdouble hn = Math.log(points.size()) / 0.693147180559945 / 2.0;\n\t\tint nHilbert = (int) Math.floor(hn + 0.5);\n\t\tif (nHilbert < 4) {\n\t\t\tnHilbert = 4;\n\t\t}\n\n\t\t// could also use SortedMap<index -> point>\n\t\tList<Pair<Integer, PVector>> ranks = new ArrayList<>(points.size());\n\t\tdouble hScale = (1 << nHilbert) - 1.0;\n\t\t// scale coordinates to 2^n - 1\n\t\tfor (PVector vh : points) {\n\t\t\tint ix = (int) (hScale * (vh.x - xMin) / xDelta);\n\t\t\tint iy = (int) (hScale * (vh.y - yMin) / yDelta);\n\t\t\tranks.add(new Pair<>(xy2Hilbert(ix, iy, nHilbert), vh));\n\t\t}\n\n\t\tranks.sort((a, b) -> Integer.compare(a.getFirst(), b.getFirst()));\n\n\t\treturn ranks.stream().map(Pair::getSecond).collect(Collectors.toList());\n\t}\n\n\t/**\n\t * Clusters points into N groups, using k-means clustering.\n\t * <p>\n\t * K-means finds the N cluster centers and assigns points to the nearest cluster\n\t * center, such that the squared (euclidean) distances from the cluster are\n\t * minimised.\n\t * \n\t * @param points list of points to cluster\n\t * @param groups desired number of clustered groups\n\t * @since 1.4.0\n\t * @see #cluster(Collection, int, long)\n\t * @return list of groups, where each group is a list of PVectors\n\t */\n\tpublic static List<List<PVector>> cluster(Collection<PVector> points, int groups) {\n\t\treturn cluster(points, groups, System.nanoTime());\n\t}\n\n\t/**\n\t * Clusters points into N groups, using k-means clustering.\n\t * <p>\n\t * K-means finds the N cluster centers and assigns points to the nearest cluster\n\t * center, such that the squared (euclidean) distances from the cluster are\n\t * minimised.\n\t * \n\t * @param points list of points to cluster\n\t * @param groups desired number of clustered groups\n\t * @param seed   random seed\n\t * @since 1.4.0\n\t * @return list of groups, where each group is a list of PVectors\n\t * @see #cluster(Collection, int)\n\t */\n\tpublic static List<List<PVector>> cluster(Collection<PVector> points, int groups, long seed) {\n\t\tRandomGenerator r = new XoRoShiRo128PlusRandomGenerator(seed);\n\t\tClusterer<CPVector> kmeans = new KMeansPlusPlusClusterer<>(groups, 25, new EuclideanDistance(), r);\n\t\tList<CPVector> pointz = points.stream().map(p -> new CPVector(p)).collect(Collectors.toList());\n\n\t\tList<List<PVector>> clusters = new ArrayList<>(groups);\n\t\tkmeans.cluster(pointz).forEach(cluster -> {\n\t\t\tclusters.add(cluster.getPoints().stream().map(p -> p.p).collect(Collectors.toList()));\n\t\t});\n\n\t\treturn clusters;\n\t}\n\n\t/**\n\t * Finds the geometric median point of a set of weighted sample points.\n\t * <p>\n\t * The median point is the point that minimises the sum of (weighted) distances\n\t * to the sample points.\n\t * <p>\n\t * Points are expressed as PVectors; the z coordinate is used as the weight for\n\t * each point. Weights must be positive. If every point has a weight of 0 (z=0),\n\t * the function returns the median as if each point had an equal non-zero weight\n\t * (set to 1).\n\t * \n\t * @param points list of points, where the z coordinate is point weight\n\t * @since 1.4.0\n\t * @return 2D median point\n\t */\n\tpublic static PVector weightedMedian(Collection<PVector> points) {\n\t\tboolean allZero = points.stream().allMatch(p -> p.z == 0);\n\t\tPoint4d[] wp = points.stream().map(p -> new Point4d(p.x, p.y, 0, allZero ? 1 : p.z)).toArray(Point4d[]::new);\n\t\tPoint3d median = GeometricMedian.median(wp, 1e-3, 50);\n\t\treturn new PVector((float) median.x, (float) median.y);\n\t}\n\n\t/**\n\t * Generates a set of random (uniform) points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #random(double, double, double, double, int, long) seeded random()\n\t */\n\tpublic static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn random(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random (uniform) points that lie within a bounding\n\t * rectangle, using the specified seed.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #random(double, double, double, double, int) non-seeded random()\n\t */\n\tpublic static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (xMin + (xMax - xMin) * random.nextDouble());\n\t\t\tfinal float y = (float) (yMin + (yMax - yMin) * random.nextDouble());\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random points having a gaussian/normal distribution. The\n\t * point set is centered around the given center, given by mean coordinates.\n\t * \n\t * @param centerX x coordinate of the center/mean of the point set\n\t * @param centerY x coordinate of the center/mean of the point set\n\t * @param sd      standard deviation, which specifies how much the values can\n\t *                vary from the mean. 68% of point samples have a value within\n\t *                one standard deviation of the mean; three standard deviations\n\t *                account for 99.7% of the sample population\n\t * @param n       number of points to generate\n\t * @return\n\t * @see #gaussian(double, double, double, int, long) seeded gaussian()\n\t */\n\tpublic static List<PVector> gaussian(double centerX, double centerY, double sd, int n) {\n\t\treturn gaussian(centerX, centerY, sd, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random points having a gaussian/normal distribution, using\n\t * the specified seed. The point set is centered around the given center, given\n\t * by mean coordinates.\n\t * \n\t * @param centerX x coordinate of the center/mean of the point set\n\t * @param centerY x coordinate of the center/mean of the point set\n\t * @param sd      standard deviation, which specifies how much the values can\n\t *                vary from the mean. 68% of point samples have a value within\n\t *                one standard deviation of the mean; three standard deviations\n\t *                account for 99.7% of the sample population\n\t * @param n       number of points to generate\n\t * @param seed    number used to initialize the underlying pseudorandom number\n\t *                generator\n\t * @return\n\t * @see #gaussian(double, double, double, int) non-seeded gaussian()\n\t */\n\tpublic static List<PVector> gaussian(double centerX, double centerY, double sd, int n, long seed) {\n\t\tfinal RandomGenerator random = new XoRoShiRo128PlusRandomGenerator(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (sd * random.nextGaussian() + centerX);\n\t\t\tfinal float y = (float) (sd * random.nextGaussian() + centerY);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a square grid/lattice of points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @return\n\t */\n\tpublic static List<PVector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,\n\t\t\tfinal double pointDistance) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\tfor (double x = 0; x < width; x += pointDistance) {\n\t\t\tfor (double y = 0; y < height; y += pointDistance) {\n\t\t\t\tpoints.add(new PVector((float) (x + xMin), (float) (y + yMin)));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagon grid/lattice of points that lie within a bounding\n\t * rectangle.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #hexGrid(double, double, double, double, double) hexGrid() where\n\t *      inter-point distance is specified\n\t */\n\tpublic static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal float h = (float) Math.sqrt((width * height * (Math.sqrt(5) / 2)) / n);\n\t\tfinal float v = (float) (h * (2 / Math.sqrt(5)));\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\n\t\tfor (int i = 0; i < width / h; i++) {\n\t\t\tfor (int j = 0; j < height / v; j++) {\n\t\t\t\tpoints.add(new PVector((i - (j % 2) / 2f) * h + (float) xMin, j * v + (float) yMin));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagon grid of points that lie within a bounding rectangle.\n\t * \n\t * @param xMin          x-coordinate of boundary minimum\n\t * @param yMin          y-coordinate of boundary minimum\n\t * @param xMax          x-coordinate of boundary maximum\n\t * @param yMax          y-coordinate of boundary maximum\n\t * @param pointDistance inter-point distance\n\t * @return\n\t * @see #hexGrid(double, double, double, double, int) hexGrid() where number of\n\t *      points is specified\n\t */\n\tpublic static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,\n\t\t\tfinal double pointDistance) {\n\t\tfinal double width = xMax - xMin;\n\t\tfinal double height = yMax - yMin;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\tfor (int i = 0; i < width / pointDistance; i++) {\n\t\t\tfor (int j = 0; j < height / pointDistance; j++) {\n\t\t\t\tpoints.add(new PVector((float) ((i - (j % 2) / 2f) * pointDistance + xMin), (float) (j * pointDistance + yMin)));\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a hexagonal grid of points <b>arranged in a hexagon pattern</b>.\n\t * \n\t * @param centerX x coordinate of the hexagon center point\n\t * @param centerY y coordinate of the hexagon center point\n\t * @param length  layers/no. of points on each hexagon side\n\t * @distance inter-point distance\n\t * @return\n\t */\n\tpublic static List<PVector> hexagon(double centerX, double centerY, int length, double distance) {\n\t\tfinal float xOffset = (float) centerX;\n\t\tfinal float yOffset = (float) centerY;\n\t\tfinal float d = (float) distance;\n\n\t\tfinal List<PVector> points = new ArrayList<>();\n\n\t\t/*\n\t\t * PVector .z is set to length so hexagon layer can be easily identified.\n\t\t */\n\t\tfor (int i = 0; i <= (length - 1); i++) {\n\t\t\tfloat y = (SQRT_3 * i * d) / 2.0f;\n\t\t\tfor (int j = 0; j < (2 * length - 1 - i); j++) {\n\t\t\t\tfloat x = (-(2 * length - i - 2) * d) / 2.0f + j * d;\n\t\t\t\tpoints.add(new PVector(x + xOffset, y + yOffset, length));\n\t\t\t\tif (y != 0) {\n\t\t\t\t\tpoints.add(new PVector(x + xOffset, -y + yOffset, length));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of n points that are randomly distributed on a ring\n\t * (annulus).\n\t * \n\t * @param centerX     x coordinate of the center/mean of the ring\n\t * @param centerY     x coordinate of the center/mean of the ring\n\t * @param innerRadius radius of the ring's hole\n\t * @param outerRadius outer radius of the ring\n\t * @param maxAngle    angle of the ring (in radians). Can be negative\n\t * @param n           the number of random points to generate\n\t * @return a list of PVector objects representing the (x, y) coordinates of the\n\t *         random points\n\t * @see #ring(double, double, double, double, double, int, long) seeded ring()\n\t */\n\tpublic static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {\n\t\treturn ring(centerX, centerY, innerRadius, outerRadius, maxAngle, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of points that are randomly distributed on a ring (annulus).\n\t * \n\t * @param centerX     x coordinate of the center/mean of the ring\n\t * @param centerY     x coordinate of the center/mean of the ring\n\t * @param innerRadius radius of the ring's hole\n\t * @param outerRadius outer radius of the ring\n\t * @param maxAngle    angle of the ring (in radians). Can be negative\n\t * @param n           the number of random points to generate\n\t * @param seed        number used to initialize the underlying pseudorandom\n\t *                    number generator\n\t * @return a list of PVector objects representing the (x, y) coordinates of the\n\t *         random points\n\t * @see #ring(double, double, double, double, double, int) non-seeded ring()\n\t */\n\tpublic static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,\n\t\t\tlong seed) {\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tif (maxAngle == 0) {\n\t\t\tmaxAngle = Double.MIN_VALUE;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdouble randomAngle = (maxAngle < 0 ? -1 : 1) * random.nextDouble(Math.abs(maxAngle));\n\t\t\tdouble randomRadius = random.nextDouble(innerRadius, outerRadius);\n\t\t\tdouble x = -Math.sin(randomAngle) * randomRadius;\n\t\t\tdouble y = Math.cos(randomAngle) * randomRadius;\n\n\t\t\tpoints.add(new PVector((float) (x + centerX), (float) (y + centerY)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random points (constrained within a rectangular region)\n\t * via Poisson Disk Sampling.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin    x-coordinate of boundary minimum\n\t * @param yMin    y-coordinate of boundary minimum\n\t * @param xMax    x-coordinate of boundary maximum\n\t * @param yMax    y-coordinate of boundary maximum\n\t * @param minDist minimum euclidean distance between any two points\n\t * @return\n\t * @see #poisson(double, double, double, double, double, long) seeded poisson()\n\t */\n\tpublic static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {\n\t\treturn poisson(xMin, yMin, xMax, yMax, minDist, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random points (constrained within a rectangular region)\n\t * via Poisson Disk Sampling, using the specified seed.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin    x-coordinate of boundary minimum\n\t * @param yMin    y-coordinate of boundary minimum\n\t * @param xMax    x-coordinate of boundary maximum\n\t * @param yMax    y-coordinate of boundary maximum\n\t * @param minDist minimum euclidean distance between any two points\n\t * @param seed    number used to initialize the underlying pseudorandom number\n\t *                generator\n\t * @return\n\t * @see #poisson(double, double, double, double, double) non-seeded poisson()\n\t */\n\tpublic static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist, long seed) {\n\t\tfinal PoissonDistributionJRUS pd = new PoissonDistributionJRUS(seed);\n\t\treturn pd.generate(xMin, yMin, xMax, yMax, minDist);\n\t}\n\n\t/**\n\t * Generates a poisson point set having N points constrained within a\n\t * rectangular region.\n\t * <p>\n\t * Poisson-disc sampling produces points that are tightly-packed, but no closer\n\t * to each other than a specified minimum distance, resulting in a more natural\n\t * and desirable pattern for many applications. This distribution is also\n\t * described as blue noise.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    target size of poisson point set\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t */\n\tpublic static List<PVector> poissonN(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal PoissonDistributionJRUS pd = new PoissonDistributionJRUS(seed);\n\t\treturn pd.generate(xMin, yMin, xMax, yMax, n);\n\t}\n\n\t/**\n\t * Generates a set of points arranged in a phyllotaxis pattern (an arrangement\n\t * similar to the florets in the head of a sunflower), using the golden ratio\n\t * (the most irrational number) to position points with the least possible\n\t * aliasing (which is arguably the \"best\" arrangement).\n\t * \n\t * @param centerX x coordinate of the center of the point set\n\t * @param centerY y coordinate of the center of the point set\n\t * @param n       number of points to generate\n\t * @param radius  radius of circular phyllotaxis extent (max distance of a point\n\t *                from the center position)\n\t * @return\n\t */\n\tpublic static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius) {\n\t\treturn phyllotaxis(centerX, centerY, n, radius, 2 * Math.PI - GOLDEN_ANGLE);\n\t}\n\n\t/**\n\t * Generates a set of points arranged in a phyllotaxis pattern (an arrangement\n\t * similar to the florets in the head of a sunflower), using a user-defined\n\t * theta.\n\t * \n\t * @param centerX x coordinate of the center of the point set\n\t * @param centerY y coordinate of the center of the point set\n\t * @param n       number of points to generate\n\t * @param radius  radius of circular phyllotaxis extent (max distance of a point\n\t *                from the center position)\n\t * @param theta   angle (in radians) to turn after each point placement\n\t * @return\n\t */\n\tpublic static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {\n\t\tfinal double fillArea = radius * radius * Math.PI; // calculate area to be filled\n\t\tfinal double circleSpace = (fillArea / n); // area per circle\n\t\tfinal double fudge = 0.7; // Fudge factor: breathing space between circles\n\t\tfinal float circleRadius = (float) (Math.sqrt(circleSpace / Math.PI) * fudge);\n\n\t\tfloat cumArea = 0; // cumulative circle area\n\n\t\tfinal List<PVector> outList = new ArrayList<>();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tfinal double angle = i * theta; // rotation per circle\n\t\t\tcumArea += circleSpace; // add sm_area to cum_area every loop\n\n\t\t\tfinal double spiralR = Math.sqrt(cumArea / Math.PI); // expansion of spiral (distance of circle) per loop\n\n\t\t\tfloat pX = (float) (centerX + Math.cos(angle) * spiralR); // spiral rotation of golden angle per loop on X\n\t\t\tfloat pY = (float) (centerY + Math.sin(angle) * spiralR); // spiral rotation of golden angle per loop on Y\n\n\t\t\toutList.add(new PVector(pX, pY, circleRadius));\n\t\t}\n\t\treturn outList;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number (the\n\t * plastic constant).\n\t * <p>\n\t * The <i>plastic LDS</i> has been <a href=\n\t * \"http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\">shown</a>\n\t * to have superior low discrepancy properties amongst the quasirandom\n\t * sequences, and is therefore recommended.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/irrational_numbers/irrational_numbers.cpp\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfinal double p = 1.32471795724474602596; // plastic constant\n\t\tfinal double a1 = 1.0 / p; // inverse of plastic number\n\t\tfinal double a2 = 1.0 / (p * p);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (((0.5 + a1 * i) % 1) * w + xMin);\n\t\t\tfinal float y = (float) (((0.5 + a2 * i) % 1) * h + yMin);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number. In this\n\t * method, a random jitter is added to points to give the point set\n\t * blue-noise-like properties.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #plasticJitteredLDS(double, double, double, double, int, long) seeded\n\t *      irrationalJitteredLDS()\n\t */\n\tpublic static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn plasticJitteredLDS(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on an irrational number. In this\n\t * method, a random jitter is added to points to give the point set\n\t * blue-noise-like properties.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #plasticJitteredLDS(double, double, double, double, int) non-seeded\n\t *      irrationalJitteredLDS()\n\t */\n\tpublic static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/irrational_numbers/irrational_numbers.cpp\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfinal SplittableRandom random = new SplittableRandom(seed);\n\t\tfinal double p = 1.32471795724474602596; // plastic constant\n\t\tfinal double a1 = 1.0 / p;\n\t\tfinal double a2 = 1.0 / (p * p);\n\t\tfinal double c_magicNumber = 0.732;\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfinal float x = (float) (((random.nextDouble() * c_magicNumber / Math.sqrt(i + 1d) + a1 * i) % 1) * w + xMin);\n\t\t\tfinal float y = (float) (((random.nextDouble() * c_magicNumber / Math.sqrt(i + 1d) + a2 * i) % 1) * h + yMin);\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on a Halton sequence.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> haltonLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfloat[][] values = new float[n][2];\n\t\tvanDerCorput(values, 2, 0, true, 0);\n\t\tvanDerCorput(values, 3, 1, true, 0);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (float[] point : values) {\n\t\t\tpoints.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of deterministic stratified points (bounded by a rectangle)\n\t * from a low discrepancy sequence (LDS) based on a Hammersley sequence.\n\t * <p>\n\t * The Hammersley sequence in 2D is just the 1d Van Der Corput sequence on one\n\t * axis, and regular sampling on the other axis.\n\t * <p>\n\t * Low discrepancy sequences are deterministic (not randomized) number sequences\n\t * that are low discrepancy - meaning the points tend not to clump together and\n\t * leave holes; the resulting point set is more evenly spaced than a simple\n\t * random distribution but less regular than lattices.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t */\n\tpublic static List<PVector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfloat[][] values = new float[n][2];\n\t\tvanDerCorput(values, 2, 0, false, 0);\n\n\t\tfinal float offset = 1.0f / (n * 2);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvalues[i][1] = offset + (i / (float) n);\n\t\t}\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (float[] point : values) {\n\t\t\tpoints.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));\n\t\t}\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a set of random stratified points (bounded by a rectangle) based on\n\t * the \"N-Rooks\" sampling pattern.\n\t * <p>\n\t * N-Rooks is a sampling pattern where you treat the boundary as if it were a\n\t * chess board. Every sampling position is a rook that could move horizontally\n\t * or vertically, and should be placed such that none of these rooks could\n\t * capture/\"see\" any of the other rooks. In other words, every column has a\n\t * single sample point in it, and every row has a single sample point in it.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @return\n\t * @see #nRooksLDS(double, double, double, double, int, long)\n\t */\n\tpublic static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\treturn nRooksLDS(xMin, yMin, xMax, yMax, n, System.nanoTime());\n\t}\n\n\t/**\n\t * Generates a set of random stratified points (bounded by a rectangle) based on\n\t * the \"N-Rooks\" sampling pattern.\n\t * <p>\n\t * N-Rooks is a sampling pattern where you treat the boundary as if it were a\n\t * chess board. Every sampling position is a rook that could move horizontally\n\t * or vertically, and should be placed such that none of these rooks could\n\t * capture/\"see\" any of the other rooks. In other words, every column has a\n\t * single sample point in it, and every row has a single sample point in it.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @param seed number used to initialize the underlying pseudorandom number\n\t *             generator\n\t * @return\n\t * @see #nRooksLDS(double, double, double, double, int)\n\t */\n\tpublic static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\n\t\tfinal List<Integer> rookPositions = IntStream.range(0, n).boxed().collect(Collectors.toList());\n\t\tCollections.shuffle(rookPositions, new XoRoShiRo128PlusRandom(seed));\n\n\t\tfinal float offset = 1.0f / (n * 2);\n\n\t\tfinal List<PVector> points = new ArrayList<>(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfloat x = offset + (rookPositions.get(i) / (float) n);\n\t\t\tx *= w;\n\t\t\tx += xMin;\n\t\t\tfloat y = offset + i / (float) n;\n\t\t\ty *= h;\n\t\t\ty += yMin;\n\t\t\tpoints.add(new PVector(x, y));\n\t\t}\n\n\t\treturn points;\n\t}\n\n\t/**\n\t * Generates a 2D set of deterministic stratified points (bounded by a\n\t * rectangle) from the Sobol low discrepancy sequence (LDS).\n\t * <p>\n\t * A Sobol sequence is a low-discrepancy sequence with the property that for all\n\t * values of N,its subsequence (x1, ... xN) has a low discrepancy. It can be\n\t * used to generate pseudo-randompoints in a space S, which are\n\t * equi-distributed.\n\t * \n\t * @param xMin x-coordinate of boundary minimum\n\t * @param yMin y-coordinate of boundary minimum\n\t * @param xMax x-coordinate of boundary maximum\n\t * @param yMax y-coordinate of boundary maximum\n\t * @param n    number of points to generate\n\t * @since 1.4.0\n\t * @return\n\t */\n\tpublic static List<PVector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {\n\t\tfinal double w = xMax - xMin;\n\t\tfinal double h = yMax - yMin;\n\t\tfinal int dimension = 2;\n\t\tfinal int BITS = 52;\n\t\tfinal double SCALE = FastMath.pow(2, BITS);\n\t\tfinal long[][] direction = new long[dimension][BITS + 1];\n\t\tfinal long[] x = new long[dimension];\n\t\tfinal int[] m = new int[] { 0, 1 };\n\t\tfinal int a = 0;\n\t\tfinal int s = m.length - 1;\n\n\t\tfor (int i = 1; i <= BITS; i++) {\n\t\t\tdirection[0][i] = 1l << (BITS - i);\n\t\t}\n\n\t\t// init direction vector\n\t\tfinal int d = 1;\n\t\tfor (int i = 1; i <= s; i++) {\n\t\t\tdirection[d][i] = ((long) m[i]) << (BITS - i);\n\t\t}\n\t\tfor (int i = s + 1; i <= BITS; i++) {\n\t\t\tdirection[d][i] = direction[d][i - s] ^ (direction[d][i - s] >> s);\n\t\t\tfor (int k = 1; k <= s - 1; k++) {\n\t\t\t\tdirection[d][i] ^= ((a >> (s - 1 - k)) & 1) * direction[d][i - k];\n\t\t\t}\n\t\t}\n\n\t\tList<PVector> output = new ArrayList<>(n);\n\t\tfor (int i = 1; i < n; i++) {\n\n\t\t\t// find the index c of the rightmost 0\n\t\t\tint c = 1;\n\t\t\tint value = i - 1;\n\t\t\twhile ((value & 1) == 1) {\n\t\t\t\tvalue >>= 1;\n\t\t\t\tc++;\n\t\t\t}\n\n\t\t\tx[0] ^= direction[0][c];\n\t\t\tx[1] ^= direction[1][c];\n\t\t\tdouble vX = x[0] / SCALE;\n\t\t\tvX *= w;\n\t\t\tvX += xMin;\n\t\t\tdouble vY = x[1] / SCALE;\n\t\t\tvY *= h;\n\t\t\tvY += yMin;\n\t\t\toutput.add(new PVector((float) vX, (float) vY));\n\t\t}\n\n\t\treturn output;\n\t}\n\n\t/**\n\t * Computes the <i>Euclidean minimum spanning tree</i> (EMST) of a set of\n\t * points.\n\t * <p>\n\t * The EMST is a system of line segments, having only the given points as their\n\t * endpoints, whose union includes all of the points in a connected set, and\n\t * which has the minimum possible total length of any such system.\n\t * \n\t * @param points the set of points over which to compute the EMST\n\t * @return a LINES PShape\n\t * @since 1.3.0\n\t */\n\tpublic static PShape minimumSpanningTree(List<PVector> points) {\n\t\t/*\n\t\t * The Euclidean minimum spanning tree in a plane is a subgraph of the Delaunay\n\t\t * triangulation.\n\t\t */\n\t\tIIncrementalTin triangulation = PGS_Triangulation.delaunayTriangulationMesh(points);\n\t\tSimpleGraph<PVector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);\n\t\tSpanningTreeAlgorithm<PEdge> st = new PrimMinimumSpanningTree<>(graph); // faster than kruskal algorithm\n\t\treturn PGS_SegmentSet.toPShape(st.getSpanningTree().getEdges());\n\t}\n\n\t/**\n\t * Computes the hilbert index of a coordinate on a hilbert curve of order n.\n\t */\n\tprivate static int xy2Hilbert(final int px, final int py, final int n) {\n\t\tint i, xi, yi;\n\t\tint s, temp;\n\n\t\tint x = px;\n\t\tint y = py;\n\t\ts = 0; // Initialize.\n\t\tfor (i = n - 1; i >= 0; i--) {\n\t\t\txi = (x >> i) & 1; // Get bit i of x.\n\t\t\tyi = (y >> i) & 1; // Get bit i of y.\n\n\t\t\tif (yi == 0) {\n\t\t\t\ttemp = x; // Swap x and y and,\n\t\t\t\tx = y ^ (-xi); // if xi = 1,\n\t\t\t\ty = temp ^ (-xi); // complement them.\n\t\t\t}\n\t\t\ts = 4 * s + 2 * xi + (xi ^ yi); // Append two bits to s.\n\t\t}\n\t\treturn s;\n\t}\n\n\t/**\n\t * @param values\n\t * @param base\n\t * @param axis         0 = x axis; 1 = y axis\n\t * @param skipZero\n\t * @param truncateBits\n\t */\n\tprivate static void vanDerCorput(float[][] values, int base, int axis, boolean skipZero, int truncateBits) {\n\t\t// https://blog.demofox.org/2017/05/29/when-random-numbers-are-too-random-low-discrepancy-sequences/\n\t\t// https://github.com/Atrix256/SampleZoo/blob/master/src/families/_2d/samples/lds/LDS.cpp\n\t\t// figure out how many bits we are working in.\n\t\tint n = values.length;\n\t\tint value = 1;\n\t\tint numBits = 0;\n\t\twhile (value < n) {\n\t\t\tvalue *= 2;\n\t\t\t++numBits;\n\t\t}\n\t\tint numBitsPreserved = numBits - truncateBits;\n\t\tint bitsPreservedMask = numBitsPreserved > 0 ? (1 << numBitsPreserved) - 1 : 0;\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tvalues[i][axis] = 0.0f;\n\t\t\tfloat denominator = base;\n\t\t\tint q = i + (skipZero ? 1 : 0);\n\t\t\tq &= bitsPreservedMask;\n\t\t\twhile (q > 0) {\n\t\t\t\tint multiplier = q % base;\n\t\t\t\tvalues[i][axis] += multiplier / denominator;\n\t\t\t\tq = q / base;\n\t\t\t\tdenominator *= base;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class CPVector implements Clusterable {\n\t\tfinal PVector p;\n\t\tfinal double[] point;\n\n\t\tCPVector(PVector p) {\n\t\t\tthis.p = p;\n\t\t\tpoint = new double[] { p.x, p.y };\n\t\t}\n\n\t\t@Override\n\t\tpublic double[] getPoint() {\n\t\t\treturn point;\n\t\t}\n\t}\n\n}\n",
    "project": "PGS",
    "libraryName": "tinspin-indexes",
    "libraryGroupID": "org.tinspin",
    "newVersion": "2.0.1",
    "previousVersion": "1.7.1",
    "breakingCommit": "e70bd198fa1e1d65f86e071b8ebdd021141cfa95"
}