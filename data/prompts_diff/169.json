{
    "absolute_path_to_file_in_container": "/plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java",
    "errors": [
        {
            "line_number": 29,
            "message": "[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[29,35] cannot find symbol",
            "additional_info": "  symbol:   class ClosedInputStream\n  location: package org.apache.commons.io.input",
            "file_name": "ByteArrayOutputStream.java",
            "BCs": [
                {
                    "element": "org.apache.commons.io.output.ByteArrayOutputStream",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "org.apache.commons.io.input.ClosedInputStream",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "d8250285-fcd4-5871-8f8a-9c7c379ca9ac"
        },
        {
            "line_number": 401,
            "message": "[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[401,24] cannot find symbol",
            "additional_info": "  symbol:   class ClosedInputStream\n  location: class org.codehaus.plexus.archiver.zip.ByteArrayOutputStream",
            "file_name": "ByteArrayOutputStream.java",
            "BCs": [
                {
                    "element": "org.apache.commons.io.output.ByteArrayOutputStream",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "org.apache.commons.io.input.ClosedInputStream",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "ee9f8ef4-37ee-54f7-ba9b-a1a86244d5ab"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ClosedInputStream();\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n\n'''\nThe error is caused by a change in the API of the dependency: commons-io 2.11.0->20030203.000550. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- org.apache.commons.io.output.ByteArrayOutputStream\n-- org.apache.commons.io.input.ClosedInputStream\n-- org.apache.commons.io.input.BoundedInputStream\n-- org.apache.commons.io.output.CountingOutputStream.getByteCount\n-- org.apache.commons.io.input.CountingInputStream.getByteCount\n~~ SUPERTYPE_REMOVED <- org.apache.commons.io.input.CountingInputStream\n-- org.apache.commons.io.output.NullPrintStream\n-- org.apache.commons.io.output.ThresholdingOutputStream\n~~ METHOD_NOW_FINAL <- org.apache.commons.io.output.DemuxOutputStream.write\n-- org.apache.commons.io.FileUtils.write\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(byte[])\n++ public void org.apache.commons.io.ProxyOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.compress.zip.ZipOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.ProxyOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(byte[])\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.ProxyOutputStream.write(byte[])\n\nThe error is triggered in the following specific lines in the previous code:\nimport org.apache.commons.io.input.ClosedInputStream;\n            return new ClosedInputStream();\nwith the following error message:\n[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[29,35] cannot find symbol  symbol:   class ClosedInputStream\n  location: package org.apache.commons.io.input\n[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[401,24] cannot find symbol  symbol:   class ClosedInputStream\n  location: class org.codehaus.plexus.archiver.zip.ByteArrayOutputStream\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import org.apache.commons.io.input.ClosedInputStream;\n            return new ClosedInputStream();",
    "error_message": "[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[29,35] cannot find symbol  symbol:   class ClosedInputStream\n  location: package org.apache.commons.io.input\n[ERROR] /plexus-archiver/src/main/java/org/codehaus/plexus/archiver/zip/ByteArrayOutputStream.java:[401,24] cannot find symbol  symbol:   class ClosedInputStream\n  location: class org.codehaus.plexus.archiver.zip.ByteArrayOutputStream",
    "api_diff": "-- org.apache.commons.io.output.ByteArrayOutputStream\n-- org.apache.commons.io.input.ClosedInputStream\n-- org.apache.commons.io.input.BoundedInputStream\n-- org.apache.commons.io.output.CountingOutputStream.getByteCount\n-- org.apache.commons.io.input.CountingInputStream.getByteCount\n~~ SUPERTYPE_REMOVED <- org.apache.commons.io.input.CountingInputStream\n-- org.apache.commons.io.output.NullPrintStream\n-- org.apache.commons.io.output.ThresholdingOutputStream\n~~ METHOD_NOW_FINAL <- org.apache.commons.io.output.DemuxOutputStream.write\n-- org.apache.commons.io.FileUtils.write\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(byte[])\n++ public void org.apache.commons.io.ProxyOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.compress.zip.ZipOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.ProxyOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(byte[])\n++ public void org.apache.commons.io.compress.tar.TarOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(int)\n++ public void org.apache.commons.io.output.CountingOutputStream.write(byte[],int,int)\n++ public void org.apache.commons.io.ProxyOutputStream.write(byte[])",
    "original_code": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.codehaus.plexus.archiver.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SequenceInputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.commons.io.input.ClosedInputStream;\n\n/**\n * This class implements an output stream in which the data is\n * written into a byte array. The buffer automatically grows as data\n * is written to it.\n * <p>\n * The data can be retrieved using <code>toByteArray()</code> and\n * <code>toString()</code>.\n * <p>\n * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n * this class can be called after the stream has been closed without\n * generating an {@code IOException}.\n * <p>\n * This is an alternative implementation of the {@link java.io.ByteArrayOutputStream}\n * class. The original implementation only allocates 32 bytes at the beginning.\n * As this class is designed for heavy duty it starts at 1024 bytes. In contrast\n * to the original it doesn't reallocate the whole memory block but allocates\n * additional buffers. This way no buffers need to be garbage collected and\n * the contents don't have to be copied to the new buffer. This class is\n * designed to behave exactly like the original. The only exception is the\n * deprecated toString(int) method that has been ignored.\n */\npublic class ByteArrayOutputStream extends OutputStream\n{\n\n    /**\n     * A singleton empty byte array.\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[ 0 ];\n\n    /**\n     * The list of buffers, which grows and never reduces.\n     */\n    private final List<byte[]> buffers = new ArrayList<byte[]>();\n\n    /**\n     * The index of the current buffer.\n     */\n    private int currentBufferIndex;\n\n    /**\n     * The total count of bytes in all the filled buffers.\n     */\n    private int filledBufferSum;\n\n    /**\n     * The current buffer.\n     */\n    private byte[] currentBuffer;\n\n    /**\n     * The total count of bytes written.\n     */\n    private int count;\n\n    /**\n     * Flag to indicate if the buffers can be reused after reset\n     */\n    private boolean reuseBuffers = true;\n\n    /**\n     * Creates a new byte array output stream. The buffer capacity is\n     * initially 1024 bytes, though its size increases if necessary.\n     */\n    public ByteArrayOutputStream()\n    {\n        this( 1024 );\n    }\n\n    /**\n     * Creates a new byte array output stream, with a buffer capacity of\n     * the specified size, in bytes.\n     *\n     * @param size the initial size\n     *\n     * @throws IllegalArgumentException if size is negative\n     */\n    public ByteArrayOutputStream( final int size )\n    {\n        if ( size < 0 )\n        {\n            throw new IllegalArgumentException( \"Negative initial size: \" + size );\n        }\n        synchronized ( this )\n        {\n            needNewBuffer( size );\n        }\n    }\n\n    /**\n     * Makes a new buffer available either by allocating\n     * a new one or re-cycling an existing one.\n     *\n     * @param newcount the size of the buffer if one is created\n     */\n    private void needNewBuffer( final int newcount )\n    {\n        if ( currentBufferIndex < buffers.size() - 1 )\n        {\n            //Recycling old buffer\n            filledBufferSum += currentBuffer.length;\n\n            currentBufferIndex++;\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Creating new buffer\n            int newBufferSize;\n            if ( currentBuffer == null )\n            {\n                newBufferSize = newcount;\n                filledBufferSum = 0;\n            }\n            else\n            {\n                newBufferSize = Math.max(\n                    currentBuffer.length << 1,\n                    newcount - filledBufferSum );\n                filledBufferSum += currentBuffer.length;\n            }\n\n            currentBufferIndex++;\n            currentBuffer = new byte[ newBufferSize ];\n            buffers.add( currentBuffer );\n        }\n    }\n\n    /**\n     * Write the bytes to byte array.\n     *\n     * @param b the bytes to write\n     * @param off The start offset\n     * @param len The number of bytes to write\n     */\n    @Override\n    public void write( final byte[] b, final int off, final int len )\n    {\n        if ( ( off < 0 )\n                 || ( off > b.length )\n                 || ( len < 0 )\n                 || ( ( off + len ) > b.length )\n                 || ( ( off + len ) < 0 ) )\n        {\n            throw new IndexOutOfBoundsException();\n        }\n        else if ( len == 0 )\n        {\n            return;\n        }\n        synchronized ( this )\n        {\n            final int newcount = count + len;\n            int remaining = len;\n            int inBufferPos = count - filledBufferSum;\n            while ( remaining > 0 )\n            {\n                final int part = Math.min( remaining, currentBuffer.length - inBufferPos );\n                System.arraycopy( b, off + len - remaining, currentBuffer, inBufferPos, part );\n                remaining -= part;\n                if ( remaining > 0 )\n                {\n                    needNewBuffer( newcount );\n                    inBufferPos = 0;\n                }\n            }\n            count = newcount;\n        }\n    }\n\n    /**\n     * Write a byte to byte array.\n     *\n     * @param b the byte to write\n     */\n    @Override\n    public synchronized void write( final int b )\n    {\n        int inBufferPos = count - filledBufferSum;\n        if ( inBufferPos == currentBuffer.length )\n        {\n            needNewBuffer( count + 1 );\n            inBufferPos = 0;\n        }\n        currentBuffer[inBufferPos] = (byte) b;\n        count++;\n    }\n\n    /**\n     * Writes the entire contents of the specified input stream to this\n     * byte stream. Bytes from the input stream are read directly into the\n     * internal buffers of this streams.\n     *\n     * @param in the input stream to read from\n     *\n     * @return total number of bytes read from the input stream\n     * (and written to this stream)\n     *\n     * @throws java.io.IOException if an I/O error occurs while reading the input stream\n     * @since 1.4\n     */\n    public synchronized int write( final InputStream in ) throws IOException\n    {\n        int readCount = 0;\n        int inBufferPos = count - filledBufferSum;\n        int n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        while ( n != -1 )\n        {\n            readCount += n;\n            inBufferPos += n;\n            count += n;\n            if ( inBufferPos == currentBuffer.length )\n            {\n                needNewBuffer( currentBuffer.length );\n                inBufferPos = 0;\n            }\n            n = in.read( currentBuffer, inBufferPos, currentBuffer.length - inBufferPos );\n        }\n        return readCount;\n    }\n\n    /**\n     * Return the current size of the byte array.\n     *\n     * @return the current size of the byte array\n     */\n    public synchronized int size()\n    {\n        return count;\n    }\n\n    /**\n     * Closing a {@code ByteArrayOutputStream} has no effect. The methods in\n     * this class can be called after the stream has been closed without\n     * generating an {@code IOException}.\n     *\n     * @throws java.io.IOException never (this method should not declare this exception\n     * but it has to now due to backwards compatibility)\n     */\n    @Override\n    public void close() throws IOException\n    {\n        //nop\n    }\n\n    /**\n     * @see java.io.ByteArrayOutputStream#reset()\n     */\n    public synchronized void reset()\n    {\n        count = 0;\n        filledBufferSum = 0;\n        currentBufferIndex = 0;\n        if ( reuseBuffers )\n        {\n            currentBuffer = buffers.get( currentBufferIndex );\n        }\n        else\n        {\n            //Throw away old buffers\n            currentBuffer = null;\n            int size = buffers.get( 0 ).length;\n            buffers.clear();\n            needNewBuffer( size );\n            reuseBuffers = true;\n        }\n    }\n\n    /**\n     * Writes the entire contents of this byte stream to the\n     * specified output stream.\n     *\n     * @param out the output stream to write to\n     *\n     * @throws java.io.IOException if an I/O error occurs, such as if the stream is closed\n     * @see java.io.ByteArrayOutputStream#writeTo(java.io.OutputStream)\n     */\n    public synchronized void writeTo( final OutputStream out ) throws IOException\n    {\n        int remaining = count;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            out.write( buf, 0, c );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.0\n     */\n    public static InputStream toBufferedInputStream( final InputStream input )\n        throws IOException\n    {\n        return toBufferedInputStream( input, 1024 );\n    }\n\n    /**\n     * Fetches entire contents of an <code>InputStream</code> and represent\n     * same data as result InputStream.\n     * <p>\n     * This method is useful where,\n     * <ul>\n     * <li>Source InputStream is slow.</li>\n     * <li>It has network resources associated, so we cannot keep it open for\n     * long time.</li>\n     * <li>It has network timeout associated.</li>\n     * </ul>\n     * It can be used in favor of {@link #toByteArray()}, since it\n     * avoids unnecessary allocation and copy of byte[].<br>\n     * This method buffers the input internally, so there is no need to use a\n     * <code>BufferedInputStream</code>.\n     *\n     * @param input Stream to be fully buffered.\n     * @param size the initial buffer size\n     *\n     * @return A fully buffered stream.\n     *\n     * @throws java.io.IOException if an I/O error occurs\n     * @since 2.5\n     */\n    public static InputStream toBufferedInputStream( final InputStream input, int size )\n        throws IOException\n    {\n        // It does not matter if a ByteArrayOutputStream is not closed as close() is a no-op\n        @SuppressWarnings( \"resource\" )\n        final ByteArrayOutputStream output = new ByteArrayOutputStream( size );\n        output.write( input );\n        return output.toInputStream();\n    }\n\n    /**\n     * Gets the current contents of this byte stream as a Input Stream. The\n     * returned stream is backed by buffers of <code>this</code> stream,\n     * avoiding memory allocation and copy, thus saving space and time.<br>\n     *\n     * @return the current contents of this output stream.\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     * @see #reset()\n     * @since 2.5\n     */\n    public synchronized InputStream toInputStream()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return new ClosedInputStream();\n        }\n        final List<ByteArrayInputStream> list = new ArrayList<ByteArrayInputStream>( buffers.size() );\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            list.add( new ByteArrayInputStream( buf, 0, c ) );\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        reuseBuffers = false;\n        return new SequenceInputStream( Collections.enumeration( list ) );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a byte array.\n     * The result is independent of this stream.\n     *\n     * @return the current contents of this output stream, as a byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toByteArray()\n     */\n    public synchronized byte[] toByteArray()\n    {\n        int remaining = count;\n        if ( remaining == 0 )\n        {\n            return EMPTY_BYTE_ARRAY;\n        }\n        final byte newbuf[] = new byte[ remaining ];\n        int pos = 0;\n        for ( final byte[] buf : buffers )\n        {\n            final int c = Math.min( buf.length, remaining );\n            System.arraycopy( buf, 0, newbuf, pos, c );\n            pos += c;\n            remaining -= c;\n            if ( remaining == 0 )\n            {\n                break;\n            }\n        }\n        return newbuf;\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the platform default charset.\n     *\n     * @return the contents of the byte array as a String\n     *\n     * @see java.io.ByteArrayOutputStream#toString()\n     * @deprecated 2.5 use {@link #toString(String)} instead\n     */\n    @Override\n    @Deprecated\n    public String toString()\n    {\n        // make explicit the use of the default charset\n        return new String( toByteArray(), Charset.defaultCharset() );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param enc the name of the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @throws java.io.UnsupportedEncodingException if the encoding is not supported\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     */\n    public String toString( final String enc ) throws UnsupportedEncodingException\n    {\n        return new String( toByteArray(), enc );\n    }\n\n    /**\n     * Gets the curent contents of this byte stream as a string\n     * using the specified encoding.\n     *\n     * @param charset the character encoding\n     *\n     * @return the string converted from the byte array\n     *\n     * @see java.io.ByteArrayOutputStream#toString(String)\n     * @since 2.5\n     */\n    public String toString( final Charset charset )\n    {\n        return new String( toByteArray(), charset );\n    }\n\n}\n",
    "project": "plexus-archiver",
    "libraryName": "commons-io",
    "libraryGroupID": "commons-io",
    "newVersion": "20030203.000550",
    "previousVersion": "2.11.0",
    "breakingCommit": "ee0827d4c9bf80982241e8c3559dceb8b39063e4"
}