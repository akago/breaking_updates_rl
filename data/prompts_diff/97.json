{
    "absolute_path_to_file_in_container": "/billy/billy-gin/src/main/java/com/premiumminds/billy/gin/services/impl/pdf/FOPPDFTransformer.java",
    "errors": [
        {
            "line_number": 115,
            "message": "[ERROR] /billy/billy-gin/src/main/java/com/premiumminds/billy/gin/services/impl/pdf/FOPPDFTransformer.java:[115,43] no suitable method found for newInstance(no arguments)",
            "additional_info": "    method org.apache.fop.apps.FopFactory.newInstance(org.apache.fop.apps.FopFactoryConfig) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.io.File) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI,java.io.InputStream) is not applicable\n      (actual and formal argument lists differ in length)",
            "file_name": "FOPPDFTransformer.java",
            "BCs": [
                {
                    "element": "org.apache.fop.apps.FopFactory",
                    "nature": "MUTATION",
                    "kind": "CLASS_NOW_ABSTRACT"
                },
                {
                    "element": "org.apache.fop.pdf.PDFEncryptionManager.newInstance",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.apache.fop.apps.FopFactory.newInstance",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                },
                {
                    "element": "org.apache.fop.apps.FopFactory",
                    "nature": "MUTATION",
                    "kind": "CLASS_NOW_FINAL"
                }
            ],
            "Additions": [],
            "uid": "f1c39799-0481-5643-a5d6-fdbacac88faf"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Copyright (C) 2017 Premium Minds.\n *\n * This file is part of billy GIN.\n *\n * billy GIN is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n *\n * billy GIN is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with billy GIN. If not, see <http://www.gnu.org/licenses/>.\n */\npackage com.premiumminds.billy.gin.services.impl.pdf;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.EncodeHintType;\nimport com.google.zxing.WriterException;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.qrcode.QRCodeWriter;\nimport com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;\nimport com.premiumminds.billy.gin.services.exceptions.ExportServiceException;\nimport com.premiumminds.billy.gin.services.export.ParamsTree;\nimport com.premiumminds.billy.gin.services.export.ParamsTree.Node;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.EnumMap;\nimport java.util.Optional;\nimport java.util.UUID;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.sax.SAXResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.fop.apps.FOPException;\nimport org.apache.fop.apps.FOUserAgent;\nimport org.apache.fop.apps.Fop;\nimport org.apache.fop.apps.FopFactory;\nimport org.apache.xmlgraphics.util.MimeConstants;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic abstract class FOPPDFTransformer {\n\n    private static final Logger log = LoggerFactory.getLogger(FOPPDFTransformer.class);\n    private static final String QR_CODE_PATH = \"qrCodePath\";\n    private static final String QR_CODE = \"qrCode\";\n\n    private final TransformerFactory transformerFactory;\n\n    public FOPPDFTransformer(TransformerFactory transformerFactory) {\n        this.transformerFactory = transformerFactory;\n    }\n\n    public FOPPDFTransformer() {\n        this(TransformerFactory.newInstance());\n    }\n\n    private Source mapParamsToSource(ParamsTree<String, String> documentParams) {\n        return new StreamSource(new StringReader(this.generateXML(documentParams)));\n    }\n\n    private String generateXML(ParamsTree<String, String> tree) {\n        StringBuilder strBuilder = new StringBuilder();\n        strBuilder.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n\n        this.writeXML(strBuilder, tree.getRoot());\n\n        return strBuilder.toString();\n    }\n\n    private void writeXML(StringBuilder strBuilder, Node<String, String> node) {\n        strBuilder.append(\"<\").append(node.getKey());\n        if (null == node.getValue() && !node.hasChildren()) {\n            strBuilder.append(\"/>\");\n        } else {\n            strBuilder.append(\"> \");\n            if (null != node.getValue()) {\n                strBuilder.append(StringEscapeUtils.escapeXml(node.getValue()));\n            }\n\n            for (Node<String, String> child : node.getChildren()) {\n                this.writeXML(strBuilder, child);\n            }\n            strBuilder.append(\"</\").append(node.getKey()).append(\">\");\n        }\n    }\n\n    protected void transformToStream(InputStream templateStream, ParamsTree<String, String> documentParams,\n            OutputStream outStream) throws ExportServiceException {\n\n        // creation of transform source\n        StreamSource transformSource = new StreamSource(templateStream);\n\n        // create an instance of fop factory\n        FopFactory fopFactory = FopFactory.newInstance();\n        // a user agent is needed for transformation\n        FOUserAgent foUserAgent = fopFactory.newFOUserAgent();\n        // to store output\n\n        Optional<Node<String, String>> qrCodeString = documentParams\n            .getRoot()\n            .getChildren()\n            .stream()\n            .filter(stringStringNode -> stringStringNode.getKey().equals(QR_CODE))\n            .findAny();\n\n        Path qr = null;\n        try {\n            if(qrCodeString.isPresent() && !qrCodeString.get().getValue().isEmpty()){\n                qr = createQR(qrCodeString.get().getValue());\n                documentParams.getRoot().addChild(QR_CODE_PATH, qr.toString());\n            }\n            // the XML file from which we take the name\n            Source source = this.mapParamsToSource(documentParams);\n\n            Transformer xslfoTransformer = this.getTransformer(transformSource);\n\n            // Construct fop with desired output format\n            Fop fop = fopFactory.newFop(MimeConstants.MIME_PDF, foUserAgent, outStream);\n\n            // Resulting SAX events (the generated FO)\n            // must be piped through to FOP\n            Result res = new SAXResult(fop.getDefaultHandler());\n\n            // Start XSLT transformation and FOP processing\n            // everything will happen here..\n            xslfoTransformer.transform(source, res);\n        } catch (FOPException e) {\n            throw new ExportServiceException(\"Error using FOP to open the template\", e);\n        } catch (TransformerException e) {\n            throw new ExportServiceException(\"Error generating pdf from template and data source\", e);\n        } catch (IOException | WriterException e) {\n            throw new ExportServiceException(\"Error generating qrCode\", e);\n        } finally {\n            deleteTempFileIfExists(qr);\n        }\n    }\n\n    public File toFile(URI fileURI, InputStream templateStream, ParamsTree<String, String> documentParams)\n            throws ExportServiceException {\n        // if you want to save PDF file use the following code\n        File pdffile = new File(fileURI);\n        try (OutputStream out = new java.io.BufferedOutputStream(new FileOutputStream(pdffile))) {\n            this.transformToStream(templateStream, documentParams, out);\n            return pdffile;\n        } catch (FileNotFoundException e) {\n            throw new ExportServiceException(\"Could not create pdf file\", e);\n        } catch (IOException e) {\n            throw new ExportServiceException(\"IO error while saving the pdf file\", e);\n        }\n    }\n\n    private Transformer getTransformer(StreamSource streamSource) throws TransformerConfigurationException {\n        return this.transformerFactory.newTransformer(streamSource);\n    }\n\n    private Path createQR(String data)\n        throws WriterException, IOException\n    {\n        QRCodeWriter qrCodeWriter = new QRCodeWriter();\n        EnumMap<EncodeHintType, String> hints = new EnumMap<> (EncodeHintType.class);\n        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M.name());\n        hints.put(EncodeHintType.MARGIN, String.valueOf(4));\n        hints.put(EncodeHintType.QR_VERSION, String.valueOf(9));\n        BitMatrix bitMatrix = qrCodeWriter.encode(\n            new String(data.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8),\n            BarcodeFormat.QR_CODE,\n            350, 350,hints);\n\n        final Path file = Files.createTempFile(UUID.randomUUID().toString().replace(\"-\", \"\"), \".png\");\n        MatrixToImageWriter.writeToPath(\n            bitMatrix,\n            \"png\",\n            file);\n\n        return file;\n    }\n\n    private void deleteTempFileIfExists(Path path) {\n        if(path != null) {\n            try {\n                Files.deleteIfExists(path);\n            } catch (IOException e) {\n                log.error(\"Could not delete file {}\", path, e);\n            }\n        }\n    }\n\n}\n\n'''\nThe error is caused by a change in the API of the dependency: fop 1.0->2.2. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n~~ CLASS_NOW_ABSTRACT <- org.apache.fop.apps.FopFactory\n-- org.apache.fop.pdf.PDFEncryptionManager.newInstance\n-- org.apache.fop.apps.FopFactory.newInstance\n~~ CLASS_NOW_FINAL <- org.apache.fop.apps.FopFactory\n\nThe error is triggered in the following specific lines in the previous code:\n        FopFactory fopFactory = FopFactory.newInstance();\nwith the following error message:\n[ERROR] /billy/billy-gin/src/main/java/com/premiumminds/billy/gin/services/impl/pdf/FOPPDFTransformer.java:[115,43] no suitable method found for newInstance(no arguments)    method org.apache.fop.apps.FopFactory.newInstance(org.apache.fop.apps.FopFactoryConfig) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.io.File) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI,java.io.InputStream) is not applicable\n      (actual and formal argument lists differ in length)\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "        FopFactory fopFactory = FopFactory.newInstance();",
    "error_message": "[ERROR] /billy/billy-gin/src/main/java/com/premiumminds/billy/gin/services/impl/pdf/FOPPDFTransformer.java:[115,43] no suitable method found for newInstance(no arguments)    method org.apache.fop.apps.FopFactory.newInstance(org.apache.fop.apps.FopFactoryConfig) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.io.File) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI) is not applicable\n      (actual and formal argument lists differ in length)\n    method org.apache.fop.apps.FopFactory.newInstance(java.net.URI,java.io.InputStream) is not applicable\n      (actual and formal argument lists differ in length)",
    "api_diff": "~~ CLASS_NOW_ABSTRACT <- org.apache.fop.apps.FopFactory\n-- org.apache.fop.pdf.PDFEncryptionManager.newInstance\n-- org.apache.fop.apps.FopFactory.newInstance\n~~ CLASS_NOW_FINAL <- org.apache.fop.apps.FopFactory",
    "original_code": "/*\n * Copyright (C) 2017 Premium Minds.\n *\n * This file is part of billy GIN.\n *\n * billy GIN is free software: you can redistribute it and/or modify it under\n * the terms of the GNU Lesser General Public License as published by the Free\n * Software Foundation, either version 3 of the License, or (at your option) any\n * later version.\n *\n * billy GIN is distributed in the hope that it will be useful, but WITHOUT ANY\n * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n * A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more\n * details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with billy GIN. If not, see <http://www.gnu.org/licenses/>.\n */\npackage com.premiumminds.billy.gin.services.impl.pdf;\n\nimport com.google.zxing.BarcodeFormat;\nimport com.google.zxing.EncodeHintType;\nimport com.google.zxing.WriterException;\nimport com.google.zxing.client.j2se.MatrixToImageWriter;\nimport com.google.zxing.common.BitMatrix;\nimport com.google.zxing.qrcode.QRCodeWriter;\nimport com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;\nimport com.premiumminds.billy.gin.services.exceptions.ExportServiceException;\nimport com.premiumminds.billy.gin.services.export.ParamsTree;\nimport com.premiumminds.billy.gin.services.export.ParamsTree.Node;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.StringReader;\nimport java.net.URI;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.EnumMap;\nimport java.util.Optional;\nimport java.util.UUID;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.sax.SAXResult;\nimport javax.xml.transform.stream.StreamSource;\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.fop.apps.FOPException;\nimport org.apache.fop.apps.FOUserAgent;\nimport org.apache.fop.apps.Fop;\nimport org.apache.fop.apps.FopFactory;\nimport org.apache.xmlgraphics.util.MimeConstants;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic abstract class FOPPDFTransformer {\n\n    private static final Logger log = LoggerFactory.getLogger(FOPPDFTransformer.class);\n    private static final String QR_CODE_PATH = \"qrCodePath\";\n    private static final String QR_CODE = \"qrCode\";\n\n    private final TransformerFactory transformerFactory;\n\n    public FOPPDFTransformer(TransformerFactory transformerFactory) {\n        this.transformerFactory = transformerFactory;\n    }\n\n    public FOPPDFTransformer() {\n        this(TransformerFactory.newInstance());\n    }\n\n    private Source mapParamsToSource(ParamsTree<String, String> documentParams) {\n        return new StreamSource(new StringReader(this.generateXML(documentParams)));\n    }\n\n    private String generateXML(ParamsTree<String, String> tree) {\n        StringBuilder strBuilder = new StringBuilder();\n        strBuilder.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?>\\n\");\n\n        this.writeXML(strBuilder, tree.getRoot());\n\n        return strBuilder.toString();\n    }\n\n    private void writeXML(StringBuilder strBuilder, Node<String, String> node) {\n        strBuilder.append(\"<\").append(node.getKey());\n        if (null == node.getValue() && !node.hasChildren()) {\n            strBuilder.append(\"/>\");\n        } else {\n            strBuilder.append(\"> \");\n            if (null != node.getValue()) {\n                strBuilder.append(StringEscapeUtils.escapeXml(node.getValue()));\n            }\n\n            for (Node<String, String> child : node.getChildren()) {\n                this.writeXML(strBuilder, child);\n            }\n            strBuilder.append(\"</\").append(node.getKey()).append(\">\");\n        }\n    }\n\n    protected void transformToStream(InputStream templateStream, ParamsTree<String, String> documentParams,\n            OutputStream outStream) throws ExportServiceException {\n\n        // creation of transform source\n        StreamSource transformSource = new StreamSource(templateStream);\n\n        // create an instance of fop factory\n        FopFactory fopFactory = FopFactory.newInstance();\n        // a user agent is needed for transformation\n        FOUserAgent foUserAgent = fopFactory.newFOUserAgent();\n        // to store output\n\n        Optional<Node<String, String>> qrCodeString = documentParams\n            .getRoot()\n            .getChildren()\n            .stream()\n            .filter(stringStringNode -> stringStringNode.getKey().equals(QR_CODE))\n            .findAny();\n\n        Path qr = null;\n        try {\n            if(qrCodeString.isPresent() && !qrCodeString.get().getValue().isEmpty()){\n                qr = createQR(qrCodeString.get().getValue());\n                documentParams.getRoot().addChild(QR_CODE_PATH, qr.toString());\n            }\n            // the XML file from which we take the name\n            Source source = this.mapParamsToSource(documentParams);\n\n            Transformer xslfoTransformer = this.getTransformer(transformSource);\n\n            // Construct fop with desired output format\n            Fop fop = fopFactory.newFop(MimeConstants.MIME_PDF, foUserAgent, outStream);\n\n            // Resulting SAX events (the generated FO)\n            // must be piped through to FOP\n            Result res = new SAXResult(fop.getDefaultHandler());\n\n            // Start XSLT transformation and FOP processing\n            // everything will happen here..\n            xslfoTransformer.transform(source, res);\n        } catch (FOPException e) {\n            throw new ExportServiceException(\"Error using FOP to open the template\", e);\n        } catch (TransformerException e) {\n            throw new ExportServiceException(\"Error generating pdf from template and data source\", e);\n        } catch (IOException | WriterException e) {\n            throw new ExportServiceException(\"Error generating qrCode\", e);\n        } finally {\n            deleteTempFileIfExists(qr);\n        }\n    }\n\n    public File toFile(URI fileURI, InputStream templateStream, ParamsTree<String, String> documentParams)\n            throws ExportServiceException {\n        // if you want to save PDF file use the following code\n        File pdffile = new File(fileURI);\n        try (OutputStream out = new java.io.BufferedOutputStream(new FileOutputStream(pdffile))) {\n            this.transformToStream(templateStream, documentParams, out);\n            return pdffile;\n        } catch (FileNotFoundException e) {\n            throw new ExportServiceException(\"Could not create pdf file\", e);\n        } catch (IOException e) {\n            throw new ExportServiceException(\"IO error while saving the pdf file\", e);\n        }\n    }\n\n    private Transformer getTransformer(StreamSource streamSource) throws TransformerConfigurationException {\n        return this.transformerFactory.newTransformer(streamSource);\n    }\n\n    private Path createQR(String data)\n        throws WriterException, IOException\n    {\n        QRCodeWriter qrCodeWriter = new QRCodeWriter();\n        EnumMap<EncodeHintType, String> hints = new EnumMap<> (EncodeHintType.class);\n        hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M.name());\n        hints.put(EncodeHintType.MARGIN, String.valueOf(4));\n        hints.put(EncodeHintType.QR_VERSION, String.valueOf(9));\n        BitMatrix bitMatrix = qrCodeWriter.encode(\n            new String(data.getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8),\n            BarcodeFormat.QR_CODE,\n            350, 350,hints);\n\n        final Path file = Files.createTempFile(UUID.randomUUID().toString().replace(\"-\", \"\"), \".png\");\n        MatrixToImageWriter.writeToPath(\n            bitMatrix,\n            \"png\",\n            file);\n\n        return file;\n    }\n\n    private void deleteTempFileIfExists(Path path) {\n        if(path != null) {\n            try {\n                Files.deleteIfExists(path);\n            } catch (IOException e) {\n                log.error(\"Could not delete file {}\", path, e);\n            }\n        }\n    }\n\n}\n",
    "project": "billy",
    "libraryName": "fop",
    "libraryGroupID": "org.apache.xmlgraphics",
    "newVersion": "2.2",
    "previousVersion": "1.0",
    "breakingCommit": "36859167815292f279e570d39dd2ddbcf1622dc6"
}