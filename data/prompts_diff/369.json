{
    "absolute_path_to_file_in_container": "/rxjava2-extras/src/main/java/com/github/davidmoten/rx2/flowable/Serialized.java",
    "errors": [
        {
            "line_number": 298,
            "message": "[ERROR] /rxjava2-extras/src/main/java/com/github/davidmoten/rx2/flowable/Serialized.java:[298,30] cannot find symbol",
            "additional_info": "  symbol:   method eof()\n  location: variable input of type com.esotericsoftware.kryo.io.Input",
            "file_name": "Serialized.java",
            "BCs": [
                {
                    "element": "com.esotericsoftware.kryo.io.Input.eof",
                    "nature": "DELETION",
                    "kind": "METHOD_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "6100c29b-9b32-5e44-8eea-13d40bee74b8"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\npackage com.github.davidmoten.rx2.flowable;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.concurrent.Callable;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.github.davidmoten.rx2.Consumers;\n\nimport io.reactivex.Emitter;\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Consumer;\nimport io.reactivex.functions.Function;\n\n/**\n * Utility class for writing {@link Flowable} streams to\n * {@link ObjectOutputStream}s and reading {@link Flowable} streams of\n * indeterminate size from {@link ObjectInputStream}s.\n */\npublic final class Serialized {\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    private Serialized() {\n        // prevent instantiation\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link InputStream} as a\n     * {@link Flowable} stream.\n     * \n     * @param ois\n     *            the {@link ObjectInputStream}\n     * @param <T>\n     *            the generic type of the returned stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as an {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final ObjectInputStream ois) {\n        return Flowable.generate(new Consumer<Emitter<T>>() {\n            @Override\n            public void accept(Emitter<T> emitter) throws Exception {\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    T t = (T) ois.readObject();\n                    emitter.onNext(t);\n                } catch (EOFException e) {\n                    emitter.onComplete();\n                } catch (ClassNotFoundException e) {\n                    emitter.onError(e);\n                } catch (IOException e) {\n                    emitter.onError(e);\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link File} as a\n     * {@link Flowable} stream. Uses buffer of size <code>bufferSize</code>\n     * buffer reads from the File.\n     * \n     * @param file\n     *            the input file\n     * @param bufferSize\n     *            the buffer size for reading bytes from the file.\n     * @param <T>\n     *            the generic type of the deserialized objects returned in the\n     *            stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as a {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final File file, final int bufferSize) {\n        Callable<ObjectInputStream> resourceFactory = new Callable<ObjectInputStream>() {\n            @Override\n            public ObjectInputStream call() throws IOException {\n                return new ObjectInputStream(new BufferedInputStream(new FileInputStream(file), bufferSize));\n            }\n        };\n        @SuppressWarnings(\"unchecked\")\n        Function<ObjectInputStream, Flowable<T>> flowableFactory = (Function<ObjectInputStream, Flowable<T>>) (Function<?, ?>) ObjectInputStreamFlowableFactoryHolder.INSTANCE;\n        Consumer<ObjectInputStream> disposeAction = Consumers.close();\n        return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n    }\n\n    // singleton instance using Holder pattern\n    private static final class ObjectInputStreamFlowableFactoryHolder {\n        static final Function<ObjectInputStream, Flowable<Serializable>> INSTANCE = new Function<ObjectInputStream, Flowable<Serializable>>() {\n\n            @Override\n            public Flowable<Serializable> apply(ObjectInputStream is) throws Exception {\n                return read(is);\n            }\n\n        };\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link File} as a\n     * {@link Flowable} stream. A buffer size of 8192 bytes is used by default.\n     * \n     * @param file\n     *            the input file containing serialized java objects\n     * @param <T>\n     *            the generic type of the deserialized objects returned in the\n     *            stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as an {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final File file) {\n        return read(file, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a duplicate of the input stream but with the side effect that\n     * emissions from the source are written to the {@link ObjectOutputStream}.\n     * \n     * @param source\n     *            the source of objects to write\n     * @param oos\n     *            the output stream to write to\n     * @param <T>\n     *            the generic type of the objects being serialized\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(Flowable<T> source, final ObjectOutputStream oos) {\n        return source.doOnNext(new Consumer<T>() {\n\n            @Override\n            public void accept(T t) throws IOException {\n                oos.writeObject(t);\n            }\n        });\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the given buffer size.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param append\n     *            if true writes are appended to file otherwise overwrite the\n     *            file\n     * @param bufferSize\n     *            the buffer size in bytes to use.\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file,\n            final boolean append, final int bufferSize) {\n        Callable<ObjectOutputStream> resourceFactory = new Callable<ObjectOutputStream>() {\n            @Override\n            public ObjectOutputStream call() throws IOException {\n                return new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file, append), bufferSize));\n            }\n        };\n        Function<ObjectOutputStream, Flowable<T>> flowableFactory = new Function<ObjectOutputStream, Flowable<T>>() {\n\n            @Override\n            public Flowable<T> apply(ObjectOutputStream oos) {\n                return write(source, oos);\n            }\n        };\n        Consumer<ObjectOutputStream> disposeAction = Consumers.close();\n        return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the a buffer size of 8192 bytes.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param append\n     *            if true writes are appended to file otherwise overwrite the\n     *            file\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file,\n            final boolean append) {\n        return write(source, file, append, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the a buffer size of 8192 bytes.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file) {\n        return write(source, file, false, DEFAULT_BUFFER_SIZE);\n    }\n\n    public static KryoBuilder kryo() {\n        return kryo(new Kryo());\n    }\n\n    public static KryoBuilder kryo(Kryo kryo) {\n        return new KryoBuilder(kryo);\n    }\n\n    public static class KryoBuilder {\n\n        private static final int DEFAULT_BUFFER_SIZE = 4096;\n\n        private final Kryo kryo;\n\n        private KryoBuilder(Kryo kryo) {\n            this.kryo = kryo;\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file) {\n            return write(source, file, false, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file, boolean append) {\n            return write(source, file, append, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file, final boolean append,\n                final int bufferSize) {\n            Callable<Output> resourceFactory = new Callable<Output>() {\n                @Override\n                public Output call() throws FileNotFoundException {\n                    return new Output(new FileOutputStream(file, append), bufferSize);\n                }\n            };\n            Function<Output, Flowable<T>> flowableFactory = new Function<Output, Flowable<T>>() {\n\n                @Override\n                public Flowable<T> apply(final Output output) {\n                    return source.doOnNext(new Consumer<T>() {\n                        @Override\n                        public void accept(T t) {\n                            kryo.writeObject(output, t);\n                        }\n                    });\n                }\n            };\n            Consumer<Output> disposeAction = Consumers.close();\n            return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n        }\n\n        public <T> Flowable<T> read(Class<T> cls, final File file) {\n            return read(cls, file, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> read(final Class<T> cls, final File file, final int bufferSize) {\n            Callable<Input> resourceFactory = new Callable<Input>() {\n                @Override\n                public Input call() throws FileNotFoundException {\n                    return new Input(new FileInputStream(file), bufferSize);\n                }\n            };\n            Function<Input, Flowable<T>> flowableFactory = new Function<Input, Flowable<T>>() {\n\n                @Override\n                public Flowable<T> apply(final Input input) {\n                    return read(cls, input);\n                }\n            };\n            Consumer<Input> disposeAction = Consumers.close();\n            return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n        }\n\n        public <T> Flowable<T> read(final Class<T> cls, final Input input) {\n\n            return Flowable.generate(new Consumer<Emitter<T>>() {\n\n                @Override\n                public void accept(Emitter<T> emitter) throws Exception {\n                    if (input.eof()) {\n                        emitter.onComplete();\n                    } else {\n                        T t = kryo.readObject(input, cls);\n                        emitter.onNext(t);\n                    }\n                }\n\n            });\n        }\n    }\n\n}\n\n'''\nThe error is caused by a change in the API of the dependency: kryo 4.0.3->5.0.0. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- com.esotericsoftware.kryo.io.Input.eof\n\nThe error is triggered in the following specific lines in the previous code:\n                    if (input.eof()) {\nwith the following error message:\n[ERROR] /rxjava2-extras/src/main/java/com/github/davidmoten/rx2/flowable/Serialized.java:[298,30] cannot find symbol  symbol:   method eof()\n  location: variable input of type com.esotericsoftware.kryo.io.Input\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "                    if (input.eof()) {",
    "error_message": "[ERROR] /rxjava2-extras/src/main/java/com/github/davidmoten/rx2/flowable/Serialized.java:[298,30] cannot find symbol  symbol:   method eof()\n  location: variable input of type com.esotericsoftware.kryo.io.Input",
    "api_diff": "-- com.esotericsoftware.kryo.io.Input.eof",
    "original_code": "package com.github.davidmoten.rx2.flowable;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.concurrent.Callable;\n\nimport com.esotericsoftware.kryo.Kryo;\nimport com.esotericsoftware.kryo.io.Input;\nimport com.esotericsoftware.kryo.io.Output;\nimport com.github.davidmoten.rx2.Consumers;\n\nimport io.reactivex.Emitter;\nimport io.reactivex.Flowable;\nimport io.reactivex.functions.Consumer;\nimport io.reactivex.functions.Function;\n\n/**\n * Utility class for writing {@link Flowable} streams to\n * {@link ObjectOutputStream}s and reading {@link Flowable} streams of\n * indeterminate size from {@link ObjectInputStream}s.\n */\npublic final class Serialized {\n\n    private static final int DEFAULT_BUFFER_SIZE = 8192;\n\n    private Serialized() {\n        // prevent instantiation\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link InputStream} as a\n     * {@link Flowable} stream.\n     * \n     * @param ois\n     *            the {@link ObjectInputStream}\n     * @param <T>\n     *            the generic type of the returned stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as an {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final ObjectInputStream ois) {\n        return Flowable.generate(new Consumer<Emitter<T>>() {\n            @Override\n            public void accept(Emitter<T> emitter) throws Exception {\n                try {\n                    @SuppressWarnings(\"unchecked\")\n                    T t = (T) ois.readObject();\n                    emitter.onNext(t);\n                } catch (EOFException e) {\n                    emitter.onComplete();\n                } catch (ClassNotFoundException e) {\n                    emitter.onError(e);\n                } catch (IOException e) {\n                    emitter.onError(e);\n                }\n            }\n        });\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link File} as a\n     * {@link Flowable} stream. Uses buffer of size <code>bufferSize</code>\n     * buffer reads from the File.\n     * \n     * @param file\n     *            the input file\n     * @param bufferSize\n     *            the buffer size for reading bytes from the file.\n     * @param <T>\n     *            the generic type of the deserialized objects returned in the\n     *            stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as a {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final File file, final int bufferSize) {\n        Callable<ObjectInputStream> resourceFactory = new Callable<ObjectInputStream>() {\n            @Override\n            public ObjectInputStream call() throws IOException {\n                return new ObjectInputStream(new BufferedInputStream(new FileInputStream(file), bufferSize));\n            }\n        };\n        @SuppressWarnings(\"unchecked\")\n        Function<ObjectInputStream, Flowable<T>> flowableFactory = (Function<ObjectInputStream, Flowable<T>>) (Function<?, ?>) ObjectInputStreamFlowableFactoryHolder.INSTANCE;\n        Consumer<ObjectInputStream> disposeAction = Consumers.close();\n        return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n    }\n\n    // singleton instance using Holder pattern\n    private static final class ObjectInputStreamFlowableFactoryHolder {\n        static final Function<ObjectInputStream, Flowable<Serializable>> INSTANCE = new Function<ObjectInputStream, Flowable<Serializable>>() {\n\n            @Override\n            public Flowable<Serializable> apply(ObjectInputStream is) throws Exception {\n                return read(is);\n            }\n\n        };\n    }\n\n    /**\n     * Returns the deserialized objects from the given {@link File} as a\n     * {@link Flowable} stream. A buffer size of 8192 bytes is used by default.\n     * \n     * @param file\n     *            the input file containing serialized java objects\n     * @param <T>\n     *            the generic type of the deserialized objects returned in the\n     *            stream\n     * @return the stream of deserialized objects from the {@link InputStream}\n     *         as an {@link Flowable}.\n     */\n    public static <T extends Serializable> Flowable<T> read(final File file) {\n        return read(file, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Returns a duplicate of the input stream but with the side effect that\n     * emissions from the source are written to the {@link ObjectOutputStream}.\n     * \n     * @param source\n     *            the source of objects to write\n     * @param oos\n     *            the output stream to write to\n     * @param <T>\n     *            the generic type of the objects being serialized\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(Flowable<T> source, final ObjectOutputStream oos) {\n        return source.doOnNext(new Consumer<T>() {\n\n            @Override\n            public void accept(T t) throws IOException {\n                oos.writeObject(t);\n            }\n        });\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the given buffer size.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param append\n     *            if true writes are appended to file otherwise overwrite the\n     *            file\n     * @param bufferSize\n     *            the buffer size in bytes to use.\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file,\n            final boolean append, final int bufferSize) {\n        Callable<ObjectOutputStream> resourceFactory = new Callable<ObjectOutputStream>() {\n            @Override\n            public ObjectOutputStream call() throws IOException {\n                return new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(file, append), bufferSize));\n            }\n        };\n        Function<ObjectOutputStream, Flowable<T>> flowableFactory = new Function<ObjectOutputStream, Flowable<T>>() {\n\n            @Override\n            public Flowable<T> apply(ObjectOutputStream oos) {\n                return write(source, oos);\n            }\n        };\n        Consumer<ObjectOutputStream> disposeAction = Consumers.close();\n        return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the a buffer size of 8192 bytes.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param append\n     *            if true writes are appended to file otherwise overwrite the\n     *            file\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file,\n            final boolean append) {\n        return write(source, file, append, DEFAULT_BUFFER_SIZE);\n    }\n\n    /**\n     * Writes the source stream to the given file in given append mode and using\n     * the a buffer size of 8192 bytes.\n     * \n     * @param source\n     *            flowable stream to write\n     * @param file\n     *            file to write to\n     * @param <T>\n     *            the generic type of the input stream\n     * @return re-emits the input stream\n     */\n    public static <T extends Serializable> Flowable<T> write(final Flowable<T> source, final File file) {\n        return write(source, file, false, DEFAULT_BUFFER_SIZE);\n    }\n\n    public static KryoBuilder kryo() {\n        return kryo(new Kryo());\n    }\n\n    public static KryoBuilder kryo(Kryo kryo) {\n        return new KryoBuilder(kryo);\n    }\n\n    public static class KryoBuilder {\n\n        private static final int DEFAULT_BUFFER_SIZE = 4096;\n\n        private final Kryo kryo;\n\n        private KryoBuilder(Kryo kryo) {\n            this.kryo = kryo;\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file) {\n            return write(source, file, false, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file, boolean append) {\n            return write(source, file, append, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> write(final Flowable<T> source, final File file, final boolean append,\n                final int bufferSize) {\n            Callable<Output> resourceFactory = new Callable<Output>() {\n                @Override\n                public Output call() throws FileNotFoundException {\n                    return new Output(new FileOutputStream(file, append), bufferSize);\n                }\n            };\n            Function<Output, Flowable<T>> flowableFactory = new Function<Output, Flowable<T>>() {\n\n                @Override\n                public Flowable<T> apply(final Output output) {\n                    return source.doOnNext(new Consumer<T>() {\n                        @Override\n                        public void accept(T t) {\n                            kryo.writeObject(output, t);\n                        }\n                    });\n                }\n            };\n            Consumer<Output> disposeAction = Consumers.close();\n            return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n        }\n\n        public <T> Flowable<T> read(Class<T> cls, final File file) {\n            return read(cls, file, DEFAULT_BUFFER_SIZE);\n        }\n\n        public <T> Flowable<T> read(final Class<T> cls, final File file, final int bufferSize) {\n            Callable<Input> resourceFactory = new Callable<Input>() {\n                @Override\n                public Input call() throws FileNotFoundException {\n                    return new Input(new FileInputStream(file), bufferSize);\n                }\n            };\n            Function<Input, Flowable<T>> flowableFactory = new Function<Input, Flowable<T>>() {\n\n                @Override\n                public Flowable<T> apply(final Input input) {\n                    return read(cls, input);\n                }\n            };\n            Consumer<Input> disposeAction = Consumers.close();\n            return Flowable.using(resourceFactory, flowableFactory, disposeAction, true);\n        }\n\n        public <T> Flowable<T> read(final Class<T> cls, final Input input) {\n\n            return Flowable.generate(new Consumer<Emitter<T>>() {\n\n                @Override\n                public void accept(Emitter<T> emitter) throws Exception {\n                    if (input.eof()) {\n                        emitter.onComplete();\n                    } else {\n                        T t = kryo.readObject(input, cls);\n                        emitter.onNext(t);\n                    }\n                }\n\n            });\n        }\n    }\n\n}\n",
    "project": "rxjava2-extras",
    "libraryName": "kryo",
    "libraryGroupID": "com.esotericsoftware",
    "newVersion": "5.0.0",
    "previousVersion": "4.0.3",
    "breakingCommit": "1c060c19a702b81e4d65f433dcce848e2d499367"
}