{
    "absolute_path_to_file_in_container": "/docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java",
    "errors": [
        {
            "line_number": 350,
            "message": "[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[350,63] incompatible types: bad return type in lambda expression",
            "additional_info": "    inference variable U has incompatible bounds\n      equality constraints: java.util.Optional<com.artipie.http.auth.AuthUser>\n      lower bounds: java.util.Optional<java.lang.Object>",
            "file_name": "AuthTest.java",
            "BCs": [],
            "Additions": [],
            "uid": "0421e64d-315a-589a-bb79-459136140281"
        },
        {
            "line_number": 353,
            "message": "[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[353,60] cannot find symbol",
            "additional_info": "  symbol:   class User\n  location: interface com.artipie.http.auth.Authentication",
            "file_name": "AuthTest.java",
            "BCs": [],
            "Additions": [],
            "uid": "c9d0fb81-42c4-5fc2-9ac6-e30172209e99"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * The MIT License (MIT) Copyright (c) 2020-2023 artipie.com\n * https://github.com/artipie/docker-adapter/LICENSE.txt\n */\npackage com.artipie.docker.http;\n\nimport com.artipie.asto.Content;\nimport com.artipie.asto.memory.InMemoryStorage;\nimport com.artipie.docker.Blob;\nimport com.artipie.docker.Docker;\nimport com.artipie.docker.RepoName;\nimport com.artipie.docker.asto.AstoDocker;\nimport com.artipie.docker.asto.TrustedBlobSource;\nimport com.artipie.http.Headers;\nimport com.artipie.http.Response;\nimport com.artipie.http.Slice;\nimport com.artipie.http.auth.Authentication;\nimport com.artipie.http.auth.BasicAuthScheme;\nimport com.artipie.http.auth.BearerAuthScheme;\nimport com.artipie.http.auth.Permissions;\nimport com.artipie.http.headers.Authorization;\nimport com.artipie.http.headers.Header;\nimport com.artipie.http.hm.ResponseMatcher;\nimport com.artipie.http.hm.RsHasStatus;\nimport com.artipie.http.rq.RequestLine;\nimport com.artipie.http.rq.RqMethod;\nimport com.artipie.http.rs.RsStatus;\nimport io.reactivex.Flowable;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.stream.Stream;\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.IsNot;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link DockerSlice}.\n * Authentication & authorization tests.\n *\n * @since 0.8\n * @checkstyle ClassDataAbstractionCouplingCheck (500 lines)\n * @todo #434:30min test `shouldReturnForbiddenWhenUserHasNoRequiredPermissionOnSecondManifestPut`\n *  fails in github actions, locally it works fine. Figure out what is the problem and fix it.\n */\n@SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\npublic final class AuthTest {\n\n    /**\n     * Docker used in tests.\n     */\n    private Docker docker;\n\n    @BeforeEach\n    void setUp() {\n        this.docker = new AstoDocker(new InMemoryStorage());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnUnauthorizedWhenNoAuth(final Method method, final RequestLine line) {\n        MatcherAssert.assertThat(\n            method.slice(\"whatever\").response(line.toString(), Headers.EMPTY, Content.EMPTY),\n            new IsUnauthorizedResponse()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnUnauthorizedWhenUserIsUnknown(final Method method, final RequestLine line) {\n        MatcherAssert.assertThat(\n            method.slice(\"whatever\").response(\n                line.toString(),\n                method.headers(new TestAuthentication.User(\"chuck\", \"letmein\")),\n                Content.EMPTY\n            ),\n            new IsUnauthorizedResponse()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnForbiddenWhenUserHasNoRequiredPermissions(\n        final Method method,\n        final RequestLine line,\n        final String action\n    ) {\n        MatcherAssert.assertThat(\n            method.slice(action).response(\n                line.toString(),\n                method.headers(TestAuthentication.BOB),\n                Content.EMPTY\n            ),\n            new IsDeniedResponse()\n        );\n    }\n\n    @Test\n    @Disabled\n    void shouldReturnForbiddenWhenUserHasNoRequiredPermissionOnSecondManifestPut() {\n        final Basic basic = new Basic(this.docker);\n        final String line = new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\")\n            .toString();\n        final String action = \"repository:my-alpine:push\";\n        basic.slice(action).response(\n            line,\n            basic.headers(TestAuthentication.ALICE),\n            this.manifest()\n        );\n        MatcherAssert.assertThat(\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                Content.EMPTY\n            ),\n            new RsHasStatus(RsStatus.FORBIDDEN)\n        );\n    }\n\n    @Test\n    void shouldOverwriteManifestIfAllowed() {\n        final Basic basic = new Basic(this.docker);\n        final String path = \"/v2/my-alpine/manifests/abc\";\n        final String line = new RequestLine(RqMethod.PUT, path).toString();\n        final String action = \"repository:my-alpine:overwrite\";\n        final Flowable<ByteBuffer> manifest = this.manifest();\n        MatcherAssert.assertThat(\n            \"Manifest was created for the first time\",\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                manifest\n            ),\n            new ResponseMatcher(\n                RsStatus.CREATED,\n                new Header(\"Location\", path),\n                new Header(\"Content-Length\", \"0\"),\n                new Header(\n                    \"Docker-Content-Digest\",\n                    \"sha256:ef0ff2adcc3c944a63f7cafb386abc9a1d95528966085685ae9fab2a1c0bedbf\"\n                )\n            )\n        );\n        MatcherAssert.assertThat(\n            \"Manifest was overwritten\",\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                manifest\n            ),\n            new ResponseMatcher(\n                RsStatus.CREATED,\n                new Header(\"Location\", path),\n                new Header(\"Content-Length\", \"0\"),\n                new Header(\n                    \"Docker-Content-Digest\",\n                    \"sha256:ef0ff2adcc3c944a63f7cafb386abc9a1d95528966085685ae9fab2a1c0bedbf\"\n                )\n            )\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldNotReturnUnauthorizedOrForbiddenWhenUserHasPermissions(\n        final Method method,\n        final RequestLine line,\n        final String action\n    ) {\n        final Response response = method.slice(action).response(\n            line.toString(),\n            method.headers(TestAuthentication.ALICE),\n            Content.EMPTY\n        );\n        MatcherAssert.assertThat(\n            response,\n            new AllOf<>(\n                Arrays.asList(\n                    new IsNot<>(new RsHasStatus(RsStatus.FORBIDDEN)),\n                    new IsNot<>(new RsHasStatus(RsStatus.UNAUTHORIZED))\n                )\n            )\n        );\n    }\n\n    @SuppressWarnings(\"PMD.UnusedPrivateMethod\")\n    private static Stream<Arguments> setups() {\n        return Stream.of(new Basic(), new Bearer()).flatMap(AuthTest::setups);\n    }\n\n    /**\n     * Create manifest content.\n     *\n     * @return Manifest content.\n     */\n    private Flowable<ByteBuffer> manifest() {\n        final byte[] content = \"config\".getBytes();\n        final Blob config = this.docker.repo(new RepoName.Valid(\"my-alpine\")).layers()\n            .put(new TrustedBlobSource(content))\n            .toCompletableFuture().join();\n        final byte[] data = String.format(\n            \"{\\\"config\\\":{\\\"digest\\\":\\\"%s\\\"},\\\"layers\\\":[],\\\"mediaType\\\":\\\"my-type\\\"}\",\n            config.digest().string()\n        ).getBytes();\n        return Flowable.just(ByteBuffer.wrap(data));\n    }\n\n    private static Stream<Arguments> setups(final Method method) {\n        return Stream.of(\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/\"),\n                \"registry:base:*\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.HEAD, \"/v2/my-alpine/manifests/1\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/manifests/2\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\"),\n                \"repository:my-alpine:overwrite\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/tags/list\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.HEAD, \"/v2/my-alpine/blobs/sha256:123\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/blobs/sha256:012345\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.POST, \"/v2/my-alpine/blobs/uploads/\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PATCH, \"/v2/my-alpine/blobs/uploads/123\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/blobs/uploads/12345\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/blobs/uploads/112233\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/_catalog\"),\n                \"registry:catalog:*\"\n            )\n        );\n    }\n\n    /**\n     * Authentication method.\n     *\n     * @since 0.8\n     */\n    private interface Method {\n\n        Slice slice(String action);\n\n        Headers headers(TestAuthentication.User user);\n\n    }\n\n    /**\n     * Basic authentication method.\n     *\n     * @since 0.8\n     */\n    private static final class Basic implements Method {\n\n        /**\n         * Docker repo.\n         */\n        private final Docker docker;\n\n        private Basic(final Docker docker) {\n            this.docker = docker;\n        }\n\n        private Basic() {\n            this(new AstoDocker(new InMemoryStorage()));\n        }\n\n        @Override\n        public Slice slice(final String action) {\n            return new DockerSlice(\n                this.docker,\n                new Permissions.Single(TestAuthentication.ALICE.name(), action),\n                new BasicAuthScheme(new TestAuthentication())\n            );\n        }\n\n        @Override\n        public Headers headers(final TestAuthentication.User user) {\n            return user.headers();\n        }\n\n        @Override\n        public String toString() {\n            return \"Basic\";\n        }\n    }\n\n    /**\n     * Bearer authentication method.\n     *\n     * @since 0.8\n     */\n    private static final class Bearer implements Method {\n\n        @Override\n        public Slice slice(final String action) {\n            return new DockerSlice(\n                new AstoDocker(new InMemoryStorage()),\n                new Permissions.Single(TestAuthentication.ALICE.name(), action),\n                new BearerAuthScheme(\n                    token -> CompletableFuture.completedFuture(\n                        Stream.of(TestAuthentication.ALICE, TestAuthentication.BOB)\n                            .filter(user -> token.equals(token(user)))\n                            .map(user -> new Authentication.User(user.name()))\n                            .findFirst()\n                    ),\n                    \"\"\n                )\n            );\n        }\n\n        @Override\n        public Headers headers(final TestAuthentication.User user) {\n            return new Headers.From(\n                new Authorization.Bearer(token(user))\n            );\n        }\n\n        @Override\n        public String toString() {\n            return \"Bearer\";\n        }\n\n        private static String token(final TestAuthentication.User user) {\n            return String.format(\"%s:%s\", user.name(), user.password());\n        }\n    }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: http v1.1.4->v1.2.1. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n\n\nThe error is triggered in the following specific lines in the previous code:\n                    token -> CompletableFuture.completedFuture(\n                            .map(user -> new Authentication.User(user.name()))\nwith the following error message:\n[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[350,63] incompatible types: bad return type in lambda expression    inference variable U has incompatible bounds\n      equality constraints: java.util.Optional<com.artipie.http.auth.AuthUser>\n      lower bounds: java.util.Optional<java.lang.Object>\n[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[353,60] cannot find symbol  symbol:   class User\n  location: interface com.artipie.http.auth.Authentication\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "                    token -> CompletableFuture.completedFuture(\n                            .map(user -> new Authentication.User(user.name()))",
    "error_message": "[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[350,63] incompatible types: bad return type in lambda expression    inference variable U has incompatible bounds\n      equality constraints: java.util.Optional<com.artipie.http.auth.AuthUser>\n      lower bounds: java.util.Optional<java.lang.Object>\n[ERROR] /docker-adapter/src/test/java/com/artipie/docker/http/AuthTest.java:[353,60] cannot find symbol  symbol:   class User\n  location: interface com.artipie.http.auth.Authentication",
    "api_diff": "",
    "original_code": "/*\n * The MIT License (MIT) Copyright (c) 2020-2023 artipie.com\n * https://github.com/artipie/docker-adapter/LICENSE.txt\n */\npackage com.artipie.docker.http;\n\nimport com.artipie.asto.Content;\nimport com.artipie.asto.memory.InMemoryStorage;\nimport com.artipie.docker.Blob;\nimport com.artipie.docker.Docker;\nimport com.artipie.docker.RepoName;\nimport com.artipie.docker.asto.AstoDocker;\nimport com.artipie.docker.asto.TrustedBlobSource;\nimport com.artipie.http.Headers;\nimport com.artipie.http.Response;\nimport com.artipie.http.Slice;\nimport com.artipie.http.auth.Authentication;\nimport com.artipie.http.auth.BasicAuthScheme;\nimport com.artipie.http.auth.BearerAuthScheme;\nimport com.artipie.http.auth.Permissions;\nimport com.artipie.http.headers.Authorization;\nimport com.artipie.http.headers.Header;\nimport com.artipie.http.hm.ResponseMatcher;\nimport com.artipie.http.hm.RsHasStatus;\nimport com.artipie.http.rq.RequestLine;\nimport com.artipie.http.rq.RqMethod;\nimport com.artipie.http.rs.RsStatus;\nimport io.reactivex.Flowable;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.stream.Stream;\nimport org.hamcrest.MatcherAssert;\nimport org.hamcrest.core.AllOf;\nimport org.hamcrest.core.IsNot;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Disabled;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\n/**\n * Tests for {@link DockerSlice}.\n * Authentication & authorization tests.\n *\n * @since 0.8\n * @checkstyle ClassDataAbstractionCouplingCheck (500 lines)\n * @todo #434:30min test `shouldReturnForbiddenWhenUserHasNoRequiredPermissionOnSecondManifestPut`\n *  fails in github actions, locally it works fine. Figure out what is the problem and fix it.\n */\n@SuppressWarnings(\"PMD.AvoidDuplicateLiterals\")\npublic final class AuthTest {\n\n    /**\n     * Docker used in tests.\n     */\n    private Docker docker;\n\n    @BeforeEach\n    void setUp() {\n        this.docker = new AstoDocker(new InMemoryStorage());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnUnauthorizedWhenNoAuth(final Method method, final RequestLine line) {\n        MatcherAssert.assertThat(\n            method.slice(\"whatever\").response(line.toString(), Headers.EMPTY, Content.EMPTY),\n            new IsUnauthorizedResponse()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnUnauthorizedWhenUserIsUnknown(final Method method, final RequestLine line) {\n        MatcherAssert.assertThat(\n            method.slice(\"whatever\").response(\n                line.toString(),\n                method.headers(new TestAuthentication.User(\"chuck\", \"letmein\")),\n                Content.EMPTY\n            ),\n            new IsUnauthorizedResponse()\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldReturnForbiddenWhenUserHasNoRequiredPermissions(\n        final Method method,\n        final RequestLine line,\n        final String action\n    ) {\n        MatcherAssert.assertThat(\n            method.slice(action).response(\n                line.toString(),\n                method.headers(TestAuthentication.BOB),\n                Content.EMPTY\n            ),\n            new IsDeniedResponse()\n        );\n    }\n\n    @Test\n    @Disabled\n    void shouldReturnForbiddenWhenUserHasNoRequiredPermissionOnSecondManifestPut() {\n        final Basic basic = new Basic(this.docker);\n        final String line = new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\")\n            .toString();\n        final String action = \"repository:my-alpine:push\";\n        basic.slice(action).response(\n            line,\n            basic.headers(TestAuthentication.ALICE),\n            this.manifest()\n        );\n        MatcherAssert.assertThat(\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                Content.EMPTY\n            ),\n            new RsHasStatus(RsStatus.FORBIDDEN)\n        );\n    }\n\n    @Test\n    void shouldOverwriteManifestIfAllowed() {\n        final Basic basic = new Basic(this.docker);\n        final String path = \"/v2/my-alpine/manifests/abc\";\n        final String line = new RequestLine(RqMethod.PUT, path).toString();\n        final String action = \"repository:my-alpine:overwrite\";\n        final Flowable<ByteBuffer> manifest = this.manifest();\n        MatcherAssert.assertThat(\n            \"Manifest was created for the first time\",\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                manifest\n            ),\n            new ResponseMatcher(\n                RsStatus.CREATED,\n                new Header(\"Location\", path),\n                new Header(\"Content-Length\", \"0\"),\n                new Header(\n                    \"Docker-Content-Digest\",\n                    \"sha256:ef0ff2adcc3c944a63f7cafb386abc9a1d95528966085685ae9fab2a1c0bedbf\"\n                )\n            )\n        );\n        MatcherAssert.assertThat(\n            \"Manifest was overwritten\",\n            basic.slice(action).response(\n                line,\n                basic.headers(TestAuthentication.ALICE),\n                manifest\n            ),\n            new ResponseMatcher(\n                RsStatus.CREATED,\n                new Header(\"Location\", path),\n                new Header(\"Content-Length\", \"0\"),\n                new Header(\n                    \"Docker-Content-Digest\",\n                    \"sha256:ef0ff2adcc3c944a63f7cafb386abc9a1d95528966085685ae9fab2a1c0bedbf\"\n                )\n            )\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"setups\")\n    void shouldNotReturnUnauthorizedOrForbiddenWhenUserHasPermissions(\n        final Method method,\n        final RequestLine line,\n        final String action\n    ) {\n        final Response response = method.slice(action).response(\n            line.toString(),\n            method.headers(TestAuthentication.ALICE),\n            Content.EMPTY\n        );\n        MatcherAssert.assertThat(\n            response,\n            new AllOf<>(\n                Arrays.asList(\n                    new IsNot<>(new RsHasStatus(RsStatus.FORBIDDEN)),\n                    new IsNot<>(new RsHasStatus(RsStatus.UNAUTHORIZED))\n                )\n            )\n        );\n    }\n\n    @SuppressWarnings(\"PMD.UnusedPrivateMethod\")\n    private static Stream<Arguments> setups() {\n        return Stream.of(new Basic(), new Bearer()).flatMap(AuthTest::setups);\n    }\n\n    /**\n     * Create manifest content.\n     *\n     * @return Manifest content.\n     */\n    private Flowable<ByteBuffer> manifest() {\n        final byte[] content = \"config\".getBytes();\n        final Blob config = this.docker.repo(new RepoName.Valid(\"my-alpine\")).layers()\n            .put(new TrustedBlobSource(content))\n            .toCompletableFuture().join();\n        final byte[] data = String.format(\n            \"{\\\"config\\\":{\\\"digest\\\":\\\"%s\\\"},\\\"layers\\\":[],\\\"mediaType\\\":\\\"my-type\\\"}\",\n            config.digest().string()\n        ).getBytes();\n        return Flowable.just(ByteBuffer.wrap(data));\n    }\n\n    private static Stream<Arguments> setups(final Method method) {\n        return Stream.of(\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/\"),\n                \"registry:base:*\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.HEAD, \"/v2/my-alpine/manifests/1\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/manifests/2\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/manifests/latest\"),\n                \"repository:my-alpine:overwrite\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/tags/list\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.HEAD, \"/v2/my-alpine/blobs/sha256:123\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/blobs/sha256:012345\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.POST, \"/v2/my-alpine/blobs/uploads/\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PATCH, \"/v2/my-alpine/blobs/uploads/123\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.PUT, \"/v2/my-alpine/blobs/uploads/12345\"),\n                \"repository:my-alpine:push\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/my-alpine/blobs/uploads/112233\"),\n                \"repository:my-alpine:pull\"\n            ),\n            Arguments.of(\n                method,\n                new RequestLine(RqMethod.GET, \"/v2/_catalog\"),\n                \"registry:catalog:*\"\n            )\n        );\n    }\n\n    /**\n     * Authentication method.\n     *\n     * @since 0.8\n     */\n    private interface Method {\n\n        Slice slice(String action);\n\n        Headers headers(TestAuthentication.User user);\n\n    }\n\n    /**\n     * Basic authentication method.\n     *\n     * @since 0.8\n     */\n    private static final class Basic implements Method {\n\n        /**\n         * Docker repo.\n         */\n        private final Docker docker;\n\n        private Basic(final Docker docker) {\n            this.docker = docker;\n        }\n\n        private Basic() {\n            this(new AstoDocker(new InMemoryStorage()));\n        }\n\n        @Override\n        public Slice slice(final String action) {\n            return new DockerSlice(\n                this.docker,\n                new Permissions.Single(TestAuthentication.ALICE.name(), action),\n                new BasicAuthScheme(new TestAuthentication())\n            );\n        }\n\n        @Override\n        public Headers headers(final TestAuthentication.User user) {\n            return user.headers();\n        }\n\n        @Override\n        public String toString() {\n            return \"Basic\";\n        }\n    }\n\n    /**\n     * Bearer authentication method.\n     *\n     * @since 0.8\n     */\n    private static final class Bearer implements Method {\n\n        @Override\n        public Slice slice(final String action) {\n            return new DockerSlice(\n                new AstoDocker(new InMemoryStorage()),\n                new Permissions.Single(TestAuthentication.ALICE.name(), action),\n                new BearerAuthScheme(\n                    token -> CompletableFuture.completedFuture(\n                        Stream.of(TestAuthentication.ALICE, TestAuthentication.BOB)\n                            .filter(user -> token.equals(token(user)))\n                            .map(user -> new Authentication.User(user.name()))\n                            .findFirst()\n                    ),\n                    \"\"\n                )\n            );\n        }\n\n        @Override\n        public Headers headers(final TestAuthentication.User user) {\n            return new Headers.From(\n                new Authorization.Bearer(token(user))\n            );\n        }\n\n        @Override\n        public String toString() {\n            return \"Bearer\";\n        }\n\n        private static String token(final TestAuthentication.User user) {\n            return String.format(\"%s:%s\", user.name(), user.password());\n        }\n    }\n}\n",
    "project": "docker-adapter",
    "libraryName": "http",
    "libraryGroupID": "com.artipie",
    "newVersion": "v1.2.1",
    "previousVersion": "v1.1.4",
    "breakingCommit": "d38182a8a0fe1ec039aed97e103864fce717a0be"
}