{
    "absolute_path_to_file_in_container": "/depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java",
    "errors": [
        {
            "line_number": 141,
            "message": "[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[141,32] cannot find symbol",
            "additional_info": "  symbol:   method getFile()\n  location: variable dependency of type se.kth.depclean.core.model.Dependency",
            "file_name": "DepCleanManager.java",
            "BCs": [],
            "Additions": [],
            "uid": "90dbf10e-7cfe-589f-904d-520d11a1b9ee"
        },
        {
            "line_number": 220,
            "message": "[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[220,35] incompatible types: invalid constructor reference",
            "additional_info": "    constructor Scope in class se.kth.depclean.core.model.Scope cannot be applied to given types\n      required: no arguments\n      found: java.lang.String\n      reason: actual and formal argument lists differ in length",
            "file_name": "DepCleanManager.java",
            "BCs": [],
            "Additions": [],
            "uid": "80cf199b-09bd-5071-b0d4-121b57013edb"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\npackage se.kth.depclean.core;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport lombok.AllArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.io.FileUtils;\nimport se.kth.depclean.core.analysis.AnalysisFailureException;\nimport se.kth.depclean.core.analysis.DefaultProjectDependencyAnalyzer;\nimport se.kth.depclean.core.analysis.model.ProjectDependencyAnalysis;\nimport se.kth.depclean.core.model.ClassName;\nimport se.kth.depclean.core.model.Dependency;\nimport se.kth.depclean.core.model.ProjectContext;\nimport se.kth.depclean.core.model.Scope;\nimport se.kth.depclean.core.util.JarUtils;\nimport se.kth.depclean.core.wrapper.DependencyManagerWrapper;\nimport se.kth.depclean.core.wrapper.LogWrapper;\n\n/**\n * Runs the depclean process, regardless of a specific dependency manager.\n */\n@AllArgsConstructor\n@Slf4j\npublic class DepCleanManager {\n\n  private static final String SEPARATOR = \"-------------------------------------------------------\";\n  private static final String DIRECTORY_TO_EXTRACT_DEPENDENCIES = \"dependency\";\n\n  private final DependencyManagerWrapper dependencyManager;\n  private final boolean skipDepClean;\n  private final boolean ignoreTests;\n  private final Set<String> ignoreScopes;\n  private final Set<String> ignoreDependencies;\n  private final boolean failIfUnusedDirect;\n  private final boolean failIfUnusedTransitive;\n  private final boolean failIfUnusedInheritedDirect;\n  private final boolean failIfUnusedInheritedTransitive;\n  private final boolean createPomDebloated;\n  private final boolean createResultJson;\n  private final boolean createCallGraphCsv;\n\n  /**\n   * Execute the depClean manager.\n   */\n  @SneakyThrows\n  public ProjectDependencyAnalysis execute() throws AnalysisFailureException {\n    final long startTime = System.currentTimeMillis();\n\n    if (skipDepClean) {\n      getLog().info(\"Skipping DepClean plugin execution\");\n      return null;\n    }\n    printString(SEPARATOR);\n    getLog().info(\"Starting DepClean dependency analysis\");\n\n    if (dependencyManager.isMaven() && dependencyManager.isPackagingPom()) {\n      getLog().info(\"Skipping because packaging type is pom\");\n      return null;\n    }\n\n    extractClassesFromDependencies();\n\n    final DefaultProjectDependencyAnalyzer projectDependencyAnalyzer = new DefaultProjectDependencyAnalyzer();\n    final ProjectDependencyAnalysis analysis = projectDependencyAnalyzer.analyze(buildProjectContext());\n    analysis.print();\n\n    /* Fail the build if there are unused direct dependencies */\n    if (failIfUnusedDirect && analysis.hasUnusedDirectDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused direct dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused transitive dependencies */\n    if (failIfUnusedTransitive && analysis.hasUnusedTransitiveDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused transitive dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused inherited direct dependencies */\n    if (failIfUnusedInheritedDirect && analysis.hasUnusedInheritedDirectDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused inherited direct dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused inherited direct dependencies */\n    if (failIfUnusedInheritedTransitive && analysis.hasUnusedInheritedTransitiveDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused inherited transitive dependencies in the dependency tree of the project.\");\n    }\n\n    /* Writing the debloated version of the pom */\n    if (createPomDebloated) {\n      dependencyManager.getDebloater(analysis).write();\n    }\n\n    /* Writing the JSON file with the depclean results */\n    if (createResultJson) {\n      createResultJson(analysis);\n    }\n\n    final long stopTime = System.currentTimeMillis();\n    getLog().info(\"Analysis done in \" + getTime(stopTime - startTime));\n\n    return analysis;\n  }\n\n  @SneakyThrows\n  private void extractClassesFromDependencies() {\n    File dependencyDirectory = dependencyManager.getBuildDirectory().resolve(DIRECTORY_TO_EXTRACT_DEPENDENCIES).toFile();\n    FileUtils.deleteDirectory(dependencyDirectory);\n    dependencyManager.dependencyGraph().allDependencies()\n        .forEach(jarFile -> copyDependencies(jarFile, dependencyDirectory));\n\n    // Workaround for dependencies that are in located in a project's libs directory.\n    if (dependencyManager.getBuildDirectory().resolve(\"libs\").toFile().exists()) {\n      try {\n        FileUtils.copyDirectory(\n            dependencyManager.getBuildDirectory().resolve(\"libs\").toFile(),\n            dependencyDirectory\n        );\n      } catch (IOException | NullPointerException e) {\n        getLog().error(\"Error copying directory libs to\" + dependencyDirectory.getAbsolutePath());\n      }\n    }\n\n    /* Decompress dependencies */\n    if (dependencyDirectory.exists()) {\n      JarUtils.decompress(dependencyDirectory.getAbsolutePath());\n    }\n  }\n\n  private void copyDependencies(Dependency dependency, File destFolder) {\n    copyDependencies(dependency.getFile(), destFolder);\n  }\n\n  @SneakyThrows\n  private void copyDependencies(File jarFile, File destFolder) {\n    FileUtils.copyFileToDirectory(jarFile, destFolder);\n  }\n\n  private void createResultJson(ProjectDependencyAnalysis analysis) {\n    printString(\"Creating depclean-results.json, please wait...\");\n    final File jsonFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"depclean-results.json\");\n    final File treeFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"tree.txt\");\n    final File csvFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"depclean-callgraph.csv\");\n    try {\n      dependencyManager.generateDependencyTree(treeFile);\n    } catch (IOException | InterruptedException e) {\n      getLog().error(\"Unable to generate dependency tree.\");\n      // Restore interrupted state...\n      Thread.currentThread().interrupt();\n      return;\n    }\n    if (createCallGraphCsv) {\n      printString(\"Creating \" + csvFile.getName() + \", please wait...\");\n      try {\n        FileUtils.write(csvFile, \"OriginClass,TargetClass,OriginDependency,TargetDependency\\n\", Charset.defaultCharset());\n      } catch (IOException e) {\n        getLog().error(\"Error writing the CSV header.\");\n      }\n    }\n    String treeAsJson = dependencyManager.getTreeAsJson(\n        treeFile,\n        analysis,\n        csvFile,\n        createCallGraphCsv\n    );\n\n    try {\n      FileUtils.write(jsonFile, treeAsJson, Charset.defaultCharset());\n    } catch (IOException e) {\n      getLog().error(\"Unable to generate \" + jsonFile.getName() + \" file.\");\n    }\n    if (jsonFile.exists()) {\n      getLog().info(jsonFile.getName() + \" file created in: \" + jsonFile.getAbsolutePath());\n    }\n    if (csvFile.exists()) {\n      getLog().info(csvFile.getName() + \" file created in: \" + csvFile.getAbsolutePath());\n    }\n  }\n\n  private ProjectContext buildProjectContext() {\n    if (ignoreTests) {\n      ignoreScopes.add(\"test\");\n    }\n\n    // Consider are used all the classes declared in Maven processors\n    Set<ClassName> allUsedClasses = new HashSet<>();\n    Set<ClassName> usedClassesFromProcessors = dependencyManager\n        .collectUsedClassesFromProcessors().stream()\n        .map(ClassName::new)\n        .collect(Collectors.toSet());\n\n    // Consider as used all the classes located in the imports of the source code\n    Set<ClassName> usedClassesFromSource = dependencyManager.collectUsedClassesFromSource(\n            dependencyManager.getSourceDirectory(),\n            dependencyManager.getTestDirectory())\n        .stream()\n        .map(ClassName::new)\n        .collect(Collectors.toSet());\n\n    allUsedClasses.addAll(usedClassesFromProcessors);\n    allUsedClasses.addAll(usedClassesFromSource);\n\n    return new ProjectContext(\n        dependencyManager.dependencyGraph(),\n        dependencyManager.getOutputDirectories(),\n        dependencyManager.getTestOutputDirectories(),\n        dependencyManager.getSourceDirectory(),\n        dependencyManager.getTestDirectory(),\n        dependencyManager.getDependenciesDirectory(),\n        ignoreScopes.stream().map(Scope::new).collect(Collectors.toSet()),\n        toDependency(dependencyManager.dependencyGraph().allDependencies(), ignoreDependencies),\n        allUsedClasses\n    );\n  }\n\n  /**\n   * Returns a set of {@code DependencyCoordinate}s that match given string representations.\n   *\n   * @param allDependencies    all known dependencies\n   * @param dependencyPatterns string representation of dependencies to match\n   * @return a set of {@code Dependency} that match given string representations\n   */\n  private Set<Dependency> toDependency(Set<Dependency> allDependencies, Set<String> dependencyPatterns) {\n    System.out.println(\"allDependencies: \");\n    allDependencies.forEach(System.out::println);\n    System.out.println(\"dependencyPatterns: \");\n    dependencyPatterns.forEach(System.out::println);\n\n    return dependencyPatterns.stream()\n            .flatMap(pattern -> findDependencies(allDependencies, pattern).stream())\n            .collect(Collectors.toSet());\n  }\n\n  private Set<Dependency> findDependencies(Set<Dependency> allDependencies, String patternString) {\n    Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\n    return allDependencies.stream()\n            .filter(dep -> pattern.matcher(dep.toString()).matches())\n            .collect(Collectors.toSet());\n  }\n\n  private String getTime(long millis) {\n    long minutes = TimeUnit.MILLISECONDS.toMinutes(millis);\n    long seconds = (TimeUnit.MILLISECONDS.toSeconds(millis) % 60);\n    return String.format(\"%smin %ss\", minutes, seconds);\n  }\n\n  private void printString(final String string) {\n    System.out.println(string); //NOSONAR avoid a warning of non-used logger\n  }\n\n  private LogWrapper getLog() {\n    return dependencyManager.getLog();\n  }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: guava 31.1-jre->32.0.0-android. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- com.google.common.collect.ImmutableSet.toImmutableSet\n-- com.google.common.collect.ImmutableSortedSetFauxverideShim.toImmutableSet\n\nThe error is triggered in the following specific lines in the previous code:\n    copyDependencies(dependency.getFile(), destFolder);\n        ignoreScopes.stream().map(Scope::new).collect(Collectors.toSet()),\nwith the following error message:\n[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[141,32] cannot find symbol  symbol:   method getFile()\n  location: variable dependency of type se.kth.depclean.core.model.Dependency\n[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[220,35] incompatible types: invalid constructor reference    constructor Scope in class se.kth.depclean.core.model.Scope cannot be applied to given types\n      required: no arguments\n      found: java.lang.String\n      reason: actual and formal argument lists differ in length\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "    copyDependencies(dependency.getFile(), destFolder);\n        ignoreScopes.stream().map(Scope::new).collect(Collectors.toSet()),",
    "error_message": "[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[141,32] cannot find symbol  symbol:   method getFile()\n  location: variable dependency of type se.kth.depclean.core.model.Dependency\n[ERROR] /depclean/depclean-core/src/main/java/se/kth/depclean/core/DepCleanManager.java:[220,35] incompatible types: invalid constructor reference    constructor Scope in class se.kth.depclean.core.model.Scope cannot be applied to given types\n      required: no arguments\n      found: java.lang.String\n      reason: actual and formal argument lists differ in length",
    "api_diff": "-- com.google.common.collect.ImmutableSet.toImmutableSet\n-- com.google.common.collect.ImmutableSortedSetFauxverideShim.toImmutableSet",
    "original_code": "package se.kth.depclean.core;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.charset.Charset;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport lombok.AllArgsConstructor;\nimport lombok.SneakyThrows;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.io.FileUtils;\nimport se.kth.depclean.core.analysis.AnalysisFailureException;\nimport se.kth.depclean.core.analysis.DefaultProjectDependencyAnalyzer;\nimport se.kth.depclean.core.analysis.model.ProjectDependencyAnalysis;\nimport se.kth.depclean.core.model.ClassName;\nimport se.kth.depclean.core.model.Dependency;\nimport se.kth.depclean.core.model.ProjectContext;\nimport se.kth.depclean.core.model.Scope;\nimport se.kth.depclean.core.util.JarUtils;\nimport se.kth.depclean.core.wrapper.DependencyManagerWrapper;\nimport se.kth.depclean.core.wrapper.LogWrapper;\n\n/**\n * Runs the depclean process, regardless of a specific dependency manager.\n */\n@AllArgsConstructor\n@Slf4j\npublic class DepCleanManager {\n\n  private static final String SEPARATOR = \"-------------------------------------------------------\";\n  private static final String DIRECTORY_TO_EXTRACT_DEPENDENCIES = \"dependency\";\n\n  private final DependencyManagerWrapper dependencyManager;\n  private final boolean skipDepClean;\n  private final boolean ignoreTests;\n  private final Set<String> ignoreScopes;\n  private final Set<String> ignoreDependencies;\n  private final boolean failIfUnusedDirect;\n  private final boolean failIfUnusedTransitive;\n  private final boolean failIfUnusedInheritedDirect;\n  private final boolean failIfUnusedInheritedTransitive;\n  private final boolean createPomDebloated;\n  private final boolean createResultJson;\n  private final boolean createCallGraphCsv;\n\n  /**\n   * Execute the depClean manager.\n   */\n  @SneakyThrows\n  public ProjectDependencyAnalysis execute() throws AnalysisFailureException {\n    final long startTime = System.currentTimeMillis();\n\n    if (skipDepClean) {\n      getLog().info(\"Skipping DepClean plugin execution\");\n      return null;\n    }\n    printString(SEPARATOR);\n    getLog().info(\"Starting DepClean dependency analysis\");\n\n    if (dependencyManager.isMaven() && dependencyManager.isPackagingPom()) {\n      getLog().info(\"Skipping because packaging type is pom\");\n      return null;\n    }\n\n    extractClassesFromDependencies();\n\n    final DefaultProjectDependencyAnalyzer projectDependencyAnalyzer = new DefaultProjectDependencyAnalyzer();\n    final ProjectDependencyAnalysis analysis = projectDependencyAnalyzer.analyze(buildProjectContext());\n    analysis.print();\n\n    /* Fail the build if there are unused direct dependencies */\n    if (failIfUnusedDirect && analysis.hasUnusedDirectDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused direct dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused transitive dependencies */\n    if (failIfUnusedTransitive && analysis.hasUnusedTransitiveDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused transitive dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused inherited direct dependencies */\n    if (failIfUnusedInheritedDirect && analysis.hasUnusedInheritedDirectDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused inherited direct dependencies in the dependency tree of the project.\");\n    }\n\n    /* Fail the build if there are unused inherited direct dependencies */\n    if (failIfUnusedInheritedTransitive && analysis.hasUnusedInheritedTransitiveDependencies()) {\n      throw new AnalysisFailureException(\n          \"Build failed due to unused inherited transitive dependencies in the dependency tree of the project.\");\n    }\n\n    /* Writing the debloated version of the pom */\n    if (createPomDebloated) {\n      dependencyManager.getDebloater(analysis).write();\n    }\n\n    /* Writing the JSON file with the depclean results */\n    if (createResultJson) {\n      createResultJson(analysis);\n    }\n\n    final long stopTime = System.currentTimeMillis();\n    getLog().info(\"Analysis done in \" + getTime(stopTime - startTime));\n\n    return analysis;\n  }\n\n  @SneakyThrows\n  private void extractClassesFromDependencies() {\n    File dependencyDirectory = dependencyManager.getBuildDirectory().resolve(DIRECTORY_TO_EXTRACT_DEPENDENCIES).toFile();\n    FileUtils.deleteDirectory(dependencyDirectory);\n    dependencyManager.dependencyGraph().allDependencies()\n        .forEach(jarFile -> copyDependencies(jarFile, dependencyDirectory));\n\n    // Workaround for dependencies that are in located in a project's libs directory.\n    if (dependencyManager.getBuildDirectory().resolve(\"libs\").toFile().exists()) {\n      try {\n        FileUtils.copyDirectory(\n            dependencyManager.getBuildDirectory().resolve(\"libs\").toFile(),\n            dependencyDirectory\n        );\n      } catch (IOException | NullPointerException e) {\n        getLog().error(\"Error copying directory libs to\" + dependencyDirectory.getAbsolutePath());\n      }\n    }\n\n    /* Decompress dependencies */\n    if (dependencyDirectory.exists()) {\n      JarUtils.decompress(dependencyDirectory.getAbsolutePath());\n    }\n  }\n\n  private void copyDependencies(Dependency dependency, File destFolder) {\n    copyDependencies(dependency.getFile(), destFolder);\n  }\n\n  @SneakyThrows\n  private void copyDependencies(File jarFile, File destFolder) {\n    FileUtils.copyFileToDirectory(jarFile, destFolder);\n  }\n\n  private void createResultJson(ProjectDependencyAnalysis analysis) {\n    printString(\"Creating depclean-results.json, please wait...\");\n    final File jsonFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"depclean-results.json\");\n    final File treeFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"tree.txt\");\n    final File csvFile = new File(dependencyManager.getBuildDirectory() + File.separator + \"depclean-callgraph.csv\");\n    try {\n      dependencyManager.generateDependencyTree(treeFile);\n    } catch (IOException | InterruptedException e) {\n      getLog().error(\"Unable to generate dependency tree.\");\n      // Restore interrupted state...\n      Thread.currentThread().interrupt();\n      return;\n    }\n    if (createCallGraphCsv) {\n      printString(\"Creating \" + csvFile.getName() + \", please wait...\");\n      try {\n        FileUtils.write(csvFile, \"OriginClass,TargetClass,OriginDependency,TargetDependency\\n\", Charset.defaultCharset());\n      } catch (IOException e) {\n        getLog().error(\"Error writing the CSV header.\");\n      }\n    }\n    String treeAsJson = dependencyManager.getTreeAsJson(\n        treeFile,\n        analysis,\n        csvFile,\n        createCallGraphCsv\n    );\n\n    try {\n      FileUtils.write(jsonFile, treeAsJson, Charset.defaultCharset());\n    } catch (IOException e) {\n      getLog().error(\"Unable to generate \" + jsonFile.getName() + \" file.\");\n    }\n    if (jsonFile.exists()) {\n      getLog().info(jsonFile.getName() + \" file created in: \" + jsonFile.getAbsolutePath());\n    }\n    if (csvFile.exists()) {\n      getLog().info(csvFile.getName() + \" file created in: \" + csvFile.getAbsolutePath());\n    }\n  }\n\n  private ProjectContext buildProjectContext() {\n    if (ignoreTests) {\n      ignoreScopes.add(\"test\");\n    }\n\n    // Consider are used all the classes declared in Maven processors\n    Set<ClassName> allUsedClasses = new HashSet<>();\n    Set<ClassName> usedClassesFromProcessors = dependencyManager\n        .collectUsedClassesFromProcessors().stream()\n        .map(ClassName::new)\n        .collect(Collectors.toSet());\n\n    // Consider as used all the classes located in the imports of the source code\n    Set<ClassName> usedClassesFromSource = dependencyManager.collectUsedClassesFromSource(\n            dependencyManager.getSourceDirectory(),\n            dependencyManager.getTestDirectory())\n        .stream()\n        .map(ClassName::new)\n        .collect(Collectors.toSet());\n\n    allUsedClasses.addAll(usedClassesFromProcessors);\n    allUsedClasses.addAll(usedClassesFromSource);\n\n    return new ProjectContext(\n        dependencyManager.dependencyGraph(),\n        dependencyManager.getOutputDirectories(),\n        dependencyManager.getTestOutputDirectories(),\n        dependencyManager.getSourceDirectory(),\n        dependencyManager.getTestDirectory(),\n        dependencyManager.getDependenciesDirectory(),\n        ignoreScopes.stream().map(Scope::new).collect(Collectors.toSet()),\n        toDependency(dependencyManager.dependencyGraph().allDependencies(), ignoreDependencies),\n        allUsedClasses\n    );\n  }\n\n  /**\n   * Returns a set of {@code DependencyCoordinate}s that match given string representations.\n   *\n   * @param allDependencies    all known dependencies\n   * @param dependencyPatterns string representation of dependencies to match\n   * @return a set of {@code Dependency} that match given string representations\n   */\n  private Set<Dependency> toDependency(Set<Dependency> allDependencies, Set<String> dependencyPatterns) {\n    System.out.println(\"allDependencies: \");\n    allDependencies.forEach(System.out::println);\n    System.out.println(\"dependencyPatterns: \");\n    dependencyPatterns.forEach(System.out::println);\n\n    return dependencyPatterns.stream()\n            .flatMap(pattern -> findDependencies(allDependencies, pattern).stream())\n            .collect(Collectors.toSet());\n  }\n\n  private Set<Dependency> findDependencies(Set<Dependency> allDependencies, String patternString) {\n    Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);\n    return allDependencies.stream()\n            .filter(dep -> pattern.matcher(dep.toString()).matches())\n            .collect(Collectors.toSet());\n  }\n\n  private String getTime(long millis) {\n    long minutes = TimeUnit.MILLISECONDS.toMinutes(millis);\n    long seconds = (TimeUnit.MILLISECONDS.toSeconds(millis) % 60);\n    return String.format(\"%smin %ss\", minutes, seconds);\n  }\n\n  private void printString(final String string) {\n    System.out.println(string); //NOSONAR avoid a warning of non-used logger\n  }\n\n  private LogWrapper getLog() {\n    return dependencyManager.getLog();\n  }\n}\n",
    "project": "depclean",
    "libraryName": "guava",
    "libraryGroupID": "com.google.guava",
    "newVersion": "32.0.0-android",
    "previousVersion": "31.1-jre",
    "breakingCommit": "b86a5f84b44a9b50aee69745886c47123f721de3"
}