{
    "absolute_path_to_file_in_container": "/java-api/src/main/java/io/zold/api/Copies.java",
    "errors": [
        {
            "line_number": 30,
            "message": "[ERROR] /java-api/src/main/java/io/zold/api/Copies.java:[30,30] cannot find symbol",
            "additional_info": "  symbol:   class CollectionOf\n  location: package org.cactoos.collection",
            "file_name": "Copies.java",
            "BCs": [
                {
                    "element": "org.cactoos.collection.CollectionOf",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "24da5adb-1636-5d76-abd9-fa3c5b8bf066"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2018-2023 Yegor Bugayenko\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage io.zold.api;\n\nimport io.zold.api.Copies.Copy;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.cactoos.collection.CollectionOf;\nimport org.cactoos.iterable.IterableEnvelope;\nimport org.cactoos.iterable.IterableOf;\nimport org.cactoos.iterable.Joined;\nimport org.cactoos.iterable.Mapped;\n\n/**\n * Multiple copies of a Wallet.\n * @since 1.0\n */\npublic final class Copies extends IterableEnvelope<Copy> {\n\n    /**\n     * Ctor.\n     * @param id Id of the wallet to pull.\n     * @param remotes Remote nodes.\n     */\n    Copies(final long id, final Iterable<Remote> remotes) {\n        super(() -> copies(id, remotes));\n    }\n\n    /**\n     * Builds copies from remotes.\n     * @param id Wallet's id\n     * @param remotes List of remotes\n     * @return Iterable Iterable of Copy\n     * @throws IOException If fails\n     */\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    private static Iterable<Copy> copies(final long id,\n        final Iterable<Remote> remotes) throws IOException {\n        final List<Copy> copies = new ArrayList<>(10);\n        for (final Remote remote : remotes) {\n            final Wallet wallet = remote.pull(id);\n            boolean updated = false;\n            for (int idx = 0; idx < copies.size(); idx += 1) {\n                final Copy copy = copies.get(idx);\n                if (Copies.equalWallets(copies.get(idx).wallet(), wallet)) {\n                    copies.set(idx, copy.with(remote));\n                    updated = true;\n                }\n            }\n            if (!updated) {\n                copies.add(new Copy(wallet, remote));\n            }\n        }\n        return new IterableOf<>(copies);\n    }\n\n    /**\n     * Checks if content of two wallets is equal.\n     * @param first First wallet\n     * @param second Second wallet\n     * @return Boolean Boolean\n     * @throws IOException If fails\n     * @todo #56:30min Compare the entire content of two wallets. In addition\n     *  to id, compare RSA key and all transactions one by one. Entire content\n     *  of each transaction should be compared.\n     */\n    private static boolean equalWallets(final Wallet first,\n        final Wallet second) throws IOException {\n        return first.id() == second.id() && new CollectionOf<>(\n            first.ledger()\n        ).size() == new CollectionOf<>(second.ledger()).size();\n    }\n\n    /**\n     * One copy of a {@link Wallet}.\n     * @since 1.0\n     */\n    static final class Copy implements Comparable<Copy> {\n\n        /**\n         * The wallet.\n         */\n        private final Wallet wlt;\n\n        /**\n         * The remote nodes where the wallet was found.\n         */\n        private final Iterable<Remote> remotes;\n\n        /**\n         * Ctor.\n         * @param wallet The wallet.\n         * @param remotes The remote nodes where the wallet was found.\n         */\n        Copy(final Wallet wallet, final Remote... remotes) {\n            this(wallet, new IterableOf<>(remotes));\n        }\n\n        /**\n         * Ctor.\n         * @param wallet The wallet.\n         * @param remotes The remote nodes where the wallet was found.\n         */\n        Copy(final Wallet wallet, final Iterable<Remote> remotes) {\n            this.wlt = wallet;\n            this.remotes = remotes;\n        }\n\n        /**\n         * Creates new Copy instance with additional remote.\n         * @param remote Remote\n         * @return Copy Copy\n         */\n        public Copy with(final Remote remote) {\n            return new Copy(this.wallet(), new Joined<>(remote, this.remotes));\n        }\n\n        /**\n         * The wallet.\n         * @return The wallet.\n         */\n        public Wallet wallet() {\n            return this.wlt;\n        }\n\n        /**\n         * The summary of the score of all the remote nodes.\n         * @return The score.\n         */\n        public Score score() {\n            return new Score.Summed(new Mapped<>(Remote::score, this.remotes));\n        }\n\n        @Override\n        public int compareTo(final Copy other) {\n            return this.score().compareTo(other.score());\n        }\n    }\n}\n\n'''\nThe error is caused by a change in the API of the dependency: cactoos 0.35->0.55.0. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- org.cactoos.io.LengthOf\n-- org.cactoos.iterable.LengthOf\n-- org.cactoos.iterator.LengthOf\n-- org.cactoos.collection.CollectionOf\n-- org.cactoos.text.RandomText\n-- org.cactoos.collection.Filtered\n-- org.cactoos.scalar.CheckedScalar\n-- org.cactoos.scalar.UncheckedScalar\n-- org.cactoos.text.SplitText\n-- org.cactoos.scalar.IoCheckedScalar\n-- org.cactoos.scalar.SolidScalar\n-- org.cactoos.text.JoinedText\n-- org.cactoos.scalar.StickyScalar\n-- org.cactoos.text.TrimmedText\n++ public LengthOf org.cactoos.scalar.LengthOf(java.lang.Iterable)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Text)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Input,int)\n++ public final null org.cactoos.scalar.LengthOf\n++ public Filtered org.cactoos.iterable.Filtered(java.lang.Iterable,org.cactoos.Func)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Input)\n++ public Filtered org.cactoos.iterator.Filtered(java.util.Iterator,org.cactoos.Func)\n\nThe error is triggered in the following specific lines in the previous code:\nimport org.cactoos.collection.CollectionOf;\nwith the following error message:\n[ERROR] /java-api/src/main/java/io/zold/api/Copies.java:[30,30] cannot find symbol  symbol:   class CollectionOf\n  location: package org.cactoos.collection\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import org.cactoos.collection.CollectionOf;",
    "error_message": "[ERROR] /java-api/src/main/java/io/zold/api/Copies.java:[30,30] cannot find symbol  symbol:   class CollectionOf\n  location: package org.cactoos.collection",
    "api_diff": "-- org.cactoos.io.LengthOf\n-- org.cactoos.iterable.LengthOf\n-- org.cactoos.iterator.LengthOf\n-- org.cactoos.collection.CollectionOf\n-- org.cactoos.text.RandomText\n-- org.cactoos.collection.Filtered\n-- org.cactoos.scalar.CheckedScalar\n-- org.cactoos.scalar.UncheckedScalar\n-- org.cactoos.text.SplitText\n-- org.cactoos.scalar.IoCheckedScalar\n-- org.cactoos.scalar.SolidScalar\n-- org.cactoos.text.JoinedText\n-- org.cactoos.scalar.StickyScalar\n-- org.cactoos.text.TrimmedText\n++ public LengthOf org.cactoos.scalar.LengthOf(java.lang.Iterable)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Text)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Input,int)\n++ public final null org.cactoos.scalar.LengthOf\n++ public Filtered org.cactoos.iterable.Filtered(java.lang.Iterable,org.cactoos.Func)\n++ public LengthOf org.cactoos.scalar.LengthOf(org.cactoos.Input)\n++ public Filtered org.cactoos.iterator.Filtered(java.util.Iterator,org.cactoos.Func)",
    "original_code": "/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2018-2023 Yegor Bugayenko\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage io.zold.api;\n\nimport io.zold.api.Copies.Copy;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.cactoos.collection.CollectionOf;\nimport org.cactoos.iterable.IterableEnvelope;\nimport org.cactoos.iterable.IterableOf;\nimport org.cactoos.iterable.Joined;\nimport org.cactoos.iterable.Mapped;\n\n/**\n * Multiple copies of a Wallet.\n * @since 1.0\n */\npublic final class Copies extends IterableEnvelope<Copy> {\n\n    /**\n     * Ctor.\n     * @param id Id of the wallet to pull.\n     * @param remotes Remote nodes.\n     */\n    Copies(final long id, final Iterable<Remote> remotes) {\n        super(() -> copies(id, remotes));\n    }\n\n    /**\n     * Builds copies from remotes.\n     * @param id Wallet's id\n     * @param remotes List of remotes\n     * @return Iterable Iterable of Copy\n     * @throws IOException If fails\n     */\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    private static Iterable<Copy> copies(final long id,\n        final Iterable<Remote> remotes) throws IOException {\n        final List<Copy> copies = new ArrayList<>(10);\n        for (final Remote remote : remotes) {\n            final Wallet wallet = remote.pull(id);\n            boolean updated = false;\n            for (int idx = 0; idx < copies.size(); idx += 1) {\n                final Copy copy = copies.get(idx);\n                if (Copies.equalWallets(copies.get(idx).wallet(), wallet)) {\n                    copies.set(idx, copy.with(remote));\n                    updated = true;\n                }\n            }\n            if (!updated) {\n                copies.add(new Copy(wallet, remote));\n            }\n        }\n        return new IterableOf<>(copies);\n    }\n\n    /**\n     * Checks if content of two wallets is equal.\n     * @param first First wallet\n     * @param second Second wallet\n     * @return Boolean Boolean\n     * @throws IOException If fails\n     * @todo #56:30min Compare the entire content of two wallets. In addition\n     *  to id, compare RSA key and all transactions one by one. Entire content\n     *  of each transaction should be compared.\n     */\n    private static boolean equalWallets(final Wallet first,\n        final Wallet second) throws IOException {\n        return first.id() == second.id() && new CollectionOf<>(\n            first.ledger()\n        ).size() == new CollectionOf<>(second.ledger()).size();\n    }\n\n    /**\n     * One copy of a {@link Wallet}.\n     * @since 1.0\n     */\n    static final class Copy implements Comparable<Copy> {\n\n        /**\n         * The wallet.\n         */\n        private final Wallet wlt;\n\n        /**\n         * The remote nodes where the wallet was found.\n         */\n        private final Iterable<Remote> remotes;\n\n        /**\n         * Ctor.\n         * @param wallet The wallet.\n         * @param remotes The remote nodes where the wallet was found.\n         */\n        Copy(final Wallet wallet, final Remote... remotes) {\n            this(wallet, new IterableOf<>(remotes));\n        }\n\n        /**\n         * Ctor.\n         * @param wallet The wallet.\n         * @param remotes The remote nodes where the wallet was found.\n         */\n        Copy(final Wallet wallet, final Iterable<Remote> remotes) {\n            this.wlt = wallet;\n            this.remotes = remotes;\n        }\n\n        /**\n         * Creates new Copy instance with additional remote.\n         * @param remote Remote\n         * @return Copy Copy\n         */\n        public Copy with(final Remote remote) {\n            return new Copy(this.wallet(), new Joined<>(remote, this.remotes));\n        }\n\n        /**\n         * The wallet.\n         * @return The wallet.\n         */\n        public Wallet wallet() {\n            return this.wlt;\n        }\n\n        /**\n         * The summary of the score of all the remote nodes.\n         * @return The score.\n         */\n        public Score score() {\n            return new Score.Summed(new Mapped<>(Remote::score, this.remotes));\n        }\n\n        @Override\n        public int compareTo(final Copy other) {\n            return this.score().compareTo(other.score());\n        }\n    }\n}\n",
    "project": "java-api",
    "libraryName": "cactoos",
    "libraryGroupID": "org.cactoos",
    "newVersion": "0.55.0",
    "previousVersion": "0.35",
    "breakingCommit": "38c9915f0cfdf0c1a2b17c3c6f283c23a0aac0cf"
}