{
    "absolute_path_to_file_in_container": "/openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java",
    "errors": [
        {
            "line_number": 22,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[22,28] cannot find symbol",
            "additional_info": "  symbol:   class MaxSizeConfig\n  location: package com.hazelcast.config",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.config.MaxSizeConfig",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "0b48144b-8165-56a0-8aec-a12aa8b58862"
        },
        {
            "line_number": 27,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[27,26] cannot find symbol",
            "additional_info": "  symbol:   class Cluster\n  location: package com.hazelcast.core",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "c4762c45-21c3-55d4-86f6-7d0159cf2afa"
        },
        {
            "line_number": 30,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[30,26] cannot find symbol",
            "additional_info": "  symbol:   class Member\n  location: package com.hazelcast.core",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "dafb366f-651f-5158-b1c6-88de79bd8ac1"
        },
        {
            "line_number": 149,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[149,20] cannot find symbol",
            "additional_info": "  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [],
            "uid": "035561ec-7c71-58be-a786-9d7f28ed8db4"
        },
        {
            "line_number": 501,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[501,13] cannot find symbol",
            "additional_info": "  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "d99a109d-25dd-5794-82cd-57b12669a18a"
        },
        {
            "line_number": 655,
            "message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[655,42] cannot find symbol",
            "additional_info": "  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory",
            "file_name": "ClusteredCacheFactory.java",
            "BCs": [
                {
                    "element": "com.hazelcast.core.Cluster",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                },
                {
                    "element": "com.hazelcast.core.Member",
                    "nature": "DELETION",
                    "kind": "TYPE_REMOVED"
                }
            ],
            "Additions": [
                "++ public abstract interface null com.hazelcast.cluster.Member",
                "++ public abstract interface null com.hazelcast.cluster.Member"
            ],
            "uid": "d99a109d-25dd-5794-82cd-57b12669a18a"
        }
    ],
    "prompt": "\nThe following Java client code fails: \n'''java\n/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MaxSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\n\n'''\nThe error is caused by a change in the API of the dependency: hazelcast 3.12.5->5.1. \nThe new library version includes the following relevant backward incompatible changes on API. \n(API changes format: lines starting with '--' denote removed members, '++' denote added ones, '~~' denote mutations with change kind) \n-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap\n\nThe error is triggered in the following specific lines in the previous code:\nimport com.hazelcast.config.MaxSizeConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Member;\n    private static Cluster cluster = null;\n    private Member getMember(final byte[] nodeID) {\n    public static NodeID getNodeID(final Member member) {\nwith the following error message:\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[22,28] cannot find symbol  symbol:   class MaxSizeConfig\n  location: package com.hazelcast.config\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[27,26] cannot find symbol  symbol:   class Cluster\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[30,26] cannot find symbol  symbol:   class Member\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[149,20] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[501,13] cannot find symbol  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[655,42] cannot find symbol  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n\nPlease apply your reasoning and generate the fix following the system instruction.\n",
    "buggy_lines": "import com.hazelcast.config.MaxSizeConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Member;\n    private static Cluster cluster = null;\n    private Member getMember(final byte[] nodeID) {\n    public static NodeID getNodeID(final Member member) {",
    "error_message": "[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[22,28] cannot find symbol  symbol:   class MaxSizeConfig\n  location: package com.hazelcast.config\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[27,26] cannot find symbol  symbol:   class Cluster\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[30,26] cannot find symbol  symbol:   class Member\n  location: package com.hazelcast.core\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[149,20] cannot find symbol  symbol:   class Cluster\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[501,13] cannot find symbol  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory\n[ERROR] /openfire-hazelcast-plugin/src/java/org/jivesoftware/openfire/plugin/util/cache/ClusteredCacheFactory.java:[655,42] cannot find symbol  symbol:   class Member\n  location: class org.jivesoftware.openfire.plugin.util.cache.ClusteredCacheFactory",
    "api_diff": "-- com.hazelcast.core.Cluster\n-- com.hazelcast.config.MaxSizeConfig\n-- com.hazelcast.core.Member\n-- com.hazelcast.core.MemberAttributeEvent\n-- com.hazelcast.core.MembershipEvent\n-- com.hazelcast.core.MembershipListener\n-- com.hazelcast.core.IMap\n-- com.hazelcast.core.MapEvent\n++ public MembershipEvent com.hazelcast.cluster.MembershipEvent(com.hazelcast.cluster.Cluster,com.hazelcast.cluster.Member,int,java.util.Set)\n++ public null com.hazelcast.cluster.MembershipEvent\n++ public abstract interface null com.hazelcast.cluster.Member\n++ public null com.hazelcast.map.MapEvent\n++ public abstract interface null com.hazelcast.cluster.MembershipListener\n++ public MapEvent com.hazelcast.map.MapEvent(java.lang.Object,com.hazelcast.cluster.Member,int,int)\n++ public abstract interface null com.hazelcast.map.IMap",
    "original_code": "/*\n * Copyright (C) 2007-2009 Jive Software. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jivesoftware.openfire.plugin.util.cache;\n\nimport com.hazelcast.config.ClasspathXmlConfig;\nimport com.hazelcast.config.Config;\nimport com.hazelcast.config.MapConfig;\nimport com.hazelcast.config.MaxSizeConfig;\nimport com.hazelcast.config.MemberAttributeConfig;\nimport com.hazelcast.config.MemcacheProtocolConfig;\nimport com.hazelcast.config.NetworkConfig;\nimport com.hazelcast.config.RestApiConfig;\nimport com.hazelcast.core.Cluster;\nimport com.hazelcast.core.Hazelcast;\nimport com.hazelcast.core.HazelcastInstance;\nimport com.hazelcast.core.Member;\nimport org.jivesoftware.openfire.JMXManager;\nimport org.jivesoftware.openfire.XMPPServer;\nimport org.jivesoftware.openfire.cluster.ClusterEventListener;\nimport org.jivesoftware.openfire.cluster.ClusterManager;\nimport org.jivesoftware.openfire.cluster.ClusterNodeInfo;\nimport org.jivesoftware.openfire.cluster.NodeID;\nimport org.jivesoftware.openfire.container.Plugin;\nimport org.jivesoftware.openfire.container.PluginClassLoader;\nimport org.jivesoftware.openfire.plugin.HazelcastPlugin;\nimport org.jivesoftware.openfire.plugin.util.cluster.HazelcastClusterNodeInfo;\nimport org.jivesoftware.util.StringUtils;\nimport org.jivesoftware.util.SystemProperty;\nimport org.jivesoftware.util.cache.Cache;\nimport org.jivesoftware.util.cache.CacheFactory;\nimport org.jivesoftware.util.cache.CacheFactoryStrategy;\nimport org.jivesoftware.util.cache.CacheWrapper;\nimport org.jivesoftware.util.cache.ClusterTask;\nimport org.jivesoftware.util.cache.ExternalizableUtil;\nimport org.jivesoftware.util.cache.ExternalizableUtilStrategy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Serializable;\nimport java.nio.charset.StandardCharsets;\nimport java.text.MessageFormat;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\n\n/**\n * CacheFactory implementation to use when using Hazelcast in cluster mode.\n *\n * @author Tom Evans\n * @author Gaston Dombiak\n */\npublic class ClusteredCacheFactory implements CacheFactoryStrategy {\n\n    private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.executor.service.name\")\n        .setDefaultValue(\"openfire::cluster::executor\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.max.execution.seconds\")\n        .setDefaultValue(Duration.ofSeconds(30))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)\n        .setKey(\"hazelcast.startup.retry.seconds\")\n        .setDefaultValue(Duration.ofSeconds(10))\n        .setChronoUnit(ChronoUnit.SECONDS)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)\n        .setKey(\"hazelcast.startup.retry.count\")\n        .setDefaultValue(1)\n        .setDynamic(true)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)\n        .setKey(\"hazelcast.config.xml.filename\")\n        .setDefaultValue(\"hazelcast-cache-config.xml\")\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.jmx.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.rest.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n    private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)\n        .setKey(\"hazelcast.config.memcache.enabled\")\n        .setDefaultValue(Boolean.FALSE)\n        .setDynamic(false)\n        .setPlugin(HazelcastPlugin.PLUGIN_NAME)\n        .build();\n\n    private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);\n    public static final String PLUGIN_NAME = \"hazelcast\";\n\n    /**\n     * Keep serialization strategy the server was using before we set our strategy. We will\n     * restore old strategy when plugin is unloaded.\n     */\n    private ExternalizableUtilStrategy serializationStrategy;\n\n    /**\n     * Storage for cache statistics\n     */\n    private static Map<String, Map<String, long[]>> cacheStats;\n\n    private static HazelcastInstance hazelcast = null;\n    private static Cluster cluster = null;\n    private ClusterListener clusterListener;\n    private String lifecycleListener;\n    private String membershipListener;\n\n    /**\n     * Keeps that running state. Initial state is stopped.\n     */\n    private State state = State.stopped;\n\n    /**\n     * Used to limit the amount of duplicate warnings logged.\n     */\n    private final Cache<String, Instant> pluginClassLoaderWarnings;\n\n    public ClusteredCacheFactory() {\n        pluginClassLoaderWarnings = CacheFactory.createLocalCache(\"PluginClassLoader Warnings for Clustered Tasks\");\n        pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.\n    }\n\n    @Override\n    public boolean startCluster() {\n        logger.info(\"Starting hazelcast clustering\");\n        state = State.starting;\n\n        // Set the serialization strategy to use for transmitting objects between node clusters\n        serializationStrategy = ExternalizableUtil.getInstance().getStrategy();\n        ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());\n\n        // Store previous class loader (in case we change it)\n        final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();\n        final ClassLoader loader = new ClusterClassLoader();\n        Thread.currentThread().setContextClassLoader(loader);\n        int retry = 0;\n        do {\n            try {\n                final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());\n                final NetworkConfig networkConfig = config.getNetworkConfig();\n                if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {\n                    networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));\n                }\n                if (!HAZELCAST_REST_ENABLED.getValue()) {\n                    networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));\n                }\n                final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());\n                memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());\n                config.setInstanceName(\"openfire\");\n                config.setClassLoader(loader);\n                if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {\n                    config.setProperty(\"hazelcast.jmx\", \"true\");\n                    config.setProperty(\"hazelcast.jmx.detailed\", \"true\");\n                }\n                hazelcast = Hazelcast.newHazelcastInstance(config);\n                cluster = hazelcast.getCluster();\n                state = State.started;\n                // CacheFactory is now using clustered caches. We can add our listeners.\n                clusterListener = new ClusterListener(cluster);\n                clusterListener.joinCluster();\n                lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);\n                membershipListener = cluster.addMembershipListener(clusterListener);\n                logger.info(\"Hazelcast clustering started\");\n                break;\n            } catch (final Exception e) {\n                cluster = null;\n                if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {\n                    logger.warn(\"Failed to start clustering (\" + e.getMessage() + \"); \" +\n                        \"will retry in \" + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));\n                    try {\n                        Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());\n                    } catch (final InterruptedException ignored) {\n                        Thread.currentThread().interrupt();\n                    }\n                } else {\n                    logger.error(\"Unable to start clustering - continuing in local mode\", e);\n                    state = State.stopped;\n                }\n            }\n        } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());\n\n        if (oldLoader != null) {\n            // Restore previous class loader\n            Thread.currentThread().setContextClassLoader(oldLoader);\n        }\n        return cluster != null;\n    }\n\n    @Override\n    public void stopCluster() {\n        // Stop the cache services.\n        cacheStats = null;\n        // Update the running state of the cluster\n        state = State.stopped;\n\n        // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the\n        // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache\n        fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));\n        // Stop the cluster\n        hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);\n        cluster.removeMembershipListener(membershipListener);\n        Hazelcast.shutdownAll();\n        cluster = null;\n        lifecycleListener = null;\n        membershipListener = null;\n        clusterListener = null;\n\n        // Reset packet router to use to deliver packets to remote cluster nodes\n        XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);\n        // Reset the session locator to use\n        XMPPServer.getInstance().setRemoteSessionLocator(null);\n        // Set the old serialization strategy was using before clustering was loaded\n        ExternalizableUtil.getInstance().setStrategy(serializationStrategy);\n    }\n\n    @Override\n    public Cache createCache(final String name) {\n        // Check if cluster is being started up\n        while (state == State.starting) {\n            // Wait until cluster is fully started (or failed)\n            try {\n                Thread.sleep(250);\n            } catch (final InterruptedException e) {\n                // Ignore\n            }\n        }\n        if (state == State.stopped) {\n            throw new IllegalStateException(\"Cannot create clustered cache when not in a cluster\");\n        }\n        // Determine the time to live. Note that in Hazelcast 0 means \"forever\", not -1\n        final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);\n        final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);\n        // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes\n        final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);\n        final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);\n        // It's only possible to create a dynamic config if a static one doesn't already exist\n        final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);\n        if (staticConfig == null) {\n            final MapConfig dynamicConfig = new MapConfig(name);\n            dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);\n            dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));\n            logger.debug(\"Creating dynamic map config for cache={}, dynamicConfig={}\", name, dynamicConfig);\n            hazelcast.getConfig().addMapConfig(dynamicConfig);\n        } else {\n            logger.debug(\"Static configuration already exists for cache={}, staticConfig={}\", name, staticConfig);\n        }\n        // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning\n        @SuppressWarnings(\"unchecked\") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));\n        return clusteredCache;\n    }\n\n    @Override\n    public void destroyCache(Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n\n        final ClusteredCache clustered = (ClusteredCache) cache;\n        clustered.destroy();\n    }\n\n    @Override\n    public boolean isSeniorClusterMember() {\n        if (clusterListener == null || !clusterListener.isClusterMember()) {\n            return false;\n        }\n        return clusterListener.isSeniorClusterMember();\n    }\n\n    @Override\n    public List<ClusterNodeInfo> getClusterNodesInfo() {\n        return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();\n    }\n\n    @Override\n    public int getMaxClusterNodes() {\n        // No longer depends on license code so just return a big number\n        return 10000;\n    }\n\n    @Override\n    public byte[] getSeniorClusterMemberID() {\n        if (cluster != null && !cluster.getMembers().isEmpty()) {\n            final Member oldest = cluster.getMembers().iterator().next();\n            return getNodeID(oldest).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] getClusterMemberID() {\n        if (cluster != null) {\n            return getNodeID(cluster.getLocalMember()).toByteArray();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets the pseudo-synchronized time from the cluster. While the cluster members may\n     * have varying system times, this method is expected to return a timestamp that is\n     * synchronized (or nearly so; best effort) across the cluster.\n     *\n     * @return Synchronized time for all cluster members\n     */\n    @Override\n    public long getClusterTime() {\n        return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();\n    }\n\n    /*\n     * Execute the given task on the other (non-local) cluster members.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task) {\n\n        if (cluster == null) {\n            return;\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (!member.getUuid().equals(current.getUuid())) {\n                members.add(member);\n            }\n        }\n\n\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            logger.debug(\"Executing asynchronous MultiTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n    }\n\n    /*\n     * Execute the given task on the given cluster member.\n     * Note that this method does not provide the result set for the given\n     * task, as the task is run asynchronously across the cluster.\n     */\n    @Override\n    public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return;\n        }\n        final Member member = getMember(nodeID);\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing asynchronous DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n    }\n\n    /*\n     * Execute the given task on the designated cluster members.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) per member until the task is run on all members.\n     */\n    @Override\n    public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {\n        if (cluster == null) {\n            return Collections.emptyList();\n        }\n        final Set<Member> members = new HashSet<>();\n        final Member current = cluster.getLocalMember();\n        for (final Member member : cluster.getMembers()) {\n            if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {\n                members.add(member);\n            }\n        }\n        final Collection<T> result = new ArrayList<>();\n        if (!members.isEmpty()) {\n            // Asynchronously execute the task on the other cluster members\n            try {\n                logger.debug(\"Executing MultiTask: \" + task.getClass().getName());\n                checkForPluginClassLoader(task);\n                final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);\n                long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());\n                for (final Future<T> future : futures.values()) {\n                    final long start = System.nanoTime();\n                    result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));\n                    nanosLeft = nanosLeft - (System.nanoTime() - start);\n                }\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            logger.debug(\"No cluster members selected for cluster task \" + task.getClass().getName());\n        }\n        return result;\n    }\n\n    /*\n     * Execute the given task on the designated cluster member.\n     * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME\n     * (seconds) until the task is run on the given member.\n     */\n    @Override\n    public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        final Member member = getMember(nodeID);\n        T result = null;\n        // Check that the requested member was found\n        if (member != null) {\n            // Asynchronously execute the task on the target member\n            logger.debug(\"Executing DistributedTask: \" + task.getClass().getName());\n            checkForPluginClassLoader(task);\n            try {\n                final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);\n                result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);\n                logger.trace(\"DistributedTask result: {}\", result);\n            } catch (final TimeoutException te) {\n                logger.error(\"Failed to execute cluster task within \" + MAX_CLUSTER_EXECUTION_TIME + \" seconds\", te);\n            } catch (final Exception e) {\n                logger.error(\"Failed to execute cluster task\", e);\n            }\n        } else {\n            final String msg = MessageFormat.format(\"Requested node {0} not found in cluster\", new String(nodeID, StandardCharsets.UTF_8));\n            logger.warn(msg);\n            throw new IllegalArgumentException(msg);\n        }\n        return result;\n    }\n\n    @Override\n    public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {\n        if (cluster == null) {\n            return null;\n        }\n        ClusterNodeInfo result = null;\n        final Member member = getMember(nodeID);\n        if (member != null) {\n            result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());\n        }\n        return result;\n    }\n\n    private Member getMember(final byte[] nodeID) {\n        final NodeID memberToFind = NodeID.getInstance(nodeID);\n        for (final Member member : cluster.getMembers()) {\n            if (memberToFind.equals(getNodeID(member))) {\n                return member;\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public void updateCacheStats(final Map<String, Cache> caches) {\n        if (!caches.isEmpty() && cluster != null) {\n            // Create the cacheStats map if necessary.\n            if (cacheStats == null) {\n                cacheStats = hazelcast.getMap(\"opt-$cacheStats\");\n            }\n            final String uid = getNodeID(cluster.getLocalMember()).toString();\n            final Map<String, long[]> stats = new HashMap<>();\n            for (final String cacheName : caches.keySet()) {\n                final Cache cache = caches.get(cacheName);\n                // The following information is published:\n                // current size, max size, num elements, cache\n                // hits, cache misses.\n                final long[] info = new long[5];\n                info[0] = cache.getLongCacheSize();\n                info[1] = cache.getMaxCacheSize();\n                info[2] = cache.size();\n                info[3] = cache.getCacheHits();\n                info[4] = cache.getCacheMisses();\n                stats.put(cacheName, info);\n            }\n            // Publish message\n            cacheStats.put(uid, stats);\n        }\n    }\n\n    @Override\n    public String getPluginName() {\n        return PLUGIN_NAME;\n    }\n\n    @Override\n    public Lock getLock(final Object key, Cache cache) {\n        if (cache instanceof CacheWrapper) {\n            cache = ((CacheWrapper) cache).getWrappedCache();\n        }\n        // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)\n        @SuppressWarnings(\"unchecked\") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);\n        return clusterLock;\n    }\n\n    /**\n     * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class\n     * loading when the providing plugin is reloaded. This method verifies if an instance of a task is\n     * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is\n     * limited by a time interval.\n     *\n     * @param o the instance for which to verify the class loader\n     * @see <a href=\"https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74\">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>\n     */\n    protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {\n        if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader\n            && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )\n        {\n            // Try to determine what plugin loaded the offending class.\n            String pluginName = null;\n            try {\n                final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();\n                for (final Plugin plugin : plugins) {\n                    final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);\n                    if (o.getClass().getClassLoader().equals(pluginClassloader)) {\n                        pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);\n                        break;\n                    }\n                }\n            } catch (Exception e) {\n                logger.debug(\"An exception occurred while trying to determine the plugin class loader that loaded an instance of {}\", o.getClass(), e);\n            }\n            logger.warn(\"An instance of {} that is executed as a cluster task. This will cause issues when reloading \" +\n                    \"the plugin that provides this class. The plugin implementation should be modified.\",\n                pluginName != null ? o.getClass() + \" (provided by plugin \" + pluginName + \")\" : o.getClass());\n            pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.\n        }\n    }\n\n    private static class ClusterLock implements Lock {\n\n        private final Serializable key;\n        private final ClusteredCache<Serializable, ?> cache;\n\n        ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {\n            this.key = key;\n            this.cache = cache;\n        }\n\n        @Override\n        public void lock() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public void lockInterruptibly() {\n            cache.lock(key, -1);\n        }\n\n        @Override\n        public boolean tryLock() {\n            return cache.lock(key, 0);\n        }\n\n        @Override\n        public boolean tryLock(final long time, final TimeUnit unit) {\n            return cache.lock(key, unit.toMillis(time));\n        }\n\n        @Override\n        public void unlock() {\n            cache.unlock(key);\n        }\n\n        @Override\n        public Condition newCondition() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    private static class CallableTask<V> implements Callable<V>, Serializable {\n        private static final long serialVersionUID = -8761271979427214681L;\n        private final ClusterTask<V> task;\n\n        CallableTask(final ClusterTask<V> task) {\n            this.task = task;\n        }\n\n        @Override\n        public V call() {\n            try {\n                task.run();\n                logger.trace(\"CallableTask[{}] result: {}\", task.getClass().getName(), task.getResult());\n                return task.getResult();\n            } catch (final Exception e) {\n                logger.error(\"Unexpected exception running CallableTask[{}]\", task.getClass().getName(), e);\n                throw e;\n            }\n        }\n    }\n\n    private enum State {\n        stopped,\n        starting,\n        started\n    }\n\n    public static NodeID getNodeID(final Member member) {\n        return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));\n    }\n\n    static void fireLeftClusterAndWaitToComplete(final Duration timeout) {\n        final Semaphore leftClusterSemaphore = new Semaphore(0);\n        final ClusterEventListener clusterEventListener = new ClusterEventListener() {\n            @Override\n            public void joinedCluster() {\n            }\n\n            @Override\n            public void joinedCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void leftCluster() {\n                leftClusterSemaphore.release();\n            }\n\n            @Override\n            public void leftCluster(final byte[] bytes) {\n            }\n\n            @Override\n            public void markedAsSeniorClusterMember() {\n            }\n        };\n        try {\n            // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling\n            // has been invoked for all before proceeding.\n            ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);\n            logger.debug(\"Firing leftCluster() event\");\n            ClusterManager.fireLeftCluster();\n            logger.debug(\"Waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {\n                logger.warn(\"Timeout waiting for leftCluster() event to be called [timeout={}]\", StringUtils.getFullElapsedTime(timeout));\n            }\n        } catch (final Exception e) {\n            logger.error(\"Unexpected exception waiting for clustering to shut down\", e);\n        } finally {\n            ClusterManager.removeListener(clusterEventListener);\n        }\n    }\n\n}\n\n\n\n",
    "project": "openfire-hazelcast-plugin",
    "libraryName": "hazelcast",
    "libraryGroupID": "com.hazelcast",
    "newVersion": "5.1",
    "previousVersion": "3.12.5",
    "breakingCommit": "9545eb3a2687afc77b0a7da4d5d621807618d95c"
}