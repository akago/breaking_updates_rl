{
    "absolute_path_to_file_in_container": "/PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java",
    "errors": [
        {
            "line_number": 26,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol",
            "additional_info": "  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index",
            "file_name": "PGS_CirclePacking.java",
            "uid": "eee837df-a0d1-55dd-a231-7f4964b2c3ec"
        },
        {
            "line_number": 27,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol",
            "additional_info": "  symbol:   class PointEntryDist\n  location: package org.tinspin.index",
            "file_name": "PGS_CirclePacking.java",
            "uid": "9f78aeeb-e1bd-59ec-920b-1493da09f381"
        },
        {
            "line_number": 226,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol",
            "additional_info": "  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking",
            "file_name": "PGS_CirclePacking.java",
            "uid": "9063e6eb-b973-51da-896b-3ab642fae82f"
        },
        {
            "line_number": 645,
            "message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol",
            "additional_info": "  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking",
            "file_name": "PGS_CirclePacking.java",
            "uid": "78bf7ec6-ab95-55aa-800a-7f00ac8e7e56"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: tinspin-indexes 1.7.1->2.0.1\n\nthe following client code fails: \n'''java\npackage micycle.pgs;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\nimport micycle.pgs.commons.FrontChainPacker;\nimport micycle.pgs.commons.LargestEmptyCircles;\nimport micycle.pgs.commons.RepulsionCirclePack;\nimport micycle.pgs.commons.TangencyPack;\nimport org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;\nimport org.locationtech.jts.geom.Coordinate;\nimport org.locationtech.jts.geom.Envelope;\nimport org.locationtech.jts.geom.Geometry;\nimport org.locationtech.jts.geom.Location;\nimport org.locationtech.jts.geom.prep.PreparedGeometry;\nimport org.locationtech.jts.geom.prep.PreparedGeometryFactory;\nimport org.locationtech.jts.operation.distance.IndexedFacetDistance;\nimport org.locationtech.jts.util.GeometricShapeFactory;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinfour.common.SimpleTriangle;\nimport org.tinfour.common.Vertex;\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\nimport org.tinspin.index.covertree.CoverTree;\nimport processing.core.PShape;\nimport processing.core.PVector;\nimport static micycle.pgs.PGS_Conversion.fromPShape;\npublic final class PGS_CirclePacking {\n    private PGS_CirclePacking() {\n    }\n\n    public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {\n        final Geometry geometry = fromPShape(shape);\n        LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry, areaCoverRatio > 0.95 ? 0.5 : 1);\n        final double shapeArea = geometry.getArea();\n        double circlesArea = 0;\n        List<PVector> circles = new ArrayList<>();\n        while ((circlesArea / shapeArea) < areaCoverRatio) {\n            double[] currentLEC = lec.findNextLEC();\n            circles.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            circlesArea += (Math.PI * currentLEC[2]) * currentLEC[2];\n            if (currentLEC[2] < 0.5) {\n                break;\n            }\n        } \n        return circles;\n    }\n\n    public static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {\n        final List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);\n        final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);\n        return StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t)).collect(Collectors.toList());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {\n        return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints, long seed) {\n        final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);\n        final List<PVector> out = new ArrayList<>();\n        List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);\n        if (triangulatePoints) {\n            final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);\n            steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(PGS_CirclePacking::centroid).collect(Collectors.toList());\n        }\n        final List<PVector> vertices = PGS_Conversion.toPVector(shape);\n        Collections.shuffle(vertices);\n        vertices.forEach(p -> tree.insert(new double[]{ p.x, p.y, 0 }, p));\n        float largestR = 0;\n        for (PVector p : steinerPoints) {\n            final PointEntryDist<PVector> nn = tree.query1NN(new double[]{ p.x, p.y, largestR });\n            final float dx = p.x - nn.value().x;\n            final float dy = p.y - nn.value().y;\n            final float radius = ((float) (Math.sqrt((dx * dx) + (dy * dy)) - nn.value().z));\n            if (radius > minRadius) {\n                largestR = (radius >= largestR) ? radius : largestR;\n                p.z = radius;\n                tree.insert(new double[]{ p.x, p.y, radius }, p);\n                out.add(p);\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {\n        radiusMin = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        radiusMax = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        IndexedPointInAreaLocator pointLocator;\n        final FrontChainPacker packer = new FrontChainPacker(((float) (e.getWidth())), ((float) (e.getHeight())), ((float) (radiusMin)), ((float) (radiusMax)), ((float) (e.getMinX())), ((float) (e.getMinY())));\n        if (radiusMin == radiusMax) {\n            pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n            packer.getCircles().removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            pointLocator = new IndexedPointInAreaLocator(g);\n            final PreparedGeometry cache = PreparedGeometryFactory.prepare(g);\n            final GeometricShapeFactory circleFactory = new GeometricShapeFactory();\n            circleFactory.setNumPoints(8);\n            packer.getCircles().removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                circleFactory.setCentre(PGS.coordFromPVector(p));\n                circleFactory.setSize(p.z * 2);\n                return !cache.intersects(circleFactory.createCircle());\n            });\n        }\n        return packer.getCircles();\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, int n, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        final List<PVector> out = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            double[] c = mics.findNextLEC();\n            out.add(new PVector(((float) (c[0])), ((float) (c[1])), ((float) (c[2]))));\n        }\n        return out;\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, double minRadius, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        minRadius = Math.max(0.01, minRadius);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        final List<PVector> out = new ArrayList<>();\n        double[] currentLEC;\n        do {\n            currentLEC = mics.findNextLEC();\n            if (currentLEC[2] >= minRadius) {\n                out.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            }\n        } while (currentLEC[2] >= minRadius );\n        return out;\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {\n        final double rMinA = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        final double rMaxA = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        double totalArea = e.getArea() * 0.85;\n        double avgCircleArea = ((rMaxA * rMaxA) * rMaxA) - ((rMinA * rMinA) * rMinA);\n        avgCircleArea *= Math.PI / (3 * (rMaxA - rMinA));\n        int n = ((int) (totalArea / avgCircleArea));\n        List<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n, seed);\n        SplittableRandom r = new SplittableRandom(seed);\n        points.forEach(p -> p.z = (rMaxA == rMinA) ? ((float) (rMaxA)) : ((float) (r.nextDouble(rMinA, rMaxA))));\n        return repulsionPack(shape, points);\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        float radiusMin = Float.MAX_VALUE;\n        float radiusMax = Float.MIN_VALUE;\n        for (PVector circle : circles) {\n            radiusMax = Math.max(1.0F, Math.max(radiusMax, circle.z));\n            radiusMin = Math.max(1.0F, Math.min(radiusMin, circle.z));\n        }\n        final RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin, e.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);\n        final List<PVector> packing = packer.getPacking();\n        IndexedPointInAreaLocator pointLocator;\n        if (radiusMin == radiusMax) {\n            pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n            packing.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            pointLocator = new IndexedPointInAreaLocator(g);\n            IndexedFacetDistance distIndex = new IndexedFacetDistance(g);\n            packing.removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                return distIndex.distance(PGS.pointFromPVector(p)) > (p.z * 0.5);\n            });\n        }\n        return packing;\n    }\n\n    public static List<PVector> squareLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        final double radius = diameter / 2;\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        final double w = (e.getWidth() + diameter) + e.getMinX();\n        final double h = (e.getHeight() + diameter) + e.getMinY();\n        final List<PVector> out = new ArrayList<>();\n        for (double x = e.getMinX(); x < w; x += diameter) {\n            for (double y = e.getMinY(); y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> hexLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        final double radius = diameter / 2.0;\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        final double w = (e.getWidth() + diameter) + e.getMinX();\n        final double h = (e.getHeight() + diameter) + e.getMinY();\n        final List<PVector> out = new ArrayList<>();\n        final double z = radius * Math.sqrt(3);\n        double offset = 0;\n        for (double x = e.getMinX(); x < w; x += z) {\n            offset = (offset == radius) ? 0 : radius;\n            for (double y = e.getMinY() - offset; y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    private static PVector inCircle(SimpleTriangle t) {\n        final double a = t.getEdgeA().getLength();\n        final double b = t.getEdgeB().getLength();\n        final double c = t.getEdgeC().getLength();\n        double inCenterX = ((t.getVertexA().x * a) + (t.getVertexB().x * b)) + (t.getVertexC().x * c);\n        inCenterX /= (a + b) + c;\n        double inCenterY = ((t.getVertexA().y * a) + (t.getVertexB().y * b)) + (t.getVertexC().y * c);\n        inCenterY /= (a + b) + c;\n        final double s = ((a + b) + c) / 2;\n        final double r = Math.sqrt((((s - a) * (s - b)) * (s - c)) / s);\n        return new PVector(((float) (inCenterX)), ((float) (inCenterY)), ((float) (r)));\n    }\n\n    private static PVector centroid(SimpleTriangle t) {\n        final Vertex a = t.getVertexA();\n        final Vertex b = t.getVertexB();\n        final Vertex c = t.getVertexC();\n        double x = (a.x + b.x) + c.x;\n        x /= 3;\n        double y = (a.y + b.y) + c.y;\n        y /= 3;\n        return new PVector(((float) (x)), ((float) (y)));\n    }\n\n    private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\n        final double dx = p1[0] - p2[0];\n        final double dy = p1[1] - p2[1];\n        final double dz = p1[2] - p2[2];\n        double euclideanDistance = Math.sqrt((dx * dx) + (dy * dy));\n        double absZDifference = Math.abs(dz);\n        return euclideanDistance + absZDifference;\n    };\n\n    private static final Predicate<SimpleTriangle> filterBorderTriangles = t -> (((t.getContainingRegion() != null) && (!t.getEdgeA().isConstrainedRegionBorder())) && (!t.getEdgeB().isConstrainedRegionBorder())) && (!t.getEdgeC().isConstrainedRegionBorder());\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\nwith the following error message:\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol  symbol:   class PointEntryDist\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.tinspin.index.PointEntryDist | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.PointIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.main | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.kdtree.KDTree.nnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.PointIndexWrapper | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.knnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.next | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointIndex | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.query | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree.create | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointDistanceFunction | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.RectangleIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.reset | DELETION | METHOD_REMOVED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "import org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\n\t\t\tfinal PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle\n\tprivate static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {",
    "error_message": "[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[26,25] cannot find symbol  symbol:   class PointDistanceFunction\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[27,25] cannot find symbol  symbol:   class PointEntryDist\n  location: package org.tinspin.index\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[226,31] cannot find symbol  symbol:   class PointEntryDist\n  location: class micycle.pgs.PGS_CirclePacking\n[ERROR] /PGS/src/main/java/micycle/pgs/PGS_CirclePacking.java:[645,30] cannot find symbol  symbol:   class PointDistanceFunction\n  location: class micycle.pgs.PGS_CirclePacking",
    "api_diff": "Format: element | nature | kind\norg.tinspin.index.PointEntryDist | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.PointIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.queryKNN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.main | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.iterator | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.kdtree.KDTree.nnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.PointIndexWrapper | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.knnQuery | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.next | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointIndex | DELETION | TYPE_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.kdtree.KDTree | MUTATION | SUPERTYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.query | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.covertree.CoverTree.create | MUTATION | METHOD_RETURN_TYPE_CHANGED\norg.tinspin.index.PointDistanceFunction | DELETION | TYPE_REMOVED\norg.tinspin.index.kdtree.KDTree.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.rtree.RTreeQueryKnn.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.tinspin.index.covertree.CoverTree.containsExact | DELETION | METHOD_REMOVED\norg.tinspin.index.RectangleIndex.query1NN | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTree.create | DELETION | METHOD_REMOVED\norg.tinspin.index.covertree.CoverTreeQueryKnn.reset | DELETION | METHOD_REMOVED",
    "original_code": "package micycle.pgs;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\nimport micycle.pgs.commons.FrontChainPacker;\nimport micycle.pgs.commons.LargestEmptyCircles;\nimport micycle.pgs.commons.RepulsionCirclePack;\nimport micycle.pgs.commons.TangencyPack;\nimport org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;\nimport org.locationtech.jts.geom.Coordinate;\nimport org.locationtech.jts.geom.Envelope;\nimport org.locationtech.jts.geom.Geometry;\nimport org.locationtech.jts.geom.Location;\nimport org.locationtech.jts.geom.prep.PreparedGeometry;\nimport org.locationtech.jts.geom.prep.PreparedGeometryFactory;\nimport org.locationtech.jts.operation.distance.IndexedFacetDistance;\nimport org.locationtech.jts.util.GeometricShapeFactory;\nimport org.tinfour.common.IIncrementalTin;\nimport org.tinfour.common.SimpleTriangle;\nimport org.tinfour.common.Vertex;\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\nimport org.tinspin.index.covertree.CoverTree;\nimport processing.core.PShape;\nimport processing.core.PVector;\nimport static micycle.pgs.PGS_Conversion.fromPShape;\npublic final class PGS_CirclePacking {\n    private PGS_CirclePacking() {\n    }\n\n    public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {\n        final Geometry geometry = fromPShape(shape);\n        LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry, areaCoverRatio > 0.95 ? 0.5 : 1);\n        final double shapeArea = geometry.getArea();\n        double circlesArea = 0;\n        List<PVector> circles = new ArrayList<>();\n        while ((circlesArea / shapeArea) < areaCoverRatio) {\n            double[] currentLEC = lec.findNextLEC();\n            circles.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            circlesArea += (Math.PI * currentLEC[2]) * currentLEC[2];\n            if (currentLEC[2] < 0.5) {\n                break;\n            }\n        } \n        return circles;\n    }\n\n    public static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {\n        final List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);\n        final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);\n        return StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t)).collect(Collectors.toList());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {\n        return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints, long seed) {\n        final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);\n        final List<PVector> out = new ArrayList<>();\n        List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);\n        if (triangulatePoints) {\n            final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);\n            steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(PGS_CirclePacking::centroid).collect(Collectors.toList());\n        }\n        final List<PVector> vertices = PGS_Conversion.toPVector(shape);\n        Collections.shuffle(vertices);\n        vertices.forEach(p -> tree.insert(new double[]{ p.x, p.y, 0 }, p));\n        float largestR = 0;\n        for (PVector p : steinerPoints) {\n            final PointEntryDist<PVector> nn = tree.query1NN(new double[]{ p.x, p.y, largestR });\n            final float dx = p.x - nn.value().x;\n            final float dy = p.y - nn.value().y;\n            final float radius = ((float) (Math.sqrt((dx * dx) + (dy * dy)) - nn.value().z));\n            if (radius > minRadius) {\n                largestR = (radius >= largestR) ? radius : largestR;\n                p.z = radius;\n                tree.insert(new double[]{ p.x, p.y, radius }, p);\n                out.add(p);\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {\n        radiusMin = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        radiusMax = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        IndexedPointInAreaLocator pointLocator;\n        final FrontChainPacker packer = new FrontChainPacker(((float) (e.getWidth())), ((float) (e.getHeight())), ((float) (radiusMin)), ((float) (radiusMax)), ((float) (e.getMinX())), ((float) (e.getMinY())));\n        if (radiusMin == radiusMax) {\n            pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n            packer.getCircles().removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            pointLocator = new IndexedPointInAreaLocator(g);\n            final PreparedGeometry cache = PreparedGeometryFactory.prepare(g);\n            final GeometricShapeFactory circleFactory = new GeometricShapeFactory();\n            circleFactory.setNumPoints(8);\n            packer.getCircles().removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                circleFactory.setCentre(PGS.coordFromPVector(p));\n                circleFactory.setSize(p.z * 2);\n                return !cache.intersects(circleFactory.createCircle());\n            });\n        }\n        return packer.getCircles();\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, int n, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        final List<PVector> out = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            double[] c = mics.findNextLEC();\n            out.add(new PVector(((float) (c[0])), ((float) (c[1])), ((float) (c[2]))));\n        }\n        return out;\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, double minRadius, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        minRadius = Math.max(0.01, minRadius);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        final List<PVector> out = new ArrayList<>();\n        double[] currentLEC;\n        do {\n            currentLEC = mics.findNextLEC();\n            if (currentLEC[2] >= minRadius) {\n                out.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            }\n        } while (currentLEC[2] >= minRadius );\n        return out;\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {\n        final double rMinA = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        final double rMaxA = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        double totalArea = e.getArea() * 0.85;\n        double avgCircleArea = ((rMaxA * rMaxA) * rMaxA) - ((rMinA * rMinA) * rMinA);\n        avgCircleArea *= Math.PI / (3 * (rMaxA - rMinA));\n        int n = ((int) (totalArea / avgCircleArea));\n        List<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n, seed);\n        SplittableRandom r = new SplittableRandom(seed);\n        points.forEach(p -> p.z = (rMaxA == rMinA) ? ((float) (rMaxA)) : ((float) (r.nextDouble(rMinA, rMaxA))));\n        return repulsionPack(shape, points);\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        float radiusMin = Float.MAX_VALUE;\n        float radiusMax = Float.MIN_VALUE;\n        for (PVector circle : circles) {\n            radiusMax = Math.max(1.0F, Math.max(radiusMax, circle.z));\n            radiusMin = Math.max(1.0F, Math.min(radiusMin, circle.z));\n        }\n        final RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin, e.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);\n        final List<PVector> packing = packer.getPacking();\n        IndexedPointInAreaLocator pointLocator;\n        if (radiusMin == radiusMax) {\n            pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n            packing.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            pointLocator = new IndexedPointInAreaLocator(g);\n            IndexedFacetDistance distIndex = new IndexedFacetDistance(g);\n            packing.removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                return distIndex.distance(PGS.pointFromPVector(p)) > (p.z * 0.5);\n            });\n        }\n        return packing;\n    }\n\n    public static List<PVector> squareLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        final double radius = diameter / 2;\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        final double w = (e.getWidth() + diameter) + e.getMinX();\n        final double h = (e.getHeight() + diameter) + e.getMinY();\n        final List<PVector> out = new ArrayList<>();\n        for (double x = e.getMinX(); x < w; x += diameter) {\n            for (double y = e.getMinY(); y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> hexLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        final double radius = diameter / 2.0;\n        final Geometry g = fromPShape(shape);\n        final Envelope e = g.getEnvelopeInternal();\n        final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        final double w = (e.getWidth() + diameter) + e.getMinX();\n        final double h = (e.getHeight() + diameter) + e.getMinY();\n        final List<PVector> out = new ArrayList<>();\n        final double z = radius * Math.sqrt(3);\n        double offset = 0;\n        for (double x = e.getMinX(); x < w; x += z) {\n            offset = (offset == radius) ? 0 : radius;\n            for (double y = e.getMinY() - offset; y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    private static PVector inCircle(SimpleTriangle t) {\n        final double a = t.getEdgeA().getLength();\n        final double b = t.getEdgeB().getLength();\n        final double c = t.getEdgeC().getLength();\n        double inCenterX = ((t.getVertexA().x * a) + (t.getVertexB().x * b)) + (t.getVertexC().x * c);\n        inCenterX /= (a + b) + c;\n        double inCenterY = ((t.getVertexA().y * a) + (t.getVertexB().y * b)) + (t.getVertexC().y * c);\n        inCenterY /= (a + b) + c;\n        final double s = ((a + b) + c) / 2;\n        final double r = Math.sqrt((((s - a) * (s - b)) * (s - c)) / s);\n        return new PVector(((float) (inCenterX)), ((float) (inCenterY)), ((float) (r)));\n    }\n\n    private static PVector centroid(SimpleTriangle t) {\n        final Vertex a = t.getVertexA();\n        final Vertex b = t.getVertexB();\n        final Vertex c = t.getVertexC();\n        double x = (a.x + b.x) + c.x;\n        x /= 3;\n        double y = (a.y + b.y) + c.y;\n        y /= 3;\n        return new PVector(((float) (x)), ((float) (y)));\n    }\n\n    private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\n        final double dx = p1[0] - p2[0];\n        final double dy = p1[1] - p2[1];\n        final double dz = p1[2] - p2[2];\n        double euclideanDistance = Math.sqrt((dx * dx) + (dy * dy));\n        double absZDifference = Math.abs(dz);\n        return euclideanDistance + absZDifference;\n    };\n\n    private static final Predicate<SimpleTriangle> filterBorderTriangles = t -> (((t.getContainingRegion() != null) && (!t.getEdgeA().isConstrainedRegionBorder())) && (!t.getEdgeB().isConstrainedRegionBorder())) && (!t.getEdgeC().isConstrainedRegionBorder());\n}\n",
    "project": "PGS",
    "libraryName": "tinspin-indexes",
    "libraryGroupID": "org.tinspin",
    "newVersion": "2.0.1",
    "previousVersion": "1.7.1",
    "breakingCommit": "e70bd198fa1e1d65f86e071b8ebdd021141cfa95",
    "patch": "```java\npackage micycle.pgs;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SplittableRandom;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.StreamSupport;\nimport micycle.pgs.commons.FrontChainPacker;\nimport micycle.pgs.commons.LargestEmptyCircles;\nimport micycle.pgs.commons.RepulsionCirclePack;\nimport micycle.pgs.commons.TangencyPack;\nimport org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;\nimport org.locationtech.jts.geom.Coordinate;\nimport org.locationtech.jts.geom.Envelope;\nimport org.locationtech.jts.geom.Geometry;\nimport org.locationtech.jts.geom.Location;\nimport org.locationtech.jts.geom.prep.PreparedGeometry;\nimport org.locationtech.jts.geom.prep.PreparedGeometryFactory;\nimport org.locationtech.jts.operation.distance.IndexedFacetDistance;\nimport org.tinspin.index.PointDistanceFunction;\nimport org.tinspin.index.PointEntryDist;\nimport org.tinspin.index.covertree.CoverTree;\nimport processing.core.PShape;\nimport processing.core.PVector;\nimport static micycle.pgs.PGS_Conversion.fromPShape;\npublic final class PGS_CirclePacking {\n    private PGS_CirclePacking() {\n    }\n\n    public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {\n        final Geometry geometry = fromPShape(shape);\n        LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry, areaCoverRatio > 0.95 ? 0.5 : 1);\n        final double shapeArea = geometry.getArea();\n        double circlesArea = 0;\n        List<PVector> circles = new ArrayList<>();\n        while ((circlesArea / shapeArea) < areaCoverRatio) {\n            double[] currentLEC = lec.findNextLEC();\n            circles.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            circlesArea += (Math.PI * currentLEC[2]) * currentLEC[2];\n            if (currentLEC[2] < 0.5) {\n                break;\n            }\n        }\n        return circles;\n    }\n\n    public static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {\n        final List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);\n        final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);\n        return StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t)).collect(Collectors.toList());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {\n        return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());\n    }\n\n    public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints, long seed) {\n        PointDistanceFunction circleDistanceMetric = p1 -> p2 -> {\n            double dx = p1[0] - p2[0];\n            double dy = p1[1] - p2[1];\n            double dz = p1[2] - p2[2];\n            return Math.sqrt((dx * dx) + (dy * dy)) + dz;\n        };\n        CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);\n        List<PVector> out = new ArrayList<>();\n        List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);\n        if (triangulatePoints) {\n            final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);\n            steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(PGS_CirclePacking::centroid).collect(Collectors.toList());\n        }\n        List<PVector> vertices = PGS_Conversion.toPVector(shape);\n        Collections.shuffle(vertices);\n        vertices.forEach(p -> tree.insert(new double[]{ p.x, p.y, 0 }, p));\n        float largestR = 0;\n        for (PVector p : steinerPoints) {\n            PointEntryDist<PVector> nn = tree.query1NN(new double[]{ p.x, p.y, largestR });\n            float dx = (float) (p.x - nn.value().x);\n            float dy = (float) (p.y - nn.value().y);\n            float radius = (float) ((Math.sqrt((dx * dx) + (dy * dy)) - nn.value().z));\n            if (radius > minRadius) {\n                largestR = (radius >= largestR) ? radius : largestR;\n                p.z = radius;\n                tree.insert(new double[]{ p.x, p.y, radius }, p);\n                out.add(p);\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {\n        radiusMin = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        radiusMax = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        Geometry g = fromPShape(shape);\n        Envelope e = g.getEnvelopeInternal();\n        IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n        FrontChainPacker packer = new FrontChainPacker(((float) (e.getWidth())), ((float) (e.getHeight())), ((float) (radiusMin)), ((float) (radiusMax)), ((float) (e.getMinX())), ((float) (e.getMinY())));\n        if (radiusMin == radiusMax) {\n            packer.getCircles().removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            packer.getCircles().removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                return false;\n            });\n        }\n        return packer.getCircles();\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, int n, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        List<PVector> out = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            double[] c = mics.findNextLEC();\n            out.add(new PVector(((float) (c[0])), ((float) (c[1])), ((float) (c[2]))));\n        }\n        return out;\n    }\n\n    public static List<PVector> maximumInscribedPack(PShape shape, double minRadius, double tolerance) {\n        tolerance = Math.max(0.01, tolerance);\n        minRadius = Math.max(0.01, minRadius);\n        LargestEmptyCircles mics = new LargestEmptyCircles(fromPShape(shape), null, tolerance);\n        List<PVector> out = new ArrayList<>();\n        double[] currentLEC;\n        do {\n            currentLEC = mics.findNextLEC();\n            if (currentLEC[2] >= minRadius) {\n                out.add(new PVector(((float) (currentLEC[0])), ((float) (currentLEC[1])), ((float) (currentLEC[2]))));\n            }\n        } while (currentLEC[2] >= minRadius);\n        return out;\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {\n        TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);\n        return pack.pack();\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {\n        double rMinA = Math.max(1.0F, Math.min(radiusMin, radiusMax));\n        double rMaxA = Math.max(1.0F, Math.max(radiusMin, radiusMax));\n        Geometry g = fromPShape(shape);\n        Envelope e = g.getEnvelopeInternal();\n        double totalArea = e.getArea() * 0.85;\n        double avgCircleArea = ((rMaxA * rMaxA) * rMaxA) - ((rMinA * rMinA) * rMinA);\n        avgCircleArea *= Math.PI / (3 * (rMaxA - rMinA));\n        int n = (int) Math.round(totalArea / avgCircleArea);\n        List<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n, seed);\n        SplittableRandom r = new SplittableRandom(seed);\n        points.forEach(p -> p.z = (rMaxA == rMinA) ? (float) rMaxA : (float) (r.nextDouble(rMinA, rMaxA)));\n        return repulsionPack(shape, points);\n    }\n\n    public static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {\n        Geometry g = fromPShape(shape);\n        Envelope e = g.getEnvelopeInternal();\n        float radiusMin = Float.MAX_VALUE;\n        float radiusMax = Float.MIN_VALUE;\n        for (PVector circle : circles) {\n            radiusMax = Math.max(1.0F, Math.max(radiusMax, circle.z));\n            radiusMin = Math.max(1.0F, Math.min(radiusMin, circle.z));\n        }\n        RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin, e.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);\n        List<PVector> packing = packer.getPacking();\n        IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));\n        if (radiusMin == radiusMax) {\n            packing.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);\n        } else {\n            packing.removeIf(p -> {\n                if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {\n                    return false;\n                }\n                return false;\n            });\n        }\n        return packing;\n    }\n\n    public static List<PVector> squareLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        double radius = diameter / 2.0;\n        Geometry g = fromPShape(shape);\n        Envelope e = g.getEnvelopeInternal();\n        IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        double w = (e.getWidth() + diameter) + e.getMinX();\n        double h = (e.getHeight() + diameter) + e.getMinY();\n        List<PVector> out = new ArrayList<>();\n        double z = radius * Math.sqrt(3);\n        double offset = 0;\n        for (double x = e.getMinX(); x < w; x += z) {\n            offset = (offset == radius) ? 0 : radius;\n            for (double y = e.getMinY() - offset; y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    public static List<PVector> hexLatticePack(PShape shape, double diameter) {\n        diameter = Math.max(diameter, 0.1);\n        double radius = diameter / 2.0;\n        Geometry g = fromPShape(shape);\n        Envelope e = g.getEnvelopeInternal();\n        IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));\n        double w = (e.getWidth() + diameter) + e.getMinX();\n        double h = (e.getHeight() + diameter) + e.getMinY();\n        List<PVector> out = new ArrayList<>();\n        double xOffset = radius;\n        double yOffset = radius * Math.sqrt(3);\n        for (double x = e.getMinX(); x < w; x += xOffset) {\n            for (double y = e.getMinY() - yOffset; y < h; y += diameter) {\n                if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {\n                    out.add(new PVector(((float) (x)), ((float) (y)), ((float) (radius))));\n                }\n            }\n        }\n        return out;\n    }\n\n    private static PVector inCircle(SimpleTriangle t) {\n        double a = t.getEdgeA().getLength();\n        double b = t.getEdgeB().getLength();\n        double c = t.getEdgeC().getLength();\n        double inCenterX = ((t.getVertexA().x * a) + (t.getVertexB().x * b)) + (t.getVertexC().x * c) / (a + b + c);\n        double inCenterY = ((t.getVertexA().y * a) + (t.getVertexB().y * b)) + (t.getVertexC().y * c) / (a + b + c);\n        double s = ((a + b) + c) / 2;\n        double r = Math.sqrt((((s - a) * (s - b)) * (s - c)) / s);\n        return new PVector(((float) (inCenterX)), ((float) (inCenterY)), ((float) (r)));\n    }\n\n    private static PVector centroid(SimpleTriangle t) {\n        Vertex a = t.getVertexA();\n        Vertex b = t.getVertexB();\n        Vertex c = t.getVertexC();\n        double x = (a.x + b.x + c.x) / 3;\n        double y = (a.y + b.y + c.y) / 3;\n        return new PVector(((float) (x)), ((float) (y)));\n    }\n\n    private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {\n        double dx = p1[0] - p2[0];\n        double dy = p1[1] - p2[1];\n        double dz = p1[2] - p2[2];\n        double euclideanDistance = Math.sqrt((dx * dx) + (dy * dy));\n        double absZDifference = Math.abs(dz);\n        return euclideanDistance + absZDifference;\n    };\n\n    private static final Predicate<SimpleTriangle> filterBorderTriangles = t -> ((t.getContainingRegion() != null) && (!t.getEdgeA().isConstrainedRegionBorder())) && (!t.getEdgeB().isConstrainedRegionBorder()) && (!t.getEdgeC().isConstrainedRegionBorder());\n}\n```<end_of_turn>"
}