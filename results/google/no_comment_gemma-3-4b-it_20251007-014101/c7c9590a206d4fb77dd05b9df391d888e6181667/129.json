{
    "absolute_path_to_file_in_container": "/scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java",
    "errors": [
        {
            "line_number": 32,
            "message": "[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist",
            "additional_info": "",
            "file_name": "SCoverageReportMojo.java",
            "uid": "b6d6c3d6-293b-5748-be9a-19048f825fad"
        },
        {
            "line_number": 385,
            "message": "[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[385,13] cannot find symbol",
            "additional_info": "  symbol:   class RenderingContext\n  location: class org.scoverage.plugin.SCoverageReportMojo",
            "file_name": "SCoverageReportMojo.java",
            "uid": "c604f6d4-d750-5bff-84b0-1518b71f30c5"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: doxia-site-renderer 1.0->1.11.1\n\nthe following client code fails: \n'''java\npackage org.scoverage.plugin;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala.collection.Set;\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.IOUtils;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\nimport scoverage.serialize.Serializer;\n@Mojo(name = \"report\", threadSafe = false)\n@Execute(lifecycle = \"scoverage\", phase = LifecyclePhase.TEST)\npublic class SCoverageReportMojo extends AbstractMojo implements MavenReport {\n    @Parameter(property = \"scoverage.skip\", defaultValue = \"false\")\n    private boolean skip;\n\n    @Parameter(property = \"scoverage.aggregate\", defaultValue = \"false\")\n    private boolean aggregate;\n\n    @Parameter(property = \"scoverage.aggregateOnly\", defaultValue = \"false\")\n    private boolean aggregateOnly;\n\n    @Parameter(property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n    private String encoding;\n\n    @Parameter(property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true)\n    private boolean failOnError;\n\n    @Parameter(defaultValue = \"${project}\", readonly = true, required = true)\n    private MavenProject project;\n\n    @Parameter(defaultValue = \"${reactorProjects}\", required = true, readonly = true)\n    private List<MavenProject> reactorProjects;\n\n    @Parameter(property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true)\n    private File dataDirectory;\n\n    @Parameter(property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true)\n    private File outputDirectory;\n\n    @Parameter(property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true)\n    private File xmlOutputDirectory;\n\n    @Parameter(property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true)\n    private String destDir;\n\n    @Parameter(property = \"name\", readonly = true)\n    private String name;\n\n    @Parameter(property = \"description\", readonly = true)\n    private String description;\n\n    @Override\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return getBundle(locale).getString(\"report.scoverage.name\");\n        }\n        return name;\n    }\n\n    @Override\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return getBundle(locale).getString(\"report.scoverage.description\");\n        }\n        return description;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n        if (canAttachAggregatedReportToSite && (!(canGenerateNonAggregatedReport || canGenerateAggregatedReport))) {\n            return;\n        }\n        try {\n            long ts = System.currentTimeMillis();\n            if (canGenerateNonAggregatedReport) {\n                generateReports();\n            }\n            if (canGenerateAggregatedReport) {\n                generateAggregatedReports();\n            }\n            long te = System.currentTimeMillis();\n            getLog().debug(String.format(\"Mojo execution time: %d ms\", te - ts));\n        } catch (MavenReportException e) {\n            if (failOnError) {\n                throw e;\n            }\n            getLog().error(\"Error while creating scoverage report: \" + e.getMessage(), e);\n        } catch (RuntimeException e) {\n            if (failOnError) {\n                throw new MavenReportException(\"Report generation exception\", e);\n            }\n            getLog().error(\"Error while creating scoverage report: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public String getOutputName() {\n        return destDir + \"/index\";\n    }\n\n    @Override\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    @Override\n    public boolean canGenerateReport() {\n        if ((!skip) && (!\"pom\".equals(project.getPackaging()))) {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit(project, reactorProjects);\n        }\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite;\n        if ((!result) && canGenerateAggregatedReport()) {\n            try {\n                generateAggregatedReports();\n            } catch (MavenReportException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport() {\n        if (skip) {\n            return false;\n        }\n        if (\"pom\".equals(project.getPackaging())) {\n            return false;\n        }\n        if (aggregateOnly && (reactorProjects.size() > 1)) {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile(dataDirectory);\n        if ((!coverageFile.exists()) || (!coverageFile.isFile())) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport() {\n        return ((aggregate || aggregateOnly) && (reactorProjects.size() > 1)) && (project == reactorProjects.get(reactorProjects.size() - 1));\n    }\n\n    private boolean canAttachAggregatedReportToSite() {\n        return ((aggregate || aggregateOnly) && (reactorProjects.size() > 1)) && project.isExecutionRoot();\n    }\n\n    @Override\n    public String getCategoryName() {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    @Override\n    public File getReportOutputDirectory() {\n        return outputDirectory;\n    }\n\n    @Override\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        updateReportOutputDirectory(reportOutputDirectory);\n    }\n\n    private void updateReportOutputDirectory(File reportOutputDirectory) {\n        if (((reportOutputDirectory != null) && (destDir != null)) && (!reportOutputDirectory.getAbsolutePath().endsWith(destDir))) {\n            this.outputDirectory = new File(reportOutputDirectory, destDir);\n        } else {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException {\n        if (!canGenerateReport()) {\n            getLog().info(\"Skipping SCoverage report generation\");\n            return;\n        }\n        try {\n            RenderingContext context = new RenderingContext(outputDirectory, getOutputName() + \".html\");\n            SiteRendererSink sink = new SiteRendererSink(context);\n            Locale locale = Locale.getDefault();\n            generate(sink, locale);\n        } catch (MavenReportException e) {\n            String prefix = (\"An error has occurred in \" + getName(Locale.ENGLISH)) + \" report generation\";\n            throw new MojoExecutionException((prefix + \": \") + e.getMessage(), e);\n        }\n    }\n\n    private ResourceBundle getBundle(Locale locale) {\n        return ResourceBundle.getBundle(\"scoverage-report\", locale, getClass().getClassLoader());\n    }\n\n    private void generateReports() throws MavenReportException {\n        @SuppressWarnings(\"unchecked\")\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>(sourceDirs.size());\n        for (String dir : sourceDirs) {\n            sourceRoots.add(new File(dir));\n        }\n        mkdirs(outputDirectory);\n        mkdirs(xmlOutputDirectory);\n        File coverageFile = Serializer.coverageFile(dataDirectory);\n        getLog().info(String.format(\"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath()));\n        Coverage coverage = Serializer.deserialize(coverageFile, project.getBasedir());\n        getLog().info(String.format(\"Reading scoverage measurements [%s*]...\", new File(dataDirectory, Constants.MeasurementsPrefix()).getAbsolutePath()));\n        List<File> measurementFiles = Arrays.asList(IOUtils.findMeasurementFiles(dataDirectory));\n        Set<Tuple2<Object, String>> measurements = IOUtils.invoked(CollectionConverters.asScala(measurementFiles).toSeq(), encoding);\n        coverage.apply(measurements);\n        getLog().info(\"Generating coverage reports...\");\n        writeReports(coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory);\n        getLog().info(\"Coverage reports completed.\");\n    }\n\n    private void generateAggregatedReports() throws MavenReportException {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for (MavenProject module : reactorProjects) {\n            if (module.isExecutionRoot()) {\n                topLevelModule = module;\n            } else if (!module.getPackaging().equals(\"pom\")) {\n                File scoverageDataDir = rebase(dataDirectory, module);\n                if (scoverageDataDir.isDirectory()) {\n                    scoverageDataDirs.add(scoverageDataDir);\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList(IOUtils.findMeasurementFiles(scoverageDataDir));\n                        Set<Tuple2<Object, String>> measurements = IOUtils.invoked(CollectionConverters.asScala(measurementFiles).toSeq(), encoding);\n                        subCoverage.apply(measurements);\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(statement.location(), statementId, statement.start(), statement.end(), statement.line(), statement.desc(), statement.symbolName(), statement.treeName(), statement.branch(), statement.count(), statement.ignored(), statement.tests());\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n                    File sourceRootsFile = new File(scoverageDataDir, \"source.roots\");\n                    if (sourceRootsFile.isFile()) {\n                        try {\n                            BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(sourceRootsFile), \"UTF-8\"));\n                            try {\n                                String path = r.readLine();\n                                while (path != null) {\n                                    sourceRoots.add(new File(path));\n                                    path = r.readLine();\n                                } \n                            } finally {\n                                r.close();\n                            }\n                        } catch (IOException e) {\n                            throw new MavenReportException(\"...\", e);\n                        }\n                    }\n                }\n            }\n        }\n        if (getLog().isDebugEnabled() && (scoverageDataDirs.size() > 0)) {\n            getLog().debug(String.format(\"Found %d subproject subproject scoverage data directories:\", scoverageDataDirs.size()));\n            for (File dataDir : scoverageDataDirs) {\n                getLog().debug(String.format(\"- %s\", dataDir.getAbsolutePath()));\n            }\n        } else {\n            getLog().info(String.format(\"Found %d subproject scoverage data directories.\", scoverageDataDirs.size()));\n        }\n        File topLevelModuleOutputDirectory = rebase(outputDirectory, topLevelModule);\n        File topLevelModuleXmlOutputDirectory = rebase(xmlOutputDirectory, topLevelModule);\n        mkdirs(topLevelModuleOutputDirectory);\n        mkdirs(topLevelModuleXmlOutputDirectory);\n        getLog().info(\"Generating coverage aggregated reports...\");\n        writeReports(coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory, topLevelModuleOutputDirectory);\n        getLog().info(\"Coverage aggregated reports completed.\");\n    }\n\n    private void writeReports(Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory, File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory) {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala(sourceRoots).toSeq();\n        new CoberturaXmlWriter(sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written Cobertura XML report [%s]\", new File(coberturaXmlOutputDirectory, \"cobertura.xml\").getAbsolutePath()));\n        new ScoverageXmlWriter(sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written XML coverage report [%s]\", new File(scoverageXmlOutputDirectory, \"scoverage.xml\").getAbsolutePath()));\n        new ScoverageHtmlWriter(sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written HTML coverage report [%s]\", new File(scoverageHtmlOutputDirectory, \"index.html\").getAbsolutePath()));\n        getLog().info(String.format(\"Statement coverage.: %s%%\", coverage.statementCoverageFormatted()));\n        getLog().info(String.format(\"Branch coverage....: %s%%\", coverage.branchCoverageFormatted()));\n    }\n\n    private void mkdirs(File directory) throws MavenReportException {\n        if ((!directory.exists()) && (!directory.mkdirs())) {\n            throw new MavenReportException(String.format(\"Cannot create \\\"%s\\\" directory \", directory.getAbsolutePath()));\n        } else if (directory.exists() && (!directory.isDirectory())) {\n            throw new MavenReportException(String.format(\"Directory \\\"%s\\\" exists but is not a directory \", directory.getAbsolutePath()));\n        }\n    }\n\n    private File rebase(File file, MavenProject otherModule) {\n        return new File(file.getAbsolutePath().replace(project.getBasedir().getAbsolutePath(), otherModule.getBasedir().getAbsolutePath()));\n    }\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\nwith the following error message:\n[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[385,13] cannot find symbol  symbol:   class RenderingContext\n  location: class org.scoverage.plugin.SCoverageReportMojo\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.apache.maven.doxia.siterenderer.DoxiaDocumentRenderer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink | MUTATION | SUPERTYPE_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink.getAuthors | MUTATION | METHOD_RETURN_TYPE_CHANGED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "import org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\n            RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );",
    "error_message": "[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[32,61] package org.apache.maven.doxia.module.xhtml.decoration.render does not exist\n[ERROR] /scoverage-maven-plugin/src/main/java/org/scoverage/plugin/SCoverageReportMojo.java:[385,13] cannot find symbol  symbol:   class RenderingContext\n  location: class org.scoverage.plugin.SCoverageReportMojo",
    "api_diff": "Format: element | nature | kind\norg.apache.maven.doxia.siterenderer.DoxiaDocumentRenderer.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink | MUTATION | SUPERTYPE_REMOVED\norg.apache.maven.doxia.siterenderer.sink.SiteRendererSink.getAuthors | MUTATION | METHOD_RETURN_TYPE_CHANGED",
    "original_code": "package org.scoverage.plugin;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala.collection.Set;\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.sink.Sink;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.IOUtils;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\nimport scoverage.serialize.Serializer;\n@Mojo(name = \"report\", threadSafe = false)\n@Execute(lifecycle = \"scoverage\", phase = LifecyclePhase.TEST)\npublic class SCoverageReportMojo extends AbstractMojo implements MavenReport {\n    @Parameter(property = \"scoverage.skip\", defaultValue = \"false\")\n    private boolean skip;\n\n    @Parameter(property = \"scoverage.aggregate\", defaultValue = \"false\")\n    private boolean aggregate;\n\n    @Parameter(property = \"scoverage.aggregateOnly\", defaultValue = \"false\")\n    private boolean aggregateOnly;\n\n    @Parameter(property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n    private String encoding;\n\n    @Parameter(property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true)\n    private boolean failOnError;\n\n    @Parameter(defaultValue = \"${project}\", readonly = true, required = true)\n    private MavenProject project;\n\n    @Parameter(defaultValue = \"${reactorProjects}\", required = true, readonly = true)\n    private List<MavenProject> reactorProjects;\n\n    @Parameter(property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true)\n    private File dataDirectory;\n\n    @Parameter(property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true)\n    private File outputDirectory;\n\n    @Parameter(property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true)\n    private File xmlOutputDirectory;\n\n    @Parameter(property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true)\n    private String destDir;\n\n    @Parameter(property = \"name\", readonly = true)\n    private String name;\n\n    @Parameter(property = \"description\", readonly = true)\n    private String description;\n\n    @Override\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return getBundle(locale).getString(\"report.scoverage.name\");\n        }\n        return name;\n    }\n\n    @Override\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return getBundle(locale).getString(\"report.scoverage.description\");\n        }\n        return description;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canGenerateAggregatedReport = canGenerateAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n        if (canAttachAggregatedReportToSite && (!(canGenerateNonAggregatedReport || canGenerateAggregatedReport))) {\n            return;\n        }\n        try {\n            long ts = System.currentTimeMillis();\n            if (canGenerateNonAggregatedReport) {\n                generateReports();\n            }\n            if (canGenerateAggregatedReport) {\n                generateAggregatedReports();\n            }\n            long te = System.currentTimeMillis();\n            getLog().debug(String.format(\"Mojo execution time: %d ms\", te - ts));\n        } catch (MavenReportException e) {\n            if (failOnError) {\n                throw e;\n            }\n            getLog().error(\"Error while creating scoverage report: \" + e.getMessage(), e);\n        } catch (RuntimeException e) {\n            if (failOnError) {\n                throw new MavenReportException(\"Report generation exception\", e);\n            }\n            getLog().error(\"Error while creating scoverage report: \" + e.getMessage(), e);\n        }\n    }\n\n    @Override\n    public String getOutputName() {\n        return destDir + \"/index\";\n    }\n\n    @Override\n    public boolean isExternalReport() {\n        return true;\n    }\n\n    @Override\n    public boolean canGenerateReport() {\n        if ((!skip) && (!\"pom\".equals(project.getPackaging()))) {\n            SCoverageForkedLifecycleConfigurator.afterForkedLifecycleExit(project, reactorProjects);\n        }\n        boolean canGenerateNonAggregatedReport = canGenerateNonAggregatedReport();\n        boolean canAttachAggregatedReportToSite = canAttachAggregatedReportToSite();\n        boolean result = canGenerateNonAggregatedReport || canAttachAggregatedReportToSite;\n        if ((!result) && canGenerateAggregatedReport()) {\n            try {\n                generateAggregatedReports();\n            } catch (MavenReportException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return result;\n    }\n\n    private boolean canGenerateNonAggregatedReport() {\n        if (skip) {\n            return false;\n        }\n        if (\"pom\".equals(project.getPackaging())) {\n            return false;\n        }\n        if (aggregateOnly && (reactorProjects.size() > 1)) {\n            return false;\n        }\n        File coverageFile = Serializer.coverageFile(dataDirectory);\n        if ((!coverageFile.exists()) || (!coverageFile.isFile())) {\n            return false;\n        }\n        return true;\n    }\n\n    private boolean canGenerateAggregatedReport() {\n        return ((aggregate || aggregateOnly) && (reactorProjects.size() > 1)) && (project == reactorProjects.get(reactorProjects.size() - 1));\n    }\n\n    private boolean canAttachAggregatedReportToSite() {\n        return ((aggregate || aggregateOnly) && (reactorProjects.size() > 1)) && project.isExecutionRoot();\n    }\n\n    @Override\n    public String getCategoryName() {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    @Override\n    public File getReportOutputDirectory() {\n        return outputDirectory;\n    }\n\n    @Override\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        updateReportOutputDirectory(reportOutputDirectory);\n    }\n\n    private void updateReportOutputDirectory(File reportOutputDirectory) {\n        if (((reportOutputDirectory != null) && (destDir != null)) && (!reportOutputDirectory.getAbsolutePath().endsWith(destDir))) {\n            this.outputDirectory = new File(reportOutputDirectory, destDir);\n        } else {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException {\n        if (!canGenerateReport()) {\n            getLog().info(\"Skipping SCoverage report generation\");\n            return;\n        }\n        try {\n            RenderingContext context = new RenderingContext(outputDirectory, getOutputName() + \".html\");\n            SiteRendererSink sink = new SiteRendererSink(context);\n            Locale locale = Locale.getDefault();\n            generate(sink, locale);\n        } catch (MavenReportException e) {\n            String prefix = (\"An error has occurred in \" + getName(Locale.ENGLISH)) + \" report generation\";\n            throw new MojoExecutionException((prefix + \": \") + e.getMessage(), e);\n        }\n    }\n\n    private ResourceBundle getBundle(Locale locale) {\n        return ResourceBundle.getBundle(\"scoverage-report\", locale, getClass().getClassLoader());\n    }\n\n    private void generateReports() throws MavenReportException {\n        @SuppressWarnings(\"unchecked\")\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>(sourceDirs.size());\n        for (String dir : sourceDirs) {\n            sourceRoots.add(new File(dir));\n        }\n        mkdirs(outputDirectory);\n        mkdirs(xmlOutputDirectory);\n        File coverageFile = Serializer.coverageFile(dataDirectory);\n        getLog().info(String.format(\"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath()));\n        Coverage coverage = Serializer.deserialize(coverageFile, project.getBasedir());\n        getLog().info(String.format(\"Reading scoverage measurements [%s*]...\", new File(dataDirectory, Constants.MeasurementsPrefix()).getAbsolutePath()));\n        List<File> measurementFiles = Arrays.asList(IOUtils.findMeasurementFiles(dataDirectory));\n        Set<Tuple2<Object, String>> measurements = IOUtils.invoked(CollectionConverters.asScala(measurementFiles).toSeq(), encoding);\n        coverage.apply(measurements);\n        getLog().info(\"Generating coverage reports...\");\n        writeReports(coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory);\n        getLog().info(\"Coverage reports completed.\");\n    }\n\n    private void generateAggregatedReports() throws MavenReportException {\n        Coverage coverage = new Coverage();\n        AtomicInteger id = new AtomicInteger();\n        List<File> scoverageDataDirs = new ArrayList<File>();\n        List<File> sourceRoots = new ArrayList<File>();\n        MavenProject topLevelModule = null;\n        for (MavenProject module : reactorProjects) {\n            if (module.isExecutionRoot()) {\n                topLevelModule = module;\n            } else if (!module.getPackaging().equals(\"pom\")) {\n                File scoverageDataDir = rebase(dataDirectory, module);\n                if (scoverageDataDir.isDirectory()) {\n                    scoverageDataDirs.add(scoverageDataDir);\n                    File coverageFile = Serializer.coverageFile(scoverageDataDir);\n                    if (coverageFile.exists()) {\n                        Coverage subCoverage = Serializer.deserialize(coverageFile, module.getBasedir());\n                        List<File> measurementFiles = Arrays.asList(IOUtils.findMeasurementFiles(scoverageDataDir));\n                        Set<Tuple2<Object, String>> measurements = IOUtils.invoked(CollectionConverters.asScala(measurementFiles).toSeq(), encoding);\n                        subCoverage.apply(measurements);\n                        subCoverage.statements().foreach(statement -> {\n                            int statementId = id.getAndIncrement();\n                            Statement copy = statement.copy(statement.location(), statementId, statement.start(), statement.end(), statement.line(), statement.desc(), statement.symbolName(), statement.treeName(), statement.branch(), statement.count(), statement.ignored(), statement.tests());\n                            coverage.add(copy);\n                            return null;\n                        });\n                    }\n                    File sourceRootsFile = new File(scoverageDataDir, \"source.roots\");\n                    if (sourceRootsFile.isFile()) {\n                        try {\n                            BufferedReader r = new BufferedReader(new InputStreamReader(new FileInputStream(sourceRootsFile), \"UTF-8\"));\n                            try {\n                                String path = r.readLine();\n                                while (path != null) {\n                                    sourceRoots.add(new File(path));\n                                    path = r.readLine();\n                                } \n                            } finally {\n                                r.close();\n                            }\n                        } catch (IOException e) {\n                            throw new MavenReportException(\"...\", e);\n                        }\n                    }\n                }\n            }\n        }\n        if (getLog().isDebugEnabled() && (scoverageDataDirs.size() > 0)) {\n            getLog().debug(String.format(\"Found %d subproject subproject scoverage data directories:\", scoverageDataDirs.size()));\n            for (File dataDir : scoverageDataDirs) {\n                getLog().debug(String.format(\"- %s\", dataDir.getAbsolutePath()));\n            }\n        } else {\n            getLog().info(String.format(\"Found %d subproject scoverage data directories.\", scoverageDataDirs.size()));\n        }\n        File topLevelModuleOutputDirectory = rebase(outputDirectory, topLevelModule);\n        File topLevelModuleXmlOutputDirectory = rebase(xmlOutputDirectory, topLevelModule);\n        mkdirs(topLevelModuleOutputDirectory);\n        mkdirs(topLevelModuleXmlOutputDirectory);\n        getLog().info(\"Generating coverage aggregated reports...\");\n        writeReports(coverage, sourceRoots, topLevelModuleXmlOutputDirectory, topLevelModuleXmlOutputDirectory, topLevelModuleOutputDirectory);\n        getLog().info(\"Coverage aggregated reports completed.\");\n    }\n\n    private void writeReports(Coverage coverage, List<File> sourceRoots, File coberturaXmlOutputDirectory, File scoverageXmlOutputDirectory, File scoverageHtmlOutputDirectory) {\n        Seq<File> sourceRootsAsScalaSeq = CollectionConverters.asScala(sourceRoots).toSeq();\n        new CoberturaXmlWriter(sourceRootsAsScalaSeq, coberturaXmlOutputDirectory, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written Cobertura XML report [%s]\", new File(coberturaXmlOutputDirectory, \"cobertura.xml\").getAbsolutePath()));\n        new ScoverageXmlWriter(sourceRootsAsScalaSeq, scoverageXmlOutputDirectory, false, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written XML coverage report [%s]\", new File(scoverageXmlOutputDirectory, \"scoverage.xml\").getAbsolutePath()));\n        new ScoverageHtmlWriter(sourceRootsAsScalaSeq, scoverageHtmlOutputDirectory, Option.<String>apply(encoding)).write(coverage);\n        getLog().info(String.format(\"Written HTML coverage report [%s]\", new File(scoverageHtmlOutputDirectory, \"index.html\").getAbsolutePath()));\n        getLog().info(String.format(\"Statement coverage.: %s%%\", coverage.statementCoverageFormatted()));\n        getLog().info(String.format(\"Branch coverage....: %s%%\", coverage.branchCoverageFormatted()));\n    }\n\n    private void mkdirs(File directory) throws MavenReportException {\n        if ((!directory.exists()) && (!directory.mkdirs())) {\n            throw new MavenReportException(String.format(\"Cannot create \\\"%s\\\" directory \", directory.getAbsolutePath()));\n        } else if (directory.exists() && (!directory.isDirectory())) {\n            throw new MavenReportException(String.format(\"Directory \\\"%s\\\" exists but is not a directory \", directory.getAbsolutePath()));\n        }\n    }\n\n    private File rebase(File file, MavenProject otherModule) {\n        return new File(file.getAbsolutePath().replace(project.getBasedir().getAbsolutePath(), otherModule.getBasedir().getAbsolutePath()));\n    }\n}\n",
    "project": "scoverage-maven-plugin",
    "libraryName": "doxia-site-renderer",
    "libraryGroupID": "org.apache.maven.doxia",
    "newVersion": "1.11.1",
    "previousVersion": "1.0",
    "breakingCommit": "c7c9590a206d4fb77dd05b9df391d888e6181667",
    "patch": "```java\npackage org.scoverage.plugin;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.codehaus.plexus.util.StringUtils;\nimport scala.collection.Set;\nimport org.apache.maven.doxia.module.xhtml.decoration.render.RenderingContext;\nimport org.apache.maven.doxia.siterenderer.sink.SiteRendererSink;\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\nimport org.apache.maven.plugins.annotations.Execute;\nimport org.apache.maven.plugins.annotations.LifecyclePhase;\nimport org.apache.maven.plugins.annotations.Mojo;\nimport org.apache.maven.plugins.annotations.Parameter;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.reporting.MavenReport;\nimport org.apache.maven.reporting.MavenReportException;\nimport scala.Option;\nimport scala.Tuple2;\nimport scala.collection.immutable.Seq;\nimport scala.jdk.javaapi.CollectionConverters;\nimport scoverage.domain.Constants;\nimport scoverage.domain.Coverage;\nimport scoverage.domain.Statement;\nimport scoverage.reporter.CoberturaXmlWriter;\nimport scoverage.reporter.CoverageAggregator;\nimport scoverage.reporter.IOUtils;\nimport scoverage.reporter.ScoverageHtmlWriter;\nimport scoverage.reporter.ScoverageXmlWriter;\nimport scoverage.serialize.Serializer;\n@Mojo(name = \"report\", threadSafe = false)\n@Execute(lifecycle = \"scoverage\", phase = LifecyclePhase.TEST)\npublic class SCoverageReportMojo extends AbstractMojo implements MavenReport {\n    @Parameter(property = \"scoverage.skip\", defaultValue = \"false\")\n    private boolean skip;\n\n    @Parameter(property = \"scoverage.aggregate\", defaultValue = \"false\")\n    private boolean aggregate;\n\n    @Parameter(property = \"scoverage.aggregateOnly\", defaultValue = \"false\")\n    private boolean aggregateOnly;\n\n    @Parameter(property = \"encoding\", defaultValue = \"${project.build.sourceEncoding}\")\n    private String encoding;\n\n    @Parameter(property = \"scoverage.failOnError\", defaultValue = \"true\", readonly = true)\n    private boolean failOnError;\n\n    @Parameter(defaultValue = \"${project}\", readonly = true, required = true)\n    private MavenProject project;\n\n    @Parameter(defaultValue = \"${reactorProjects}\", required = true, readonly = true)\n    private List<MavenProject> reactorProjects;\n\n    @Parameter(property = \"scoverage.dataDirectory\", defaultValue = \"${project.build.directory}/scoverage-data\", required = true, readonly = true)\n    private File dataDirectory;\n\n    @Parameter(property = \"scoverage.outputDirectory\", defaultValue = \"${project.reporting.outputDirectory}/scoverage\", required = true, readonly = true)\n    private File outputDirectory;\n\n    @Parameter(property = \"scoverage.xmlOutputDirectory\", defaultValue = \"${project.build.directory}\", required = true, readonly = true)\n    private File xmlOutputDirectory;\n\n    @Parameter(property = \"destDir\", defaultValue = \"scoverage\", required = true, readonly = true)\n    private String destDir;\n\n    @Parameter(property = \"name\", readonly = true)\n    private String name;\n\n    @Parameter(property = \"description\", readonly = true)\n    private String description;\n\n    @Override\n    public String getName(Locale locale) {\n        if (StringUtils.isEmpty(name)) {\n            return getBundle(locale).getString(\"report.scoverage.name\");\n        }\n        return name;\n    }\n\n    @Override\n    public String getDescription(Locale locale) {\n        if (StringUtils.isEmpty(description)) {\n            return getBundle(locale).getString(\"report.scoverage.description\");\n        }\n        return description;\n    }\n\n    @Override\n    @SuppressWarnings(\"deprecation\")\n    public void generate(Sink sink, Locale locale) throws MavenReportException {\n        RenderingContext context = new RenderingContext( outputDirectory, getOutputName() + \".html\" );\n        SiteRendererSink sink2 = new SiteRendererSink(context);\n        generate(sink2, locale);\n    }\n\n    @Override\n    public String getCategoryName() {\n        return MavenReport.CATEGORY_PROJECT_REPORTS;\n    }\n\n    @Override\n    public File getReportOutputDirectory() {\n        return outputDirectory;\n    }\n\n    @Override\n    public void setReportOutputDirectory(File reportOutputDirectory) {\n        updateReportOutputDirectory(reportOutputDirectory);\n    }\n\n    private void updateReportOutputDirectory(File reportOutputDirectory) {\n        if (((reportOutputDirectory != null) && (destDir != null)) && (!reportOutputDirectory.getAbsolutePath().endsWith(destDir))) {\n            this.outputDirectory = new File(reportOutputDirectory, destDir);\n        } else {\n            this.outputDirectory = reportOutputDirectory;\n        }\n    }\n\n    @Override\n    public void execute() throws MojoExecutionException {\n        if (!canGenerateReport()) {\n            getLog().info(\"Skipping SCoverage report generation\");\n            return;\n        }\n        try {\n            RenderingContext context = new RenderingContext(outputDirectory, getOutputName() + \".html\");\n            SiteRendererSink sink = new SiteRendererSink(context);\n            Locale locale = Locale.getDefault();\n            generate(sink, locale);\n        } catch (MavenReportException e) {\n            String prefix = (\"An error has occurred in \" + getName(Locale.ENGLISH)) + \" report generation\";\n            throw new MojoExecutionException((prefix + \": \") + e.getMessage(), e);\n        }\n    }\n\n    private ResourceBundle getBundle(Locale locale) {\n        return ResourceBundle.getBundle(\"scoverage-report\", locale, getClass().getClassLoader());\n    }\n\n    private void generateReports() throws MavenReportException {\n        @SuppressWarnings(\"unchecked\")\n        List<String> sourceDirs = project.getExecutionProject().getCompileSourceRoots();\n        List<File> sourceRoots = new ArrayList<File>(sourceDirs.size());\n        for (String dir : sourceDirs) {\n            sourceRoots.add(new File(dir));\n        }\n        mkdirs(outputDirectory);\n        mkdirs(xmlOutputDirectory);\n        File coverageFile = Serializer.coverageFile(dataDirectory);\n        getLog().info(String.format(\"Reading scoverage instrumentation [%s]...\", coverageFile.getAbsolutePath()));\n        Coverage coverage = Serializer.deserialize(coverageFile, project.getBasedir());\n        getLog().info(String.format(\"Reading scoverage measurements [%s*]...\", new File(dataDirectory, Constants.MeasurementsPrefix()).getAbsolutePath()));\n        List<File> measurementFiles = IUtils.findMeasurementFiles(dataDirectory);\n        Set<Tuple2<Object, String>> measurements = IUtils.invoked(CollectionConverters.asScala(measurementFiles).toSeq(), encoding);\n        coverage.apply(measurements);\n        getLog().info(\"Generating coverage reports...\");\n        writeReports(coverage, sourceRoots, xmlOutputDirectory, xmlOutputDirectory, outputDirectory);\n        getLog().info(\"Coverage reports completed.\");\n    }\n}\n```<end_of_turn>"
}