{
    "absolute_path_to_file_in_container": "/quickfixj/quickfixj-core/src/main/java/quickfix/mina/acceptor/AbstractSocketAcceptor.java",
    "errors": [
        {
            "line_number": 136,
            "message": "[ERROR] /quickfixj/quickfixj-core/src/main/java/quickfix/mina/acceptor/AbstractSocketAcceptor.java:[136,18] cannot find symbol",
            "additional_info": "  symbol:   method setUseClientMode(boolean)\n  location: variable sslFilter of type quickfix.mina.ssl.SSLFilter",
            "file_name": "AbstractSocketAcceptor.java",
            "uid": "6a1a36dc-a6cf-537b-baa7-05f5eac7bfd0"
        }
    ],
    "prompt": "Act as an Automatic Program Repair (APR) tool, reply only with code, without explanation. \nYou are specialized in breaking dependency updates, in which the failure is caused by an external dependency. \nTo solve the failure you can only work on the client code.\n\nAPI upgrade: mina-core 2.1.5->2.2.1\n\nthe following client code fails: \n'''java\npackage quickfix.mina.acceptor;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.security.GeneralSecurityException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport javax.net.ssl.SSLContext;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport quickfix.Acceptor;\nimport quickfix.Application;\nimport quickfix.ConfigError;\nimport quickfix.DefaultSessionFactory;\nimport quickfix.FieldConvertError;\nimport quickfix.LogFactory;\nimport quickfix.MessageFactory;\nimport quickfix.MessageStoreFactory;\nimport quickfix.RuntimeError;\nimport quickfix.ScreenLogFactory;\nimport quickfix.Session;\nimport quickfix.SessionFactory;\nimport quickfix.SessionID;\nimport quickfix.SessionSettings;\nimport quickfix.mina.CompositeIoFilterChainBuilder;\nimport quickfix.mina.EventHandlingStrategy;\nimport quickfix.mina.NetworkingOptions;\nimport quickfix.mina.ProtocolFactory;\nimport quickfix.mina.SessionConnector;\nimport quickfix.mina.message.FIXProtocolCodecFactory;\nimport quickfix.mina.ssl.SSLConfig;\nimport quickfix.mina.ssl.SSLContextFactory;\nimport quickfix.mina.ssl.SSLFilter;\nimport quickfix.mina.ssl.SSLSupport;\npublic abstract class AbstractSocketAcceptor extends SessionConnector implements Acceptor {\n    private final Map<SocketAddress, AcceptorSessionProvider> sessionProviders = new HashMap<>();\n\n    private final SessionFactory sessionFactory;\n\n    private final Map<SocketAddress, AcceptorSocketDescriptor> socketDescriptorForAddress = new HashMap<>();\n\n    private final ConcurrentMap<AcceptorSocketDescriptor, IoAcceptor> ioAcceptors = new ConcurrentHashMap<>();\n\n    protected AbstractSocketAcceptor(SessionSettings settings, SessionFactory sessionFactory) throws ConfigError {\n        super(settings, sessionFactory);\n        IoBuffer.setAllocator(new SimpleBufferAllocator());\n        IoBuffer.setUseDirectBuffer(false);\n        this.sessionFactory = sessionFactory;\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, MessageFactory messageFactory) throws ConfigError {\n        this(application, messageStoreFactory, settings, new ScreenLogFactory(settings), messageFactory);\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, LogFactory logFactory, MessageFactory messageFactory) throws ConfigError {\n        this(settings, new DefaultSessionFactory(application, messageStoreFactory, logFactory, messageFactory));\n    }\n\n    protected synchronized void startAcceptingConnections() throws ConfigError {\n        boolean continueInitOnError = isContinueInitOnError();\n        createSessions(getSettings(), continueInitOnError);\n        startSessionTimer();\n        SocketAddress address = null;\n        for (AcceptorSocketDescriptor socketDescriptor : socketDescriptorForAddress.values()) {\n            try {\n                address = socketDescriptor.getAddress();\n                IoAcceptor ioAcceptor = getIoAcceptor(socketDescriptor);\n                CompositeIoFilterChainBuilder ioFilterChainBuilder = new CompositeIoFilterChainBuilder(getIoFilterChainBuilder());\n                if (socketDescriptor.isUseSSL()) {\n                    installSSL(socketDescriptor, ioFilterChainBuilder);\n                }\n                ioFilterChainBuilder.addLast(FIXProtocolCodecFactory.FILTER_NAME, new ProtocolCodecFilter(new FIXProtocolCodecFactory()));\n                ioAcceptor.setFilterChainBuilder(ioFilterChainBuilder);\n                ioAcceptor.setCloseOnDeactivation(false);\n                ioAcceptor.bind(socketDescriptor.getAddress());\n                log.info(\"Listening for connections at {} for session(s) {}\", address, socketDescriptor.getAcceptedSessions().keySet());\n            } catch (IOException | GeneralSecurityException | ConfigError e) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for session(s) {}, continuing...\", socketDescriptor.getAcceptedSessions().keySet(), e);\n                } else {\n                    log.error(\"Cannot start acceptor session for {}, error: {}\", address, e);\n                    throw new RuntimeError(e);\n                }\n            }\n        }\n    }\n\n    private void installSSL(AcceptorSocketDescriptor descriptor, CompositeIoFilterChainBuilder ioFilterChainBuilder) throws GeneralSecurityException {\n        log.info(\"Installing SSL filter for {}\", descriptor.getAddress());\n        SSLConfig sslConfig = descriptor.getSslConfig();\n        SSLContext sslContext = SSLContextFactory.getInstance(sslConfig);\n        SSLFilter sslFilter = new SSLFilter(sslContext);\n        sslFilter.setUseClientMode(false);\n        sslFilter.setNeedClientAuth(sslConfig.isNeedClientAuth());\n        sslFilter.setCipherSuites(sslConfig.getEnabledCipherSuites() != null ? sslConfig.getEnabledCipherSuites() : SSLSupport.getDefaultCipherSuites(sslContext));\n        sslFilter.setEnabledProtocols(sslConfig.getEnabledProtocols() != null ? sslConfig.getEnabledProtocols() : SSLSupport.getSupportedProtocols(sslContext));\n        ioFilterChainBuilder.addLast(SSLSupport.FILTER_NAME, sslFilter);\n    }\n\n    private IoAcceptor getIoAcceptor(AcceptorSocketDescriptor socketDescriptor) throws ConfigError {\n        int transportType = ProtocolFactory.getAddressTransportType(socketDescriptor.getAddress());\n        AcceptorSessionProvider sessionProvider = sessionProviders.computeIfAbsent(socketDescriptor.getAddress(), k -> new quickfix.mina.acceptor.DefaultAcceptorSessionProvider(socketDescriptor.getAcceptedSessions()));\n        IoAcceptor ioAcceptor = ioAcceptors.get(socketDescriptor);\n        if (ioAcceptor == null) {\n            ioAcceptor = ProtocolFactory.createIoAcceptor(transportType);\n            try {\n                SessionSettings settings = getSettings();\n                NetworkingOptions networkingOptions = new NetworkingOptions(settings.getDefaultProperties());\n                networkingOptions.apply(ioAcceptor);\n                ioAcceptor.setHandler(new AcceptorIoHandler(sessionProvider, settings, networkingOptions, getEventHandlingStrategy()));\n            } catch (FieldConvertError e) {\n                throw new ConfigError(e);\n            }\n            ioAcceptors.put(socketDescriptor, ioAcceptor);\n        }\n        return ioAcceptor;\n    }\n\n    private void setupSession(SessionSettings settings, SessionID sessionID, boolean isTemplate, Map<SessionID, Session> allSessions) throws ConfigError, FieldConvertError {\n        int acceptTransportType = ProtocolFactory.SOCKET;\n        if (settings.isSetting(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL)) {\n            try {\n                acceptTransportType = ProtocolFactory.getTransportType(settings.getString(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL));\n            } catch (IllegalArgumentException e) {\n                throw new ConfigError(e);\n            }\n        }\n        boolean useSSL = false;\n        SSLConfig sslConfig = null;\n        if (getSettings().isSetting(sessionID, SSLSupport.SETTING_USE_SSL) && getSettings().getBool(sessionID, SSLSupport.SETTING_USE_SSL)) {\n            if (acceptTransportType == ProtocolFactory.SOCKET) {\n                useSSL = true;\n                sslConfig = SSLSupport.getSslConfig(getSettings(), sessionID);\n            } else {\n                log.warn(\"SSL will not be enabled for transport type={}, session={}\", acceptTransportType, sessionID);\n            }\n        }\n        int acceptPort = ((int) (settings.getLong(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PORT)));\n        String acceptHost = null;\n        if (settings.isSetting(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS)) {\n            acceptHost = settings.getString(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS);\n        }\n        SocketAddress acceptorAddress = ProtocolFactory.createSocketAddress(acceptTransportType, acceptHost, acceptPort);\n        AcceptorSocketDescriptor descriptor = socketDescriptorForAddress.get(acceptorAddress);\n        if (descriptor != null) {\n            if ((descriptor.isUseSSL() != useSSL) || (!equals(sslConfig, descriptor.getSslConfig()))) {\n                throw new ConfigError(\"Conflicting configurations of acceptor socket: \" + acceptorAddress);\n            }\n        } else {\n            descriptor = new AcceptorSocketDescriptor(acceptorAddress, useSSL, sslConfig);\n            socketDescriptorForAddress.put(acceptorAddress, descriptor);\n        }\n        if (!isTemplate) {\n            Session session = sessionFactory.create(sessionID, settings);\n            descriptor.acceptSession(session);\n            allSessions.put(sessionID, session);\n        }\n    }\n\n    private boolean equals(Object object1, Object object2) {\n        return object1 == null ? object2 == null : object1.equals(object2);\n    }\n\n    private void createSessions(SessionSettings settings, boolean continueInitOnError) throws ConfigError {\n        Map<SessionID, Session> allSessions = new HashMap<>();\n        for (Iterator<SessionID> i = settings.sectionIterator(); i.hasNext();) {\n            SessionID sessionID = i.next();\n            try {\n                String connectionType = null;\n                if (settings.isSetting(sessionID, SessionFactory.SETTING_CONNECTION_TYPE)) {\n                    connectionType = settings.getString(sessionID, SessionFactory.SETTING_CONNECTION_TYPE);\n                }\n                if (SessionFactory.ACCEPTOR_CONNECTION_TYPE.equals(connectionType)) {\n                    boolean isTemplate = false;\n                    if (settings.isSetting(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE)) {\n                        try {\n                            isTemplate = settings.getBool(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE);\n                        } catch (FieldConvertError | ConfigError ex) {\n                        }\n                    }\n                    setupSession(settings, sessionID, isTemplate, allSessions);\n                }\n            } catch (Throwable t) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for {}, continuing...\", sessionID, t);\n                } else {\n                    throw t instanceof ConfigError ? ((ConfigError) (t)) : new ConfigError(\"error during session initialization\", t);\n                }\n            }\n        }\n        setSessions(allSessions);\n        if (socketDescriptorForAddress.isEmpty()) {\n            throw new ConfigError(\"No acceptor sessions found in settings.\");\n        }\n    }\n\n    protected void stopAcceptingConnections() {\n        Iterator<IoAcceptor> ioIt = getEndpoints().iterator();\n        while (ioIt.hasNext()) {\n            IoAcceptor ioAcceptor = ioIt.next();\n            SocketAddress localAddress = ioAcceptor.getLocalAddress();\n            ioAcceptor.unbind();\n            closeManagedSessionsAndDispose(ioAcceptor, true, log);\n            log.info(\"No longer accepting connections on {}\", localAddress);\n            ioIt.remove();\n        } \n    }\n\n    private static class AcceptorSocketDescriptor {\n        private final SocketAddress address;\n\n        private final boolean useSSL;\n\n        private final SSLConfig sslConfig;\n\n        private final Map<SessionID, Session> acceptedSessions = new HashMap<>();\n\n        public AcceptorSocketDescriptor(SocketAddress address, boolean useSSL, SSLConfig sslConfig) {\n            this.address = address;\n            this.useSSL = useSSL;\n            this.sslConfig = sslConfig;\n        }\n\n        public void acceptSession(Session session) {\n            acceptedSessions.put(session.getSessionID(), session);\n        }\n\n        public Map<SessionID, Session> getAcceptedSessions() {\n            return Collections.unmodifiableMap(acceptedSessions);\n        }\n\n        public SocketAddress getAddress() {\n            return address;\n        }\n\n        public boolean isUseSSL() {\n            return useSSL;\n        }\n\n        public SSLConfig getSslConfig() {\n            return sslConfig;\n        }\n    }\n\n    public Collection<IoAcceptor> getEndpoints() {\n        return ioAcceptors.values();\n    }\n\n    public Map<SessionID, SocketAddress> getAcceptorAddresses() {\n        Map<SessionID, SocketAddress> sessionIdToAddressMap = new HashMap<>();\n        for (AcceptorSocketDescriptor descriptor : socketDescriptorForAddress.values()) {\n            for (SessionID sessionID : descriptor.getAcceptedSessions().keySet()) {\n                sessionIdToAddressMap.put(sessionID, descriptor.getAddress());\n            }\n        }\n        return sessionIdToAddressMap;\n    }\n\n    public void setSessionProvider(SocketAddress address, AcceptorSessionProvider provider) {\n        sessionProviders.put(address, provider);\n    }\n\n    static class StaticAcceptorSessionProvider implements AcceptorSessionProvider {\n        private final Map<SessionID, Session> acceptorSessions;\n\n        public StaticAcceptorSessionProvider(final Map<SessionID, Session> acceptorSessions) {\n            this.acceptorSessions = acceptorSessions;\n        }\n\n        public Session getSession(SessionID sessionID, SessionConnector connector) {\n            return acceptorSessions.get(sessionID);\n        }\n    }\n\n    public int getQueueSize() {\n        final EventHandlingStrategy ehs = getEventHandlingStrategy();\n        return ehs == null ? 0 : ehs.getQueueSize();\n    }\n\n    protected abstract EventHandlingStrategy getEventHandlingStrategy();\n\n    private class DefaultAcceptorSessionProvider implements AcceptorSessionProvider {\n        private final Map<SessionID, Session> acceptorSessions;\n\n        public DefaultAcceptorSessionProvider(Map<SessionID, Session> acceptorSessions) {\n            this.acceptorSessions = acceptorSessions;\n        }\n\n        public Session getSession(SessionID sessionID, SessionConnector ignored) {\n            Session session = acceptorSessions.get(sessionID);\n            if (session == null) {\n                SessionID reduced = reduceSessionID(sessionID);\n                session = acceptorSessions.get(reduced);\n            }\n            return session;\n        }\n\n        private SessionID reduceSessionID(SessionID sessionID) {\n            return new SessionID(sessionID.getBeginString(), sessionID.getSenderCompID(), sessionID.getTargetCompID());\n        }\n    }\n}\n\n'''\nthe error is triggered in the following specific lines in the previous code:\n        sslFilter.setUseClientMode(false);\nwith the following error message:\n[ERROR] /quickfixj/quickfixj-core/src/main/java/quickfix/mina/acceptor/AbstractSocketAcceptor.java:[136,18] cannot find symbol  symbol:   method setUseClientMode(boolean)\n  location: variable sslFilter of type quickfix.mina.ssl.SSLFilter\nThe error is caused by a change in the API of the dependency. The new library version includes the following changes:\nFormat: element | nature | kind\norg.apache.mina.filter.ssl.SslFilter.filterClose | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.PEER_ADDRESS | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter$SslFilterMessage | DELETION | TYPE_REMOVED\norg.apache.mina.filter.ssl.SslFilter.isSslStarted | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPreRemove | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.onPreAdd | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.sessionClosed | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.START_HANDSHAKE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPostAdd | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.isUseClientMode | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.DISABLE_ENCRYPTION_ONCE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.getSslSession | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.isSecured | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.messageReceived | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.USE_NOTIFICATION | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.CLIENT_HANDSHAKE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.stopSsl | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPreAdd | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.messageSent | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.filterWrite | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.core.session.IoSession | ADDITION | METHOD_ADDED_TO_INTERFACE\norg.apache.mina.filter.ssl.SslFilter.messageReceived | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.mina.filter.ssl.SslFilter.filterClose | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.onPreRemove | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.sessionClosed | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.filterWrite | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.setUseClientMode | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.startSsl | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPostAdd | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.initiateHandshake | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.SSL_SESSION | DELETION | FIELD_REMOVED\n\n- Identify the specific API changes that are causing the failure in the client code. \n- Compare the old and new API versions, noting any changes in method signatures, return types, or parameter lists. \n- Determine which parts of the client code need to be updated to accommodate these API changes. \n- Consider any constraints or requirements for the fix (e.g., not changing function signatures, potential import adjustments). \n- Plan the minimal set of changes needed to fix the issue while keeping the code functional and compliant with the new API. \n- Consider potential side effects of the proposed changes on other parts of the code. \n- Ensure that the planned changes will result in a complete and compilable class. \n- If applicable, note any additional imports that may be needed due to the API changes.  \n- Propose a patch that can be applied to the code to fix the issue. \n- Return only a complete and compilable class in a fenced code block. \n- You CANNOT change the function signature of any method but may create variables if it simplifies the code. \n- You CAN remove the @Override annotation IF AND ONLY IF the method no longer overrides a method in the updated dependency version. \n- If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version. \n- Avoid removing any existing code unless it directly causes a compilation or functionality error. \n- Return only the fixed class, ensuring it fully compiles and adheres to these constraints.",
    "buggy_lines": "        sslFilter.setUseClientMode(false);",
    "error_message": "[ERROR] /quickfixj/quickfixj-core/src/main/java/quickfix/mina/acceptor/AbstractSocketAcceptor.java:[136,18] cannot find symbol  symbol:   method setUseClientMode(boolean)\n  location: variable sslFilter of type quickfix.mina.ssl.SSLFilter",
    "api_diff": "Format: element | nature | kind\norg.apache.mina.filter.ssl.SslFilter.filterClose | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.PEER_ADDRESS | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter$SslFilterMessage | DELETION | TYPE_REMOVED\norg.apache.mina.filter.ssl.SslFilter.isSslStarted | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPreRemove | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.onPreAdd | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.sessionClosed | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.START_HANDSHAKE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPostAdd | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.isUseClientMode | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.DISABLE_ENCRYPTION_ONCE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.getSslSession | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.isSecured | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.messageReceived | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.USE_NOTIFICATION | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.CLIENT_HANDSHAKE | DELETION | FIELD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.stopSsl | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPreAdd | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.messageSent | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.filterWrite | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.core.session.IoSession | ADDITION | METHOD_ADDED_TO_INTERFACE\norg.apache.mina.filter.ssl.SslFilter.messageReceived | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.<init> | DELETION | CONSTRUCTOR_REMOVED\norg.apache.mina.filter.ssl.SslFilter.filterClose | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.onPreRemove | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.sessionClosed | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.filterWrite | MUTATION | METHOD_NOW_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.setUseClientMode | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.startSsl | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.onPostAdd | MUTATION | METHOD_NO_LONGER_THROWS_CHECKED_EXCEPTION\norg.apache.mina.filter.ssl.SslFilter.initiateHandshake | DELETION | METHOD_REMOVED\norg.apache.mina.filter.ssl.SslFilter.SSL_SESSION | DELETION | FIELD_REMOVED",
    "original_code": "package quickfix.mina.acceptor;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.security.GeneralSecurityException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport javax.net.ssl.SSLContext;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport quickfix.Acceptor;\nimport quickfix.Application;\nimport quickfix.ConfigError;\nimport quickfix.DefaultSessionFactory;\nimport quickfix.FieldConvertError;\nimport quickfix.LogFactory;\nimport quickfix.MessageFactory;\nimport quickfix.MessageStoreFactory;\nimport quickfix.RuntimeError;\nimport quickfix.ScreenLogFactory;\nimport quickfix.Session;\nimport quickfix.SessionFactory;\nimport quickfix.SessionID;\nimport quickfix.SessionSettings;\nimport quickfix.mina.CompositeIoFilterChainBuilder;\nimport quickfix.mina.EventHandlingStrategy;\nimport quickfix.mina.NetworkingOptions;\nimport quickfix.mina.ProtocolFactory;\nimport quickfix.mina.SessionConnector;\nimport quickfix.mina.message.FIXProtocolCodecFactory;\nimport quickfix.mina.ssl.SSLConfig;\nimport quickfix.mina.ssl.SSLContextFactory;\nimport quickfix.mina.ssl.SSLFilter;\nimport quickfix.mina.ssl.SSLSupport;\npublic abstract class AbstractSocketAcceptor extends SessionConnector implements Acceptor {\n    private final Map<SocketAddress, AcceptorSessionProvider> sessionProviders = new HashMap<>();\n\n    private final SessionFactory sessionFactory;\n\n    private final Map<SocketAddress, AcceptorSocketDescriptor> socketDescriptorForAddress = new HashMap<>();\n\n    private final ConcurrentMap<AcceptorSocketDescriptor, IoAcceptor> ioAcceptors = new ConcurrentHashMap<>();\n\n    protected AbstractSocketAcceptor(SessionSettings settings, SessionFactory sessionFactory) throws ConfigError {\n        super(settings, sessionFactory);\n        IoBuffer.setAllocator(new SimpleBufferAllocator());\n        IoBuffer.setUseDirectBuffer(false);\n        this.sessionFactory = sessionFactory;\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, MessageFactory messageFactory) throws ConfigError {\n        this(application, messageStoreFactory, settings, new ScreenLogFactory(settings), messageFactory);\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, LogFactory logFactory, MessageFactory messageFactory) throws ConfigError {\n        this(settings, new DefaultSessionFactory(application, messageStoreFactory, logFactory, messageFactory));\n    }\n\n    protected synchronized void startAcceptingConnections() throws ConfigError {\n        boolean continueInitOnError = isContinueInitOnError();\n        createSessions(getSettings(), continueInitOnError);\n        startSessionTimer();\n        SocketAddress address = null;\n        for (AcceptorSocketDescriptor socketDescriptor : socketDescriptorForAddress.values()) {\n            try {\n                address = socketDescriptor.getAddress();\n                IoAcceptor ioAcceptor = getIoAcceptor(socketDescriptor);\n                CompositeIoFilterChainBuilder ioFilterChainBuilder = new CompositeIoFilterChainBuilder(getIoFilterChainBuilder());\n                if (socketDescriptor.isUseSSL()) {\n                    installSSL(socketDescriptor, ioFilterChainBuilder);\n                }\n                ioFilterChainBuilder.addLast(FIXProtocolCodecFactory.FILTER_NAME, new ProtocolCodecFilter(new FIXProtocolCodecFactory()));\n                ioAcceptor.setFilterChainBuilder(ioFilterChainBuilder);\n                ioAcceptor.setCloseOnDeactivation(false);\n                ioAcceptor.bind(socketDescriptor.getAddress());\n                log.info(\"Listening for connections at {} for session(s) {}\", address, socketDescriptor.getAcceptedSessions().keySet());\n            } catch (IOException | GeneralSecurityException | ConfigError e) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for session(s) {}, continuing...\", socketDescriptor.getAcceptedSessions().keySet(), e);\n                } else {\n                    log.error(\"Cannot start acceptor session for {}, error: {}\", address, e);\n                    throw new RuntimeError(e);\n                }\n            }\n        }\n    }\n\n    private void installSSL(AcceptorSocketDescriptor descriptor, CompositeIoFilterChainBuilder ioFilterChainBuilder) throws GeneralSecurityException {\n        log.info(\"Installing SSL filter for {}\", descriptor.getAddress());\n        SSLConfig sslConfig = descriptor.getSslConfig();\n        SSLContext sslContext = SSLContextFactory.getInstance(sslConfig);\n        SSLFilter sslFilter = new SSLFilter(sslContext);\n        sslFilter.setUseClientMode(false);\n        sslFilter.setNeedClientAuth(sslConfig.isNeedClientAuth());\n        sslFilter.setCipherSuites(sslConfig.getEnabledCipherSuites() != null ? sslConfig.getEnabledCipherSuites() : SSLSupport.getDefaultCipherSuites(sslContext));\n        sslFilter.setEnabledProtocols(sslConfig.getEnabledProtocols() != null ? sslConfig.getEnabledProtocols() : SSLSupport.getSupportedProtocols(sslContext));\n        ioFilterChainBuilder.addLast(SSLSupport.FILTER_NAME, sslFilter);\n    }\n\n    private IoAcceptor getIoAcceptor(AcceptorSocketDescriptor socketDescriptor) throws ConfigError {\n        int transportType = ProtocolFactory.getAddressTransportType(socketDescriptor.getAddress());\n        AcceptorSessionProvider sessionProvider = sessionProviders.computeIfAbsent(socketDescriptor.getAddress(), k -> new quickfix.mina.acceptor.DefaultAcceptorSessionProvider(socketDescriptor.getAcceptedSessions()));\n        IoAcceptor ioAcceptor = ioAcceptors.get(socketDescriptor);\n        if (ioAcceptor == null) {\n            ioAcceptor = ProtocolFactory.createIoAcceptor(transportType);\n            try {\n                SessionSettings settings = getSettings();\n                NetworkingOptions networkingOptions = new NetworkingOptions(settings.getDefaultProperties());\n                networkingOptions.apply(ioAcceptor);\n                ioAcceptor.setHandler(new AcceptorIoHandler(sessionProvider, settings, networkingOptions, getEventHandlingStrategy()));\n            } catch (FieldConvertError e) {\n                throw new ConfigError(e);\n            }\n            ioAcceptors.put(socketDescriptor, ioAcceptor);\n        }\n        return ioAcceptor;\n    }\n\n    private void setupSession(SessionSettings settings, SessionID sessionID, boolean isTemplate, Map<SessionID, Session> allSessions) throws ConfigError, FieldConvertError {\n        int acceptTransportType = ProtocolFactory.SOCKET;\n        if (settings.isSetting(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL)) {\n            try {\n                acceptTransportType = ProtocolFactory.getTransportType(settings.getString(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL));\n            } catch (IllegalArgumentException e) {\n                throw new ConfigError(e);\n            }\n        }\n        boolean useSSL = false;\n        SSLConfig sslConfig = null;\n        if (getSettings().isSetting(sessionID, SSLSupport.SETTING_USE_SSL) && getSettings().getBool(sessionID, SSLSupport.SETTING_USE_SSL)) {\n            if (acceptTransportType == ProtocolFactory.SOCKET) {\n                useSSL = true;\n                sslConfig = SSLSupport.getSslConfig(getSettings(), sessionID);\n            } else {\n                log.warn(\"SSL will not be enabled for transport type={}, session={}\", acceptTransportType, sessionID);\n            }\n        }\n        int acceptPort = ((int) (settings.getLong(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PORT)));\n        String acceptHost = null;\n        if (settings.isSetting(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS)) {\n            acceptHost = settings.getString(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS);\n        }\n        SocketAddress acceptorAddress = ProtocolFactory.createSocketAddress(acceptTransportType, acceptHost, acceptPort);\n        AcceptorSocketDescriptor descriptor = socketDescriptorForAddress.get(acceptorAddress);\n        if (descriptor != null) {\n            if ((descriptor.isUseSSL() != useSSL) || (!equals(sslConfig, descriptor.getSslConfig()))) {\n                throw new ConfigError(\"Conflicting configurations of acceptor socket: \" + acceptorAddress);\n            }\n        } else {\n            descriptor = new AcceptorSocketDescriptor(acceptorAddress, useSSL, sslConfig);\n            socketDescriptorForAddress.put(acceptorAddress, descriptor);\n        }\n        if (!isTemplate) {\n            Session session = sessionFactory.create(sessionID, settings);\n            descriptor.acceptSession(session);\n            allSessions.put(sessionID, session);\n        }\n    }\n\n    private boolean equals(Object object1, Object object2) {\n        return object1 == null ? object2 == null : object1.equals(object2);\n    }\n\n    private void createSessions(SessionSettings settings, boolean continueInitOnError) throws ConfigError {\n        Map<SessionID, Session> allSessions = new HashMap<>();\n        for (Iterator<SessionID> i = settings.sectionIterator(); i.hasNext();) {\n            SessionID sessionID = i.next();\n            try {\n                String connectionType = null;\n                if (settings.isSetting(sessionID, SessionFactory.SETTING_CONNECTION_TYPE)) {\n                    connectionType = settings.getString(sessionID, SessionFactory.SETTING_CONNECTION_TYPE);\n                }\n                if (SessionFactory.ACCEPTOR_CONNECTION_TYPE.equals(connectionType)) {\n                    boolean isTemplate = false;\n                    if (settings.isSetting(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE)) {\n                        try {\n                            isTemplate = settings.getBool(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE);\n                        } catch (FieldConvertError | ConfigError ex) {\n                        }\n                    }\n                    setupSession(settings, sessionID, isTemplate, allSessions);\n                }\n            } catch (Throwable t) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for {}, continuing...\", sessionID, t);\n                } else {\n                    throw t instanceof ConfigError ? ((ConfigError) (t)) : new ConfigError(\"error during session initialization\", t);\n                }\n            }\n        }\n        setSessions(allSessions);\n        if (socketDescriptorForAddress.isEmpty()) {\n            throw new ConfigError(\"No acceptor sessions found in settings.\");\n        }\n    }\n\n    protected void stopAcceptingConnections() {\n        Iterator<IoAcceptor> ioIt = getEndpoints().iterator();\n        while (ioIt.hasNext()) {\n            IoAcceptor ioAcceptor = ioIt.next();\n            SocketAddress localAddress = ioAcceptor.getLocalAddress();\n            ioAcceptor.unbind();\n            closeManagedSessionsAndDispose(ioAcceptor, true, log);\n            log.info(\"No longer accepting connections on {}\", localAddress);\n            ioIt.remove();\n        } \n    }\n\n    private static class AcceptorSocketDescriptor {\n        private final SocketAddress address;\n\n        private final boolean useSSL;\n\n        private final SSLConfig sslConfig;\n\n        private final Map<SessionID, Session> acceptedSessions = new HashMap<>();\n\n        public AcceptorSocketDescriptor(SocketAddress address, boolean useSSL, SSLConfig sslConfig) {\n            this.address = address;\n            this.useSSL = useSSL;\n            this.sslConfig = sslConfig;\n        }\n\n        public void acceptSession(Session session) {\n            acceptedSessions.put(session.getSessionID(), session);\n        }\n\n        public Map<SessionID, Session> getAcceptedSessions() {\n            return Collections.unmodifiableMap(acceptedSessions);\n        }\n\n        public SocketAddress getAddress() {\n            return address;\n        }\n\n        public boolean isUseSSL() {\n            return useSSL;\n        }\n\n        public SSLConfig getSslConfig() {\n            return sslConfig;\n        }\n    }\n\n    public Collection<IoAcceptor> getEndpoints() {\n        return ioAcceptors.values();\n    }\n\n    public Map<SessionID, SocketAddress> getAcceptorAddresses() {\n        Map<SessionID, SocketAddress> sessionIdToAddressMap = new HashMap<>();\n        for (AcceptorSocketDescriptor descriptor : socketDescriptorForAddress.values()) {\n            for (SessionID sessionID : descriptor.getAcceptedSessions().keySet()) {\n                sessionIdToAddressMap.put(sessionID, descriptor.getAddress());\n            }\n        }\n        return sessionIdToAddressMap;\n    }\n\n    public void setSessionProvider(SocketAddress address, AcceptorSessionProvider provider) {\n        sessionProviders.put(address, provider);\n    }\n\n    static class StaticAcceptorSessionProvider implements AcceptorSessionProvider {\n        private final Map<SessionID, Session> acceptorSessions;\n\n        public StaticAcceptorSessionProvider(final Map<SessionID, Session> acceptorSessions) {\n            this.acceptorSessions = acceptorSessions;\n        }\n\n        public Session getSession(SessionID sessionID, SessionConnector connector) {\n            return acceptorSessions.get(sessionID);\n        }\n    }\n\n    public int getQueueSize() {\n        final EventHandlingStrategy ehs = getEventHandlingStrategy();\n        return ehs == null ? 0 : ehs.getQueueSize();\n    }\n\n    protected abstract EventHandlingStrategy getEventHandlingStrategy();\n\n    private class DefaultAcceptorSessionProvider implements AcceptorSessionProvider {\n        private final Map<SessionID, Session> acceptorSessions;\n\n        public DefaultAcceptorSessionProvider(Map<SessionID, Session> acceptorSessions) {\n            this.acceptorSessions = acceptorSessions;\n        }\n\n        public Session getSession(SessionID sessionID, SessionConnector ignored) {\n            Session session = acceptorSessions.get(sessionID);\n            if (session == null) {\n                SessionID reduced = reduceSessionID(sessionID);\n                session = acceptorSessions.get(reduced);\n            }\n            return session;\n        }\n\n        private SessionID reduceSessionID(SessionID sessionID) {\n            return new SessionID(sessionID.getBeginString(), sessionID.getSenderCompID(), sessionID.getTargetCompID());\n        }\n    }\n}\n",
    "project": "quickfixj",
    "libraryName": "mina-core",
    "libraryGroupID": "org.apache.mina",
    "newVersion": "2.2.1",
    "previousVersion": "2.1.5",
    "breakingCommit": "00a7cc31784ac4a9cc27d506a73ae589d6df36d6",
    "patch": "```java\npackage quickfix.mina.acceptor;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.security.GeneralSecurityException;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport javax.net.ssl.SSLContext;\nimport org.apache.mina.core.buffer.IoBuffer;\nimport org.apache.mina.core.buffer.SimpleBufferAllocator;\nimport org.apache.mina.core.service.IoAcceptor;\nimport org.apache.mina.filter.codec.ProtocolCodecFilter;\nimport quickfix.Acceptor;\nimport quickfix.Application;\nimport quickfix.ConfigError;\nimport quickfix.DefaultSessionFactory;\nimport quickfix.FieldConvertError;\nimport quickfix.LogFactory;\nimport quickfix.MessageFactory;\nimport quickfix.MessageStoreFactory;\nimport quickfix.RuntimeError;\nimport quickfix.ScreenLogFactory;\nimport quickfix.Session;\nimport quickfix.SessionFactory;\nimport quickfix.SessionID;\nimport quickfix.SessionSettings;\nimport quickfix.mina.CompositeIoFilterChainBuilder;\nimport quickfix.mina.EventHandlingStrategy;\nimport quickfix.mina.NetworkingOptions;\nimport quickfix.mina.ProtocolFactory;\nimport quickfix.mina.SessionConnector;\nimport quickfix.mina.message.FIXProtocolCodecFactory;\nimport quickfix.mina.ssl.SSLConfig;\nimport quickfix.mina.ssl.SSLContextFactory;\nimport quickfix.mina.ssl.SSLFilter;\nimport quickfix.mina.ssl.SSLSupport;\npublic abstract class AbstractSocketAcceptor extends SessionConnector implements Acceptor {\n    private final Map<SocketAddress, AcceptorSessionProvider> sessionProviders = new HashMap<>();\n\n    private final SessionFactory sessionFactory;\n\n    private final Map<SocketAddress, AcceptorSocketDescriptor> socketDescriptorForAddress = new HashMap<>();\n\n    private final ConcurrentMap<AcceptorSocketDescriptor, IoAcceptor> ioAcceptors = new ConcurrentHashMap<>();\n\n    protected AbstractSocketAcceptor(SessionSettings settings, SessionFactory sessionFactory) throws ConfigError {\n        super(settings, sessionFactory);\n        IoBuffer.setAllocator(new SimpleBufferAllocator());\n        IoBuffer.setUseDirectBuffer(false);\n        this.sessionFactory = sessionFactory;\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, MessageFactory messageFactory) throws ConfigError {\n        this(settings, new DefaultSessionFactory(application, messageStoreFactory, getLogFactory(), messageFactory));\n    }\n\n    protected AbstractSocketAcceptor(Application application, MessageStoreFactory messageStoreFactory, SessionSettings settings, LogFactory logFactory, MessageFactory messageFactory) throws ConfigError {\n        this(settings, new DefaultSessionFactory(application, messageStoreFactory, logFactory, messageFactory));\n    }\n\n    protected synchronized void startAcceptingConnections() throws ConfigError {\n        boolean continueInitOnError = isContinueInitOnError();\n        createSessions(getSettings(), continueInitOnError);\n        startSessionTimer();\n        SocketAddress address = null;\n        for (AcceptorSocketDescriptor socketDescriptor : socketDescriptorForAddress.values()) {\n            try {\n                address = socketDescriptor.getAddress();\n                IoAcceptor ioAcceptor = getIoAcceptor(socketDescriptor);\n                CompositeIoFilterChainBuilder ioFilterChainBuilder = new CompositeIoFilterChainBuilder(getIoFilterChainBuilder());\n                if (socketDescriptor.isUseSSL()) {\n                    installSSL(socketDescriptor, ioFilterChainBuilder);\n                }\n                ioFilterChainBuilder.addLast(FIXProtocolCodecFactory.FILTER_NAME, new ProtocolCodecFilter(new FIXProtocolCodecFactory()));\n                ioAcceptor.setFilterChainBuilder(ioFilterChainBuilder);\n                ioAcceptor.setCloseOnDeactivation(false);\n                ioAcceptor.bind(socketDescriptor.getAddress());\n                log.info(\"Listening for connections at {} for session(s) {}\", address, socketDescriptor.getAcceptedSessions().keySet());\n            } catch (IOException | GeneralSecurityException | ConfigError e) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for session(s) {}, continuing...\", socketDescriptor.getAcceptedSessions().keySet(), e);\n                } else {\n                    log.error(\"Cannot start acceptor session for {}, error: {}\", address, e);\n                    throw new RuntimeError(e);\n                }\n            }\n        }\n    }\n\n    private void installSSL(AcceptorSocketDescriptor descriptor, CompositeIoFilterChainBuilder ioFilterChainBuilder) throws GeneralSecurityException {\n        log.info(\"Installing SSL filter for {}\", descriptor.getAddress());\n        SSLConfig sslConfig = descriptor.getSslConfig();\n        SSLContext sslContext = SSLContextFactory.getInstance(sslConfig);\n        SSLFilter sslFilter = new SSLFilter(sslContext);\n        sslFilter.setUseClientMode(false);\n        sslFilter.setNeedClientAuth(sslConfig.isNeedClientAuth());\n        sslFilter.setCipherSuites(sslConfig.getEnabledCipherSuites() != null ? sslConfig.getEnabledCipherSuites() : SSLSupport.getDefaultCipherSuites(sslContext));\n        sslFilter.setProtocols(sslConfig.getEnabledProtocols() != null ? sslConfig.getEnabledProtocols() : SSLSupport.getSupportedProtocols(sslContext));\n        ioFilterChainBuilder.addLast(SSLSupport.FILTER_NAME, sslFilter);\n    }\n\n    private IoAcceptor getIoAcceptor(AcceptorSocketDescriptor socketDescriptor) throws ConfigError {\n        int transportType = ProtocolFactory.getAddressTransportType(socketDescriptor.getAddress());\n        AcceptorSessionProvider sessionProvider = sessionProviders.computeIfAbsent(socketDescriptor.getAddress(), k -> new StaticAcceptorSessionProvider(Collections.emptyMap()));\n        IoAcceptor ioAcceptor = ioAcceptors.get(socketDescriptor);\n        if (ioAcceptor == null) {\n            ioAcceptor = ProtocolFactory.createIoAcceptor(transportType);\n            try {\n                SessionSettings settings = getSettings();\n                NetworkingOptions networkingOptions = new NetworkingOptions(settings.getDefaultProperties());\n                networkingOptions.apply(ioAcceptor);\n                ioAcceptor.setHandler(new AcceptorIoHandler(sessionProvider, settings, networkingOptions, getEventHandlingStrategy()));\n            } catch (FieldConvertError e) {\n                throw new ConfigError(e);\n            }\n            ioAcceptors.put(socketDescriptor, ioAcceptor);\n        }\n        return ioAcceptor;\n    }\n\n    private void setupSession(SessionSettings settings, SessionID sessionID, boolean isTemplate, Map<SessionID, Session> allSessions) throws ConfigError, FieldConvertError {\n        int acceptTransportType = ProtocolFactory.SOCKET;\n        if (settings.isSetting(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL)) {\n            try {\n                acceptTransportType = ProtocolFactory.getTransportType(settings.getString(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PROTOCOL));\n            } catch (IllegalArgumentException e) {\n                throw new ConfigError(e);\n            }\n        }\n        boolean useSSL = false;\n        SSLConfig sslConfig = null;\n        if (getSettings().isSetting(sessionID, SSLSupport.SETTING_USE_SSL) && getSettings().getBool(sessionID, SSLSupport.SETTING_USE_SSL)) {\n            if (acceptTransportType == ProtocolFactory.SOCKET) {\n                useSSL = true;\n                sslConfig = SSLSupport.getSslConfig(getSettings(), sessionID);\n            } else {\n                log.warn(\"SSL will not be enabled for transport type={}, session={}\", acceptTransportType, sessionID);\n            }\n        }\n        int acceptPort = ((int) (settings.getLong(sessionID, Acceptor.SETTING_SOCKET_ACCEPT_PORT)));\n        String acceptHost = null;\n        if (settings.isSetting(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS)) {\n            acceptHost = settings.getString(sessionID, SETTING_SOCKET_ACCEPT_ADDRESS);\n        }\n        SocketAddress acceptorAddress = ProtocolFactory.createSocketAddress(acceptTransportType, acceptHost, acceptPort);\n        AcceptorSocketDescriptor descriptor = socketDescriptorForAddress.get(acceptorAddress);\n        if (descriptor != null) {\n            if ((descriptor.isUseSSL() != useSSL) || (!equals(sslConfig, descriptor.getSslConfig()))) {\n                throw new ConfigError(\"Conflicting configurations of acceptor socket: \" + acceptorAddress);\n            }\n        } else {\n            descriptor = new AcceptorSocketDescriptor(acceptorAddress, useSSL, sslConfig);\n            socketDescriptorForAddress.put(acceptorAddress, descriptor);\n        }\n        if (!isTemplate) {\n            Session session = sessionFactory.create(sessionID, settings);\n            descriptor.acceptSession(session);\n            allSessions.put(sessionID, session);\n        }\n    }\n\n    private boolean equals(Object object1, Object object2) {\n        return object1 == null ? object2 == null : object1.equals(object2);\n    }\n\n    private void createSessions(SessionSettings settings, boolean continueInitOnError) throws ConfigError {\n        Map<SessionID, Session> allSessions = new HashMap<>();\n        for (Iterator<SessionID> i = settings.sectionIterator(); i.hasNext();) {\n            SessionID sessionID = i.next();\n            try {\n                String connectionType = null;\n                if (settings.isSetting(sessionID, SessionFactory.SETTING_CONNECTION_TYPE)) {\n                    connectionType = settings.getString(sessionID, SessionFactory.SETTING_CONNECTION_TYPE);\n                }\n                if (SessionFactory.ACCEPTOR_CONNECTION_TYPE.equals(connectionType)) {\n                    boolean isTemplate = false;\n                    if (settings.isSetting(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE)) {\n                        try {\n                            isTemplate = settings.getBool(sessionID, Acceptor.SETTING_ACCEPTOR_TEMPLATE);\n                        } catch (FieldConvertError | ConfigError ex) {\n                        }\n                    }\n                    setupSession(settings, sessionID, isTemplate, allSessions);\n                }\n            } catch (Throwable t) {\n                if (continueInitOnError) {\n                    log.warn(\"error during session initialization for {}, continuing...\", sessionID, t);\n                } else {\n                    throw t instanceof ConfigError ? ((ConfigError) (t)) : new ConfigError(\"error during session initialization\", t);\n                }\n            }\n        }\n        setSessions(allSessions);\n        if (socketDescriptorForAddress.isEmpty()) {\n            throw new ConfigError(\"No acceptor sessions found in settings.\");\n        }\n    }\n\n    protected void stopAcceptingConnections() {\n        Iterator<IoAcceptor> ioIt = getEndpoints().iterator();\n        while (ioIt.hasNext()) {\n            IoAcceptor ioAcceptor = ioIt.next();\n            SocketAddress localAddress = ioAcceptor.getLocalAddress();\n            ioAcceptor.unbind();\n            closeManagedSessionsAndDispose(ioAcceptor, true, log);\n            log.info(\"No longer accepting connections on {}\", localAddress);\n            ioIt.remove();\n        }\n    }\n\n    private static class AcceptorSocketDescriptor {\n        private final SocketAddress address;\n\n        private final boolean useSSL;\n\n        private final SSLConfig sslConfig;\n\n        private final Map<SessionID, Session> acceptedSessions = new HashMap<>();\n\n        public AcceptorSocketDescriptor(SocketAddress address, boolean useSSL, SSLConfig sslConfig) {\n            this.address = address;\n            this.useSSL = useSSL;\n            this.sslConfig = sslConfig;\n        }\n\n        public void acceptSession(Session session) {\n            acceptedSessions.put(session.getSessionID(), session);\n        }\n\n        public Map<SessionID, Session> getAcceptedSessions() {\n            return Collections.unmodifiableMap(acceptedSessions);\n        }\n\n        public SocketAddress getAddress() {\n            return address;\n        }\n\n        public boolean isUseSSL() {\n            return useSSL;\n        }\n\n        public SSLConfig getSslConfig() {\n            return sslConfig;\n        }\n    }\n\n    public Collection<IoAcceptor> getEndpoints() {\n        return ioAcceptors.values();\n    }\n\n    public Map<SessionID, SocketAddress> getAcceptorAddresses() {\n        Map<SessionID, SocketAddress> sessionIdToAddressMap = new HashMap<>();\n        for (AcceptorSocketDescriptor descriptor : socketDescriptorForAddress.values()) {\n            for (SessionID sessionID : descriptor.getAcceptedSessions().keySet()) {\n                sessionIdToAddressMap.put(sessionID, descriptor.getAddress());\n            }\n        }\n        return sessionIdToAddressMap;\n    }\n\n    public void setSessionProvider(SocketAddress address, AcceptorSessionProvider provider) {\n        sessionProviders.put(address, provider);\n    }\n\n    public static class StaticAcceptorSessionProvider implements AcceptorSessionProvider {\n        private final Map<SessionID, Session> acceptorSessions;\n\n        public StaticAcceptorSessionProvider(final Map<SessionID, Session> acceptorSessions) {\n            this.acceptorSessions = acceptorSessions;\n        }\n\n        public Session getSession(SessionID sessionID, SessionConnector ignored) {\n            Session session = acceptorSessions.get(sessionID);\n            if (session == null) {\n                SessionID reduced = reduceSessionID(sessionID);\n                session = acceptorSessions.get(reduced);\n            }\n            return session;\n        }\n\n        private SessionID reduceSessionID(SessionID sessionID) {\n            return new SessionID(sessionID.getBeginString(), sessionID.getSenderCompID(), sessionID.getTargetCompID());\n        }\n    }\n}\n```<end_of_turn>"
}